
.. index::  program structure

.. _program-structure:

C# Program Structure
=====================

The .NET templates
----------------------

The .NET SDK comes with built-in templates for creating projects and files, including console apps, 
class libraries, unit test projects, etc. For learning purposes, we will mainly use the console app 
template. To see the list of templates, you may issue the ``dotnet new list`` command:

.. code-block:: console
   :emphasize-lines: 10


   PS C:\Users\tcn85> dotnet new list
   These templates matched your input:
   
   Template Name                                 Short Name                  Language    Tags
   --------------------------------------------  --------------------------  ----------  --------------------------
   ASP.NET Core Web App (Model-View-Controller)  mvc                         [C#],F#     Web/MVC
   ASP.NET Core Web App (Razor Pages)            webapp,razor                [C#]        Web/MVC/Razor Pages
   Blazor Web App                                blazor                      [C#]        Web/Blazor/WebAssembly
   Class Library                                 classlib                    [C#],F#,VB  Common/Library
   Console App                                   console                     [C#],F#,VB  Common/Console


We can try out the Console App template, which will give us a "Hello, World" message 
when executing, by using either the terminal. In the terminal, let us 
change directory (``cd``) into the test directory and issue command ``dotnet new console``. 
The .NET SDK will generate a project for us, which will include the following files and 
directories: 

#. The ``Program.cs`` file
#. The ``obj`` folder
#. The ``testPrj.csproj`` file
#. A ``bin`` directory will also be created.


.. code-block:: console
   :emphasize-lines: 9

   PS C:\Users\tcn85> cd test                                                                                              PS C:\Users\tcn85\test> dotnet new console
   The template "Console App" was created successfully.
   .....   
   PS C:\Users\tcn85\test> ls
      Directory: C:\Users\tcn85\test
   Mode                 LastWriteTime         Length Name
   ----                 -------------         ------ ----
   d-----          8/7/2024   2:54 PM                obj
   -a----          8/7/2024   2:54 PM            105 Program.cs
   -a----          8/7/2024   2:54 PM            252 test.csproj
   -a----         7/26/2024   5:06 PM              0 test.txt
   PS C:\Users\tcn85\test>

From the terminal we can open vscode by typing ``code`` and Enter. 

.. code-block:: console

   PS C:\Users\tcn85\test> code
   PS C:\Users\tcn85\test>

VS Code will open (and may generate some extra solution files). We then choose the 
Explorer view and click on the Program.cs file. You will see that the Program.cs looks 
simple as below and we are working the executable code directly. 

.. code-block:: c#
   :linenos:

   // See https://aka.ms/new-console-template for more information
   Console.WriteLine("Hello, World!");


The template is very succinct because of a C# feature called "top-level statements", with 
which the compiler automatically performs some tasks later: 

   - generates a Program class with an entry point method for the application; and 
   - adds a set of implicit ``global using`` directives such as Microsoft.NET.Sdk to include the most common namespaces. 
   

While this friendly to new users, as we learn more about C# programming, 
you will need to learn how to structure your code using namespaces and classes. 
To use the old program style, you can use the ``--use-program-main`` 
option to create a console app project with ``Main method``. In the example 
below, we first create a testPrj folder inside the tests folder, then change into the 
testPrj folder, followed by issuing ``dotnet new console`` with the option ``--use-program-main``
to create a new console project:

.. code-block:: console

   tychen@mac:~/tests/testPrj$ dotnet new console --use-program-main

This will give us the same project files as running dotnet new console without the "---program-main" 
option, but the Program.cs file will be different:



.. code-block:: console

   tychen@mac:~/tests/testPrj$ ls
   Program.cs     obj            testPrj.csproj


The C# Program.cs file
-----------------------

Opening the Program.cs file created by ``dotnet new console --use-program-main`` 
and you see the template code as:

.. code-block:: c#
   :linenos:
   :emphasize-lines: 5

   namespace testPrj; 

   class Program
   {
      static void Main(string[] args)
      {
            Console.WriteLine("Hello, World!");
      }
   }

Some important concepts that we need to learn from this template code example 
here so we have better ideas about the basic structure of C#.

#. ``namespace``: 
   The ``namespace`` keyword is used to declare a scope to organize types. 
   For example, we may define a namespace as below 
   to contain unique **reference type** code elements. We are not 
   going to dive into the reference types now and we only need to observe that 
   that these are the types (class, interface, struct, ...) that C# programmer 
   create functionalities for the app.  

   .. code-block:: 

      namespace SampleNamespace
      {
          class SampleClass { }
          interface ISampleInterface { }
          struct SampleStruct { }
          enum SampleEnum { a, b }
          delegate void SampleDelegate(int i);
          namespace Nested
          {
              class SampleClass2 { }
          }
      }

#. ``using System;``:  

   Starting .NET 6, ``using System`` is implicit as defined in the csproj file so 
   now shown in the Program.cs file. We should know that, ``System`` is a namespace that contains basic defined value 
   and reference types. The ``using`` directive, works like "import", allows you to use the types defined in 
   a namespace without specifying the fully qualified namespace of that type. 
   The ``using`` directive imports all the types from a single namespace. For example, 
   ``Console`` is a class inside the ``System`` namespace and we use the its WriteLine 
   method to print to the console. The following example would allow the use of the 
   ``Text`` types such as System.Text.Ascii class and the nested namespace 
   System.Text.Unicode:

   .. code-block:: 

      using System.Text;

#. ``class``:
   A class is a blueprint for creating objects, which may include the structure, 
   behaviors, and attributes of the objects. A class can be thought of a user-defined 
   data type (reference data type) containing 
   - attributes (data) and 
   - methods (actions applied to the data).  

#. The ``Main`` method:
   The most common Main methods of a C# program are probably ``static void Main()`` 
   and ``static void Main(String []args)``. The Main method is the entry point 
   of a program and therefore the first method invoked when an application is executed. 

#. ``method``:
   A method is an object-oriented term for function, which is a series of statements 
   designed to perform certain task. In C#, just like Java, the Main method is the 
   entry point of the program, meaning it is the first method invoked when a 
   program is executed. 

#. ``static`` & ``void``:
   The modifier ``static`` means the Main Method can be called without creating 
   a new object from the class. ``void`` means the Main method does not return anything. 

#. ``string[] args``:
   The ``args`` are called "command line arguments" and in this example the type is 
   string array; meaning when calling this method we send the arguments in and they 
   are zero-indexed as an array.  
   

Solutions and projects
-----------------------

The .NET platform uses *solutions* and *projects* to organize code items in specific structure. 
A solution is a container or workspace for one or more projects, and each project would 
contain source code files [#]_. A web app solution, for example, may include a website project, 
a database project, and a server-side API project; and each of the project will be named 
differently under different project folders inside the solution directory.

The idea of a project is probably what comes to mind first when beginning with the development 
of an application. To create a project, you may go to the project directory in command line 
and simply issue the command of ``dotnet new console`` to create an app project. This will 
create your project without a solution. 

On the other hand, the first time you create a project in a folder using vscode's Create .NET 
Project button in the Explorer view, a solution will be created with the same name as the 
project. This may not be ideal since we may not want the solution to be named the same as 
the first project. A better way to create a solution, therefore, may be to create a solution 
by issuing commands ``dotnet new sln`` in your solution directory. 


For now consider a small, 
artificial example program,
:repsrc:`update_vars/update_vars.cs`,
emphasizing the ability to *reassign* variable values. 
 
.. literalinclude:: ../../examples/introcs/update_vars/update_vars.cs
   :linenos:
       
Can you *predict* the result? Run the program and check.
Particularly if you did not guess right, it is important to
understand what happens, one step at a time. That means keeping
track of what changes to variables are made by each statement.

In the table below, statements are referred to by the numbers labeling
the lines in the code above. We can track the state of each
variable after each line is executed. A dash is shown where a
variable is not yet defined. For instance after line 7 is executed, a
value is given to x, but y is still undefined. Then y gets a value
in line 8. 
The comment space can be used any time
it is helpful.  In particular it should be used  when something
is printed, since this
important action does *not* affect the variable list.

====  ==  ==  =======================================
Line  x   y   Comment
====  ==  ==  =======================================
5     \-  \-  Start at beginning of Main
7     3   \-  initialize x
8     3   5   5=3+2, using the value of x from the previous line
9     3   10  10=2*5 on the right; use the value of y from the
              previous line
10    7   10  7=10-3 on the right; use the value of x and y from the
              previous line
11    7   10  print: 7 10
====  ==  ==  =======================================

The critical point here is to always use the most recently assigned value
of each variable.  Unlike in math, symbol values change!

The order of execution will always be the order of the lines in our
table. In this simple *sequential* code, that *also* follows the
textual order of the program. 

Following each line of execution of a
program in the proper order of execution, carefully, 
keeping track of the current values of
variables, will be called *playing computer*. A table like the one
above is an organized way to keep track.

The line numbering is not very exciting in a simple sequential program,
but it will become very important when we get to other execution sequences.
We start with the simple sequential numbering now for consistency, as
we get used to the idea of such a table following execution sequence.

.. index::  playing computer; exercise
   exercise; playing computer

.. _playing-computer-exercise:
   
Play Computer Exercise
~~~~~~~~~~~~~~~~~~~~~~~

Here is a similar program,
:repsrc:`update_vars2/update_vars2.cs`:
 
.. literalinclude:: ../../examples/introcs/update_vars2/update_vars2.cs
   :linenos:

Play computer, completing the table

====  ==  ==  =======================================
Line  a   b   Comment
====  ==  ==  =======================================
5     \-  \-  Start at beginning of Main
7     5   \-  initialize a
8     
9     
10    
11    
12    
====  ==  ==  =======================================

Another Play Computer Exercise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A silly one on the same line:
:repsrc:`update_vars3/update_vars3.cs`:
 
.. literalinclude:: ../../examples/introcs/update_vars3/update_vars3.cs
   :linenos:

Play computer, completing the table

====  ========  ======  =============================
Line  s         t       Comment
====  ========  ======  =============================
5     \-        \-      Start at beginning of Main
7      
8     
9     
10    
11    
12  
====  ========  ======  =============================

.. [#] Although a solution is not required for projects to execute, it offer some benefits such as project configuration and building all projects at once. 
