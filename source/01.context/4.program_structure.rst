
.. index::  program structure

.. _program-structure:

C# Project Structure
=====================

When we generate a "hello, world" console app using either the terminal or vscode, we 
see that our Program.cs looks simple as below and we can write the executable code 
directly. 

.. code-block:: c#

   // See https://aka.ms/new-console-template for more information
   Console.WriteLine("Hello, World!");


This is a C# feature called "top-level statements" in which the compiler will: 

   - generate a Program class with an entry point method for the application; and 
   - adds a set of implicit ``global using`` directives such as Microsoft.NET.Sdk to include the most common namespaces. 
   
While this friendly to new users, as we learn more about C# programming, 
you will need to learn how to structure your code using namespaces and classes. 
To use the old program style, you can use the ``--use-program-main`` 
option to create a console app project with Main method. In the example 
below, we use ``dotnet new console``` to create a new console project in the 
empty testPrj directory:

.. code-block:: console

   tychen@mac:~/workspace/tests/testPrj$ dotnet new console --use-program-main

This will give us the project files such as:

#. The ``Program.cs`` file
#. The ``obj`` folder
#. The ``testPrj.csproj`` file
#. A ``bin`` directory will also be created.

.. code-block:: console

   tychen@mac:~/workspace/tests/testPrj$ ls
   Program.cs     obj            testPrj.csproj


The C# Program.cs file
-----------------------

Opening the Program.cs file created by ``dotnet new console --use-program-main`` 
and you see the template code as:

.. code-block:: c#
   :linenos:
   :emphasize-lines: 5

   namespace testPrj; 

   class Program
   {
      static void Main(string[] args)
      {
            Console.WriteLine("Hello, World!");
      }
   }

Some important concepts that we need to learn from this template code example 
here so we have better ideas about the basic structure of C#.

#. ``namespace``: 
   The ``namespace`` keyword is used to declare a scope to organize types. 
   For example, we may define a namespace as below 
   to contain unique **reference type** code elements. We are not 
   going to dive into the reference types now and we only need to observe that 
   that these are the types (class, interface, struct, ...) that C# programmer 
   create functionalities for the app.  

   .. code-block:: 

      namespace SampleNamespace
      {
          class SampleClass { }
          interface ISampleInterface { }
          struct SampleStruct { }
          enum SampleEnum { a, b }
          delegate void SampleDelegate(int i);
          namespace Nested
          {
              class SampleClass2 { }
          }
      }

#. ``using System;``:  

   Starting .NET 6, ``using System`` is implicit as defined in the csproj file so 
   now shown in the Program.cs file. We should know that, ``System`` is a namespace that contains basic defined value 
   and reference types. The ``using`` directive, works like "import", allows you to use the types defined in 
   a namespace without specifying the fully qualified namespace of that type. 
   The ``using`` directive imports all the types from a single namespace. For example, 
   ``Console`` is a class inside the ``System`` namespace and we use the its WriteLine 
   method to print to the console. The following example would allow the use of the 
   ``Text`` types such as System.Text.Ascii class and the nested namespace 
   System.Text.Unicode:

   .. code-block:: 

      using System.Text;

#. ``class``:
   A class is a blueprint for creating objects, which may include the structure, 
   behaviors, and attributes of the objects. A class can be thought of a user-defined 
   data type (reference data type) containing 
   - attributes (data) and 
   - methods (actions applied to the data).  

#. The ``Main`` method:
   The most common Main methods of a C# program are probably ``static void Main()`` 
   and ``static void Main(String []args)``. The Main method is the entry point 
   of a program and therefore the first method invoked when an application is executed. 

#. ``method``:
   A method is an object-oriented term for function, which is a series of statements 
   designed to perform certain task. In C#, just like Java, the Main method is the 
   entry point of the program, meaning it is the first method invoked when a 
   program is executed. 

#. ``static`` & ``void``:
   The modifier ``static`` means the Main Method can be called without creating 
   a new object from the class. ``void`` means the Main method does not return anything. 

#. ``string[] args``:
   The ``args`` are called "command line arguments" and in this example the type is 
   string array; meaning when calling this method we send the arguments in and they 
   are zero-indexed as an array.  
   

Indentation Help
-----------------------

Using conventional indentation helps understand a program and find errors, 
like unmatched braces. When you press return in a C# source file 
(i.e. a file with name ending in ``.cs``), Xamarin Studio makes a guess at the proper
indentation of the next line.  The exact reaction can be set in the *options*.
The simplest approach is to set these options *once* for all new files 
in a solution, like your work solution:

#. Access the context menu for the *whole solution* (not one project).
#. Select Options.
   
   .. image:: ../images/select_options.png
      :width: 200 pt
   
#. In the popup Solution Options Window, you will see "Code Formatting" 
   in the left column.  If you do not see "C# source code" and then "Text file"
   right underneath it
   click on "Code Formatting" to expand the hierarchy.
  
   .. image:: ../images/set_indent.png 
      :width: 300 pt
   
#. Click on **C# source code**, and then the right side should show options.  
   Adjust them to look like the picture: tab and indent widths 3, 
   first and last check boxes *checked* 
   (Convert tabs to spaces. Remove trailing spaces),
   and have the middle check box (Allow tabs after non-tabs) *unchecked*.
#. Click OK in the bottom right corner.
 

Solutions and projects
-----------------------

The .NET platform uses *solutions* and *projects* to organize code items in specific structure. 
A solution is a container or workspace for one or more projects, and each project would 
contain source code files [#]_. A web app solution, for example, may include a website project, 
a database project, and a server-side API project; and each of the project will be named 
differently under different project folders inside the solution directory.

The idea of a project is probably what comes to mind first when beginning with the development 
of an application. To create a project, you may go to the project directory in command line 
and simply issue the command of ``dotnet new console`` to create an app project. This will create a 
project without a solution. 

On the other hand, the first time you create a project in a folder using vscode's Create .NET 
Project button in the Explorer view, a solution will be created with the same name as the 
project. This may not be ideal since we may not want the solution to be named the same as 
the first project. A better way to create a solution, therefore, may be to create a solution 
by issuing commands ``dotnet new sln`` in your solution directory. 


.. index:: compiler error; explanation link

Compiler Error Help
-----------------------

There are an enormous number of possible *syntactic* errors in your source code
that the compiler
can detect.  

.. index:: editor error annotations
   syntax error annotations in editor
   Xamarin Studio; editor error annotations
   logical error
   run-time error
   
**Errors shown** *while* **editing**:  If you use an editor like Xamarin Studio, 
some of these errors are even checked while you type and are
noted while you are editing.  They may be indicated with a 
red squiggly underline, and possibly a red comment at the right.  Sometimes
the squiggle is just because you are in the middle of something, but if it
is still there after you complete a whole statement, there may well
be an issue to look at.  Sometimes fixing the issue makes the annotation
go away, but sometimes your program may really be fixed, 
even though the error annotation
does not go away *until you formally compile/build the whole program*.
This annoying ambiguity leads some people to turn off error annotations,
and just let
the system note errors after a complete compile cycle.

After compiling and getting an error, sometimes reading the error description 
carefully  will help you 
understand the problem.  Sometimes the error is very cryptic.   In those cases
it might help to look at the C# .NET error documentation,

   http://msdn.microsoft.com/en-us/library/ms228296.aspx.

Each compiler error you make has a number shown in its description. 
Many of these error numbers are shown in the left column
of the linked page.  You can click to get a more complete explanation and 
examples.

Another important way to learn about the error messages is to leverage your
experience:  After 
you have eventually found how to fix your error, *allow the extra time* to
use your new knowledge,
look *back* at the original error message,
and see if the error description text makes more sense now.  
That should help next time,
(and there usually is a next time). Even when the error description still 
makes no particular sense, you may well get into the same situation again,
with the same error number.  Then 
remembering the issue you found in a previous time could help.

Debugging can eat up an enormous amount of time, 
so it is really worth your effort to understand the errors that you tend to make
and the errors' relation to the error messages that you get.

.. warning::
   It is certainly helpful that the compiler finds *syntactic* errors for you,
   but be sure to remember that compiling does *not* mean the program
   will "work" and correctly do what you desire.  Test your compiled program
   thoroughly to reduce the chance of *logical* errors remaining, that
   cause *run-time* errors, or just the wrong results.
 
.. index:: sequential execution order
   execution; sequential order
   playing computer
 
.. _sequential-execution:
     
Sequential Execution
----------------------

A function like ``Main`` involves a sequence of statements to execute.
The basic order of execution is *sequential*: 
first statement, then second, ....
This is the same as the *textual order*, so it is easy to follow.  Later in
:ref:`Defining-Own-Functions`, :ref:`If-Statements`, and :ref:`While-Loops`,
we will see more complicated 
execution orders that do *not* match textual order.
Whatever the order of execution given by the program, it is important to
always keep track of the current state of the program, 
one statement at a time: what statement was just executed,
what are the values of variables after that statement's execution, 
and what will be executed next. 

For now consider a small, 
artificial example program,
:repsrc:`update_vars/update_vars.cs`,
emphasizing the ability to *reassign* variable values. 
 
.. literalinclude:: ../../examples/introcs/update_vars/update_vars.cs
   :linenos:
       
Can you *predict* the result? Run the program and check.
Particularly if you did not guess right, it is important to
understand what happens, one step at a time. That means keeping
track of what changes to variables are made by each statement.

In the table below, statements are referred to by the numbers labeling
the lines in the code above. We can track the state of each
variable after each line is executed. A dash is shown where a
variable is not yet defined. For instance after line 7 is executed, a
value is given to x, but y is still undefined. Then y gets a value
in line 8. 
The comment space can be used any time
it is helpful.  In particular it should be used  when something
is printed, since this
important action does *not* affect the variable list.

====  ==  ==  =======================================
Line  x   y   Comment
====  ==  ==  =======================================
5     \-  \-  Start at beginning of Main
7     3   \-  initialize x
8     3   5   5=3+2, using the value of x from the previous line
9     3   10  10=2*5 on the right; use the value of y from the
              previous line
10    7   10  7=10-3 on the right; use the value of x and y from the
              previous line
11    7   10  print: 7 10
====  ==  ==  =======================================

The critical point here is to always use the most recently assigned value
of each variable.  Unlike in math, symbol values change!

The order of execution will always be the order of the lines in our
table. In this simple *sequential* code, that *also* follows the
textual order of the program. 

Following each line of execution of a
program in the proper order of execution, carefully, 
keeping track of the current values of
variables, will be called *playing computer*. A table like the one
above is an organized way to keep track.

The line numbering is not very exciting in a simple sequential program,
but it will become very important when we get to other execution sequences.
We start with the simple sequential numbering now for consistency, as
we get used to the idea of such a table following execution sequence.

.. index::  playing computer; exercise
   exercise; playing computer

.. _playing-computer-exercise:
   
Play Computer Exercise
~~~~~~~~~~~~~~~~~~~~~~~

Here is a similar program,
:repsrc:`update_vars2/update_vars2.cs`:
 
.. literalinclude:: ../../examples/introcs/update_vars2/update_vars2.cs
   :linenos:

Play computer, completing the table

====  ==  ==  =======================================
Line  a   b   Comment
====  ==  ==  =======================================
5     \-  \-  Start at beginning of Main
7     5   \-  initialize a
8     
9     
10    
11    
12    
====  ==  ==  =======================================

Another Play Computer Exercise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A silly one on the same line:
:repsrc:`update_vars3/update_vars3.cs`:
 
.. literalinclude:: ../../examples/introcs/update_vars3/update_vars3.cs
   :linenos:

Play computer, completing the table

====  ========  ======  =============================
Line  s         t       Comment
====  ========  ======  =============================
5     \-        \-      Start at beginning of Main
7      
8     
9     
10    
11    
12  
====  ========  ======  =============================

.. [#] Although a solution is not required for projects to execute, it offer some benefits such as project configuration and building all projects at once. 
