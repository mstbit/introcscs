.. index:: list


.. _listsyntax:

List Syntax
===============

Arrays are fine if you know ahead of time how long your sequence of items is.
Then you create your array with that length, and you are all set.

If you want a variable sized container, you are likely to want a ``List``.  
As with arrays, you might want a collection of any particular type. 
Unfortunately, you cannot use the simple notation of arrays to specify
the type of element in a ``List``. Array syntax is
*built into* the language. Lists are handled in the *library* of types
provided by C# from .NET. There are all sorts of situations where you might want 
a general idea to have a version for each of many kinds of objects. 


.. index:: generics
   < > for generics

Generics
-----------

.NET 4.0 introduced one new form of syntax that can apply to all sorts of
classes, *generics*.

The type for a list of strings is ::

    List<string>
    
The type for an ``int`` list is ::

    List<int>

In general, the new generic syntax allows a type in angle
brackets after a class (e.g., List) name. There is a namespace for the generics 
for collections, including List: ``System.Collections.Generic``. You used to have 
to use the ``using`` directive to *import* the features offered by the class but 
C# now does it automatically. 

We will use several generic library classes, though we will not write the definitions of 
new generic classes ourselves.


.. index::
   single: List; constructor
   single: List; Count
   single: List; Add
   single: List; Remove
   single: List; RemoveAt
   single: List; Contains
   
List Constructors and Methods
-------------------------------

We can play with some ``List`` methods in csharprepl. Note that csharprepl 
informally displays the value of a ``List`` with a list of elements inside braces.  
This is *not* a legal way to assign values to lists.   

The blocks below are all from one csharprepl session, with our comments 
breaking up the sequence. With the no-parameter constructor, 
the ``List`` is empty to start:

..  code-block:: none

	> List<string> words = new List<string>();
	> words;
	List<string>(0)
	> words.Count
	0
	
You can add elements, and keep count with the ``Count`` property 
as the size changes:

..  code-block:: none

	> words.Add("Apple");
	> words
	List<string>(1)
	┌──────┬─────────┬────────┐
	│ Name │ Value   │ Type   │
	├──────┼─────────┼────────┤
	│ [0]  │ "Apple" │ string │
	└──────┴─────────┴────────┘
	> words.Add("Banana");
	> words             
	List<string>(2)
	┌──────┬──────────┬────────┐
	│ Name │ Value    │ Type   │
	├──────┼──────────┼────────┤
	│ [0]  │ "Apple"  │ string │
	│ [1]  │ "Banana" │ string │
	└──────┴──────────┴────────┘
	> words.Add("Cherry"); 
	> words             
	List<string>(3)
 	┌──────┬──────────┬────────┐
 	│ Name │ Value    │ Type   │
 	├──────┼──────────┼────────┤
 	│ [0]  │ "Apple"  │ string │
 	│ [1]  │ "Banana" │ string │
 	│ [2]  │ "Cherry" │ string │
 	└──────┴──────────┴────────┘
	> words.Count;
	┌───────────────────────────────────────────CompilationErrorException────────────────────────────────────────────┐
	│ (1,1): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be     │
	│ used as a statement                                                                                            │
	└────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
	> words.Count
	3
	
.. index::  list; index [ ]
   single: [ ]; list index
   
You can reference and change elements by index, like with ``arrays``:

..  code-block:: none

	> words[0];
	"Apple"
	> words[2];
	"Cherry"
	> words[2] = "Coconut";
	> words;
	List<string>(3)
	┌──────┬───────────┬────────┐
	│ Name │ Value     │ Type   │
	├──────┼───────────┼────────┤
	│ [0]  │ "Apple"   │ string │
	│ [1]  │ "Banana"  │ string │
	│ [2]  │ "Coconut" │ string │
	└──────┴───────────┴────────┘
	
You can use ``foreach`` like with arrays or other sequences:

..  code-block:: none

	> foreach (string s in words) 
å  	{ 
      	Console.WriteLine(s.ToUpper()); 
  	}    
	APPLE
	BANANA
	COCONUT

.. index:: List; Console.WriteLine useless
	
Note:  Unfortunately C# is not user-friendly if 
you try to use ``Console.WriteLine`` to print a ``List`` *object*::

	> Console.WriteLine(words)
	System.Collections.Generic.List`1[System.Int32]

Next, compare ``Remove``, which finds the first matching element and removes it,
and ``RemoveAt``, which removes the element at a specified index.
``Remove`` returns whether the List has been changed::

	> words.Remove("Apple");  
	true
	> words.Remove("Apple")
	true
	> words.Remove("Apple");

	> words;
	┌───────────────────────────────────────────CompilationErrorException────────────────────────────────────────────┐
	│ (1,1): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be     │
	│ used as a statement                                                                                            │
	└────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

	> words 
	List<string>(2)
	┌──────┬───────────┬────────┐
	│ Name │ Value     │ Type   │
	├──────┼───────────┼────────┤
	│ [0]  │ "Banana"  │ string │
	│ [1]  │ "Coconut" │ string │
	└──────┴───────────┴────────┘

	> 
	> words.Add("Avocado");
	> words.Add("Durian");
	> words
	List<string>(4)
	┌──────┬───────────┬────────┐
	│ Name │ Value     │ Type   │
	├──────┼───────────┼────────┤
	│ [0]  │ "Banana"  │ string │
	│ [1]  │ "Coconut" │ string │
	│ [2]  │ "Avocado" │ string │
	│ [3]  │ "Durian"  │ string │
	└──────┴───────────┴────────┘
	> words.RemoveAt(3)
	> words
	List<string>(3)
	┌──────┬───────────┬────────┐
	│ Name │ Value     │ Type   │
	├──────┼───────────┼────────┤
	│ [0]  │ "Banana"  │ string │
	│ [1]  │ "Coconut" │ string │
	│ [2]  │ "Avocado" │ string │
	└──────┴───────────┴────────┘
	
Removing does not leave a "hole" in the ``List``:  The list closes up,
so the index decreases for the elements after the removed one::

	> words.Count;
	3
	
You can check for membership in a ``List`` with ``Contains``::

	> words.Contains("Apple")
	false
	> words.Contains("Banana")
	true
	> 

You can also remove all elements at once::

	> words.Clear()
	
	> words        
	List<string>(0)
	> 

.. index::
   single: List; constructor with sequence
   
Here is a List containing ``int`` elements.
Though more verbose than for an array, you can initialize a ``List``
with another collection, including an anonymous array,
specified with an explicit sequence in braces:

..  code-block:: none

	> List<int> nums = new List<int>(new[]{5, 3, 7, 4});
	> nums;
	{ 5, 3, 7, 4 }

We have been using the explicit declaration syntax, but generic types tend to get long,
so ``var`` is handy with them::

   var stuff = new List<string>();

When initializing a generic object, you still need to remember both the angle braces 
around the type *and* the parentheses for the parameter list after that.    

.. index:: side effect

An aside on the ``Remove`` method:  It both causes a side effect, 
changing the list,
*and* it returns a value.  If a function returns a value, 
we typically use the function call as an 
expression in a larger statement.  This is not necessary, as described in
:ref:`not-using-ret-val`.  In that section we discussed the *mistake* of not
using return values.  The ``Remove`` method illustrates that this is 
not always a mistake:  If you just want the side effect, trying to remove an element,
whether or not it is in the list, then there is no need to check for the return value.
This complete C# statement is fine::

  someList.Remove(element);

You should generally think carefully before *defining* a function 
that both has a side effect 
and a return value.  Most functions that return a value do not have a side effect.  
If you see a function used in the normal way as an expression, it is easy to forget that
it was *also* producing some side effect.
  
.. index:: example; ReadLines
   ReadLines example
   List; ReadLines example

Interactive List Example
-------------------------

Lists are handy when you do not know how much data there will be.  
A simple example would be reading in lines from the user interactively::

    /// Return a List of lines entered by the user in response
    /// to the prompt.  Lines in the List will be nonempty, since an
    /// empty line terminates the input. 
    List<string> ReadLines(string prompt) 
    {
       List<string> lines = new List<string>();
       Console.WriteLine(prompt);
       Console.WriteLine("An empty line terminates input.");
       string line = Console.ReadLine();
       while (line.Length > 0) {
          lines.Add(line);
          line = Console.ReadLine();
       }
       return lines;
    }
    
    