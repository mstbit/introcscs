.. index:: arithmetic

.. _arithmetic:
   
Arithmetic
==================

Arithmetic operations are usually included in learning a programming 
language because the constructs are similar to computation and therefore 
easier for the learners to associate. The C# Math class has many 
methods that allows you to perform arithmetic tasks on numbers.

We want to use csharprepl so that we can run some quick-and-dirty C# code, 
maybe for testing purposes. Open a terminal and enter the command 
``csharprepl``, You should see:

.. code-block:: none

    Welcome to the C# REPL (Read Eval Print Loop)!
    Type C# expressions and statements at the prompt and press Enter to evaluate them.
    Type help to learn more, exit to quit, and clear to clear your terminal.

    > 

The ``>`` prompt tells you that the C# interpreter has started
and is awaiting input. This allows you to test C# code interactively 
without having to create a project, modify it, save it, and run 
``dotnet run`` to test it. 

.. index::
   single: operator; + with numbers
   single: +; with numbers

Inside csharprepl, enter what comes after the prompt:

.. code-block:: none
 
    > 2 + 3
    5

The *repl* part in csharprepl means *read, evaluate, and print loop*: 
the acronym is *repl*. It evaluates expressions immediately and prints 
the result on a line without a prompt. C# can evaluate arbitrary C# 
expressions. It is very handy for testing as you get used to new syntax.

.. index::
   operator; -
   single: -; subtraction

Now let us do some arithmetic operations: 

.. code-block:: none
 
    > 10 - 3
    7


.. index::
   operator; *
   single: * multiplication

In Math class you could enter something like 4(10) for multiplication, but 
in C# you need to use the multiplication operator ``*``:

.. code-block:: none
 
    > 4(10);
      ┌─────────CompilationErrorException─────────┐   
      │ (1,1): error CS0149: Method name expected │   
      └───────────────────────────────────────────┘   
    > 4 * 10
    40

.. Unfortunately the error messages are not always easy to follow:  
.. it is hard to guess the
.. intention of the user making a mistake.


.. index::
   single:  ( ); grouping
   grouping ( )
   single: -; negation  


C# uses
the normal *precedence* of arithmetic operations: Multiplications
divisions, and negations are done before addition and subtraction, unless
there are parentheses forcing the order: 

.. code-block:: C#
    
    > 2 + 3 * 4 
    14
    > -(2+3)*4 
    -20 


.. index:: 
   single: remainder %
   single: % remainder
   single: operator; /, %
   division
   single: / ; division
   single: . ; double literal
   double
   int
   type; int
   type; double

.. _Division-and-Remainders:
   
Division and Remainders
--------------------------------

   
Division can be a little tricky in C#. For example:

.. code-block:: none

    > 5.0/2.0;
    2.5
    > 14.0/4.0;
    3.5

But C# will implicitly turn the following expression to an ``int`` type:

.. code-block:: none

    > 14/4
    3

 called ``int`` for short.

Adding a decimal point would inform C# that we are using ``double`` instead of ``int``:

.. code-block:: none
    > 14.0/4.0
    3.5
    > 0.5 * (2.0 + 4.5)
    3.25

Note that C# stores 
values with only a limited precision, so in fact results are
only approximate in general. For example:

.. code-block:: none

    > 1.0/3
    0.333333333333333

.. note::
   
   In C#, the result of the / operator depends on the
   *type* of the operands, not on the *mathematical value* of the operands.
 
Division with ``int`` data is handled completely differently.  

If you think about it, you learned several ways to do division.
Eventually you learned how to do division resulting in a decimal.
In the earliest grades, however, you would say

    "14 divided by 4 is 3 with a remainder of 2." 

Note the quotient is an integer 3, that matches the C# evaluation of 14/4,
so having a way to generate an integer quotient is not actually too strange.
The problem here is that the answer from grade school is in *two* parts, 
the integer quotient 3 and the remainder 2.  

C# has a *separate* operation symbol to generate the remainder part.  
There is no standard
single operator character operator for this in regular math, 
so C# grabs an unused symbol: 
``%`` is the remainder operator.  
(This is the same as in many other computer languages.)

Try in the csharp shell:

.. code-block:: none

    csharp> 14 / 4
    3
    csharp> 14 % 4
    2
    
You see that with the combination of the ``/`` operator and the ``%`` operator,
you get both the quotient and the remainder from our grade school division.

Now predict and then try each of these expression in csharp:

.. code-block:: none

    23/5 
    23%5
    20%5 
    6/8
    6%8
    6.0/8

Finding remainders will prove more useful than you might think in
the future!  Remember the strange ``%`` operator.

.. note::
   The precedence of ``%`` is the same as ``/`` and ``*``, and hence
   higher than addition and subtraction, ``+`` and ``-``. 

When you are *done with csharp*, you can enter the special expression

.. code-block:: none

    quit

There are some more details about numeric types in :ref:`value-types`.

.. index:: expression

We have been testing arithmetic expressions, with the word 
*expression* used pretty much like with normal math.  More generally in C#
an *expression* is any syntax that evaluates to a single value of some type.  
We will introduce many more types and operations that can be used in expressions. 

Divisible by 17 Exercise
~~~~~~~~~~~~~~~~~~~~~~~~~~

What is a simple expression that lets you see if an int x is divisible by 17?   

Mixed Arithmetic Exercise
~~~~~~~~~~~~~~~~~~~~~~~~~~

*Think* of the result of one of these at a time; write your prediction, 
and *then* test, and write the correct answer afterward if you were wrong.
Then go on to the next.... 
For the ones you got wrong, can you explain the result after seeing it? ::

    2 * 5 + 3
    2 + 5 * 3
    1.5 * 3
    7.0/2.0
    7.0/2
    7/2.0
    4.0 * 3 / 8
    4 * 3 / 8
    6 * (2.0/3)
    6 * (2/3)
    3 + 10 % 6
    10 % 6 + 3
