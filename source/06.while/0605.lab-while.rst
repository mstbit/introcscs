


.. index:: while; planning rubric
   loop; planning rubric
   rubric; planning a loop
   planning; loop rubric

Lab: ``while`` Loops
=======================

- **GAI**: Note that the course policy is that you should not use generative AI (GAI)
  without authorization. GAI are great tools and you should learn how to use it, but 
  they are tools and should be used to facilitate but not replace your learning. 
  If you are suspected to have used GAI to generate answers 
  to the assignment questions instead of using it as a learning tool, you may be 
  called up to explain/reproduce your work. If you fail to demonstrate your 
  competency, all your **related assignments throughout the semester will be 
  regraded as 0**. For example, if you fail to produce good code in ``while`` loops 
  in midterm exam, your *lab06 while loop homework and labs* will be re-evaluated.  

#. Create a dotnet console app project (see :ref:`create-project` if you need to), if you 
   have not, in your *USERNAME*/workspace/introcscs directory; called it 
   **Ch06WhileLoop**. 
#. Prepare your code in VS Code. 
#. Use the file Program.cs to code.    
#. The namespace of this project is *IntroCSCS*. 
#. The class name of this project is *Ch06WhileLoop*. 
#. When executing code, you will only use the Main() method in class *Ch06WhileLoop*. 
#. You will prepare methods in the same class to be called from the Main() method. 
#. Use a Word document to prepare your assignment. 
#. Number the questions and **annotate** your answers (using // in code when 
   appropriate) to show your understanding. 
#. For coding questions, screenshot and paste 1) your code in VS Code and 2) the 
   results of the code's execution (**command prompt** and **username** are part 
   of the execution).

Easy ``while``
-----------------

Write a program with a ``while`` loop to print:

..  code-block:: none

     10
     9
     8
     7
     6
     5
     4
     3
     2
     1
     Blastoff!



.. _lab-number-game:

Number Guessing Game 
-------------------------

This lab is inspired by a famous children's game
known as the number-guessing game. We suppose two people are playing.

The rules are:

- Person A chooses a positive integer less than N and keeps it in his or
  her head.
- Person B makes repeated guesses to determine the number. Person A
  must indicate whether the guess is higher or lower.
- Person A must tell the truth.

So as an example:

- George and Andy play the game.
- George chooses a positive number less than 100 (29) and puts it in his
  head.
- Andy guesses 50. George says "Lower". Andy now knows that 
  :math:`1 \leq number < 50`.
- Andy guesses 25. George says "Higher". Andy now knows that 
  :math:`26 \leq number < 50`.
- Andy guesses 30. George says "Lower". Andy now knows that the
  :math:`26 \leq number < 30`.
- Andy starts thinking that he is close to knowing the correct answer. He
  decides to guess 29. Andy guesses the correct number. So George
  says, "Good job! You win."


The computer code for the game is going to be acting like Player A and should 
behave as follows.

#. Make sure your program has ``namespace IntroCSCS;`` to match the UI class. 
#. Put the code for playing the number game in a method called ``Game``::

    static void Game()
        
#. You call ``Game()`` from the ``Main`` method.
#. Prompt the player for a guess. Use ``UI.PromptInt``. 
#. When the player guesses the right number, print "Good job!  You win!"

In ``Game``:  

#. When the player is incorrect, print "Lower!" or "Higher!" as appropriate.
#. For now set an ``int`` variable ``big`` to 100. 
#. Have the Game function print "In this game you guess a positive number 
   less than 100." It is best if you have the printing statement
   reference the variable ``big``, rather than the literal ``100``.

.. index:: random number generator

#. Have the game generate a *random* number. For your convenience, 
   use the C# code below to generate the random number. Assuming we want a 
   secret number so :math:`1 \leq secret < big`, we can use the code::

      Random r = new Random();
      int secret = r.Next(1, big);

   .. note:: 
      In case you are wondering, we are creating a *new object* 
      of the *class* ``Random`` which serves as the
      random number generator. We'll cover this in more detail when we
      get to the :ref:`classes` chapter. 
   
#. Here is some illustration using a ``Random`` object in ``csharprepl``. 
   Your answers will not be the same::

      > Random r = new Random();

      > r.Next(1, 100)
      68
      > r.Next(1, 100)
      48
      > r.Next(1, 100)
      30
      > r.Next(1, 100)
      70
      > r.Next(1, 100)
      67
      > 

#. Note that, the minimum possible value of the number returned by ``r.Next``
   is the first parameter, and the value returned is always *less* than
   the second parameter, *never equal*.  
#. As an extra challenge, when the player finally wins, print the number of guesses
   the player made. 
#. When run, the program should work like (where ``secret`` ended up as 68):
   
    | Guess a number less than 100!
    | Guess the number: **60**
    | Higher!
    | Guess the number: **72**
    | Lower!
    | Guess the number: **66**
    | Higher!
    | Guess the number: **68**
    | Good job!  You win on guess 3!
   
   
.. _SumToN:

Sum To ``n``
------------

Let us write a function to sum the numbers from 1 to ``n``::

    /// Return the sum of the numbers from 1 through n. 
    static int SumToN(int n) 
    {
       ...
    }

For instance SumToN(5) calculates 1 + 2 + 3 + 4 + 5 and returns 15.
We know how to generate a sequence of integers, but this is a place
that a programmer gets tripped up by the speed of the human mind.  
You are likely
so quick at this that you just see it all at once, with the answer.

.. index:: concrete example

In fact, you and the computer need to do this in steps.  To help see, let
us take a concrete example like the one above for SumToN(5), and write out a 
detailed sequence of steps like:

..  code-block:: none

    3 = 1 + 2
    6 = 3 + 3 
    10 = 6 + 4
    15 = 10 + 5
    
You could put this in code directly for a specific sum, but if ``n`` is general,
we need a loop, and hence we must see a *pattern* in code that we can repeat.

In each calculation the second term in the additions is a successive integer, 
that we can generate.  Starting in the second line, the first number
in each addition
is the sum from the previous line.  Of course the next integer and the next
partial sum change from step to step, so in order to use the same code over and
over we will need changeable variables, with names.  We can make the partial
sum be ``sum`` and we can call the next integer ``i``.  Each addition can be
in the form::

    sum + i

We need to remember that result, the new sum.  You might first think to introduce
such a name::

    newSum = sum + i;
    
This will work.  We can go through the ``while`` loop rubric:
    
The variables are ``sum``, ``newSum`` and ``i``.
    
To evaluate  ::

    newSum = sum + i;

the first time in the loop, we need *initial* values for sum and i.
Our concrete example leads the way::

   int sum = 1, i = 2;
   
We need a ``while`` loop heading with a continuation condition.  How
long do we want to add the next ``i``?  That is for all the value up to and
including n::

   while (i <= n) {

There is one more important piece - making sure the same code 

    newSum = sum + i;
    
works for the *next* time through the loop.  We have dealt before with
the idea of the next number in sequence::

   i = i + 1;
   
What about ``sum``?  What was the ``newSum`` 
on *one* time through the loop becomes the old or
just plain ``sum`` the *next* time through, so we can make an assignment::

   sum = newSum:
   
All together we calculate the sum with::

   int sum = 1, i = 2;
   while (i <= n) {
      int newSum = sum + i;
      sum = newSum:
      i = i + 1;
   }
   
This exactly follows our general rubric, with preparation for the next time
through the loop at the end of the loop.  
We can condense it in this case: Since ``newSum`` is only used
once, we can do away with this extra variable name, 
and directly change the value of sum::

   int sum = 1, i = 2;
   while (i <= n) {
      sum = sum + i;
      i = i + 1;
   }

Finally this was supposed to fit in a function.  The ultimate purpose
was to *return* the sum, which is the final value of the
variable ``sum``, so the whole function is::

  /// Return the sum of the numbers from 1 through n. 
  static int SumToN(int n)     // line 1
  {
     int sum = 1, i = 2;       // 2
     while (i <= n) {          // 3
        sum = sum + i;         // 4
        i = i + 1;             // 5
     }
     return sum;               // 6
  }

.. index:: testing; edge case
   range testing
   edge case
   
The comment before the function definition does not give a clear idea of the 
range of possible values for ``n``.  How small makes sense for the comment?
What actually works in the function?  The smallest expression 
starting with 1 would just be 1: (``n`` is 1).  Does that work in the function?
You were probably not thinking of that when developing the function!
Now look back now at this *edge case*.  You can play computer on the code
or directly test it.  In this case the initialization of ``sum`` is 1,
and the body of the loop *never* runs (2 <= 1 is false).  The function
execution jumps right to the return statement, and
does return 1, and everything is fine.

Also you should check the program in a more general situation, say with ``n`` 
being 4.  You should be able to play computer and generate this table,
using the line numbers shown in comments at the end of lines, 
and following one statement of execution at a time.  We only
make entries where variables change value.
      
====  ==  ====  ======================== 
Line   i   sum  Comment   
====  ==  ====  ======================== 
1               assume 4 is passed for n        
2      2     1  
3               2<=4: true, enter loop
4            3  1+2=3
5      3        2+1=3, bottom of loop
3               3<=4: true
4            6  3+3=6
5      4        3+1=4, bottom of loop
3               4<=4: true
4           10  6+4=10
5      5        4+1=5, bottom of loop
3               5<=4: false, skip loop
6               return 10
====  ==  ====  ======================== 

The return only happens once, so it is not in the loop.  You get *a* value 
for a sum each time through, but not the final one.  A common beginner
error is to put the return statement inside the loop, like ::

  static int SumToN(int n)  // 1   BAD VERSION!!!
  {                            
     int sum = 1, i = 2;    // 2
     while (i <= n) {       // 3
        sum = sum + i;      // 4
        i = i + 1;          // 5
        return sum;         // 6  WRONG!
     }
  }

Recall that *when a return statement is reached, function execution ends*,
*no matter what comes next in the code*.
(This is a way to break out of a ``while`` loop that we will find useful 
later.)  In this case however, it is not what we want at all.  The first sum
is calculated in line 4, so ``sum`` becomes 2 + 1, but when you get to line
6, the function terminates and never loops back, returning 3.
   
Now about large n....

.. index::
   big oh; order of n
   order of n
   
With loops we can make programs run for a long time.
The time taken becomes an issue.  In this case we go though the loop
n-1 times, so the total time is approximately proportional to n.
We write that the time is O(n), spoken "oh of n", or "big oh of n" or
"order of n".

.. index:: pitfall; limit on number size
   overflow
   
Computers are pretty fast, so you can try the testing program 
:repsrc:`sum_to_n_test/sum_to_n_test.cs`
and it will go by so fast, that you will hardly notice.  Try these specific
numbers in tests: 5, 6, 1000, 10000, 98765.  All look OK?  Now try 66000.
On many systems you will get quite a surprise!  
This is the first place we have to deal with the limited 
size of the ``int`` type.
On many systems the limit is a bit over 2 billion.  
You can check out the size of ``int.MaxValue`` in csharp.
The answer for 66000,
and *also* 98765, is bigger than the upper limit.  
Luckily the obviously wrong negative answer
for 66000 pops out at you.  Did you guess before you saw the answer for
66000, that there was an issue for 
98765?  It is a good thing that no safety component in a big bridge was being 
calculated!  It is a big deal that the system fails *silently* 
in such situations.  *Think* how large the data may be that you deal with!

Now look at and run :repsrc:`sum_to_n_long/sum_to_n_long.cs`.  The sum is
a ``long`` integer here. Check out in csharp how big
a ``long`` can be (``long.MaxValue``).  This version of the program
works for 100000 and for 98765.  We can get correct
answers for things that will take perceptible time.  Try working up to 
1 billion (1000000000, nine 0's).  It takes a while: O(n) can be slow!

.. index::sum through n example
   example; sum through n
   
By hand it is a lot slower, unless you totally change the algorithm:
There is a classic story about how a calculation like this
was done in grade school (n=100) by the famous
mathematician Gauss. His teacher was trying to keep him busy.
Gauss discovered the general, exact, mathematical formula:  
    
    1 + 2 + 3 + ... + n = n(n+1)/2.  
    
That is the number of terms (n), times the average term (n+1)/2.

.. index:: big oh; constant order
   constant order
   
Our loop was instructive, but not the fastest approach.  The simple exact
formula takes about the same time for any n.  
(That is as long as the result fits in
a standard type of computer integer!)  
This is basically constant time.  In discussing
how the speed relates to the size of n, we say it is O(1). 
The point is here that 1 is a constant.  The time is of *constant order*.

.. index:: 
   double: pitfall; division
   
We can write a ridiculously short
function following Gauss's model.  Here we introduce the variable average,
as in the motivation for Gauss's answer:

.. literalinclude:: ../../examples/introcs/sum_to_n_long_bad/sum_to_n_long_bad.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6

Run the example program containing it: :repsrc:`sum_to_n_long_bad/sum_to_n_long_bad.cs`.

Test it with 5, and then try 6. ???

"Ridiculously short" does not imply correct!  The problem goes back
to the fact that Gauss was in *math class* and you are doing 
Computer Science.  Think of a subtle difference that might come in here:
Though (n+1)/2 is fine as math, recall the division operator does not
always give correct answers in C#.  You get an integer answer from the
integer (or long) operands.  Of course the exact mathematical final answer
is an integer when *adding* integers, but splitting it according to
Gauss's motivation can put a mathematical non-integer in the middle.

The C# fix: The final answer is clearly an integer, so if we do the division
last, when we know the answer will be an integer (assuming a ``long`` integer), 
things should be better::

   long sum = n*(n+1)/2;
   return sum;

.. index:: cast
   
Here is a shot at the whole function:

.. literalinclude:: ../../examples/introcs/sum_to_n_long_bad2/sum_to_n_long_bad2.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6

Run the example program containing it: :repsrc:`sum_to_n_long_bad2/sum_to_n_long_bad2.cs`.

Test it with 5, and then try 6. Ok so far, but go on to long integer range:
try 66000 that messed us up before.  ??? You get an answer that is not
a multiple of 1000: not what we got before!  What other issues do we have
between math and C#?

Further analysis:  To make sure the function always worked, it made sense
to leave the parameter ``n`` an ``int``.  The function would not work
with ``n`` as the largest ``long``.  The result can still be big enough
to only fit in a ``long``, so the return value is a ``long``.  All
this is reasonable but the C# result is still wrong!  Look deeper.
While the result of ``n*(n+1)/2`` is *assigned* to a ``long`` variable,
the *calculation* ``n*(n+1)/2`` is done with ``int``\ s not mathematical
integers.  By the same general type rule that led to the (n+1)/2 error 
earlier, these operations on ``int``\ s produce an ``int`` result, even
when wrong.

We need to force the *calculation* to produce a ``long``. 
In the correct looping version ``sum`` was a ``long``, and that
forced all the later arithmetic to be with longs.  Here are two variations
that work::
    
    long nLong = n;
    return nLong*(nLong+1)/2;
    
or we can avoid a new variable name by :ref:`cast` to ``long``, converting
the first (left) operand to ``long``, so all the later left-to-right
operations are forced to be ``long``::

    return (long)n*(n+1)/2;
    
You can try example :repsrc:`sum_to_n_long_quick/sum_to_n_long_quick.cs` 
to finally get a result that is dependably fast and correct.

Important lessons from this humble summation problem:

- *Working* and being *efficient* are two different things in general.  

- *Math* operations and C# operations are not always the same. 
  Knowing this in theory is not the same as remembering it in practice!

Further special syntax that only makes sense in any kind of loop is discussed in 
:ref:`break-continue`, after we introduce the last kind of loop.


We have already processed strings a character at a time, with ``while`` loops.
We took advantage of the fact that strings could be indexed.  Our ``while``
loops directly controlled the sequence of indices. Then we could
look up the character at each index of a given string ``s``::

	int i = 0;
	while (i < s.Length) {
	   code using the value of s[i]...
	   i++;
	}

Examples have been in :ref:`While-Sequence`, like

.. literalinclude:: ../../examples/introcs/char_loop1/char_loop1.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6
 
In this example we really only care about the characters, not the indices.
Managing the indices is just a way to get at the 
underlying sequence of characters.


Variables declared in a ``for``    The variable ``i`` declared before
the ``while`` statement above is still defined after the ``while`` loop.


The C# for loop statement syntax is:

| ``for (`` *initialization* ``;`` *condition* ; *update* ``)`` {
|    statement(s)
| ``}``
   
translates to

| *initialization* ``;`` 
| ``while (`` *condition* ``)`` {
|    statement(s)
|    *update* ``;``
| ``}``


A ``for`` loop is an example of *syntactic sugar*: syntax that can 
simplify things for the programmer, but can be immediately translated 
into an equivalent syntax by the compiler. For example::

    for (i = 2; i <= n; i++) {
       sum = sum + i;
    }
   
is exactly equivalent to this code similar to part of 
:ref:`SumToN <SumToN>`::

    i= 2;
    while (i <= n) {
       sum = sum + i;
       i++;
    }




.. index:: exercise; loan table
   decimal; loan table exercise

.. _loan_table_exercise:

Loan Table Exercise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Loans are common with a specified interest rate and with a fixed periodic 
payment.  Interest is charged at a fixed rate on the amount left in the loan 
after the last periodic payment (or start of the loan for the first payment).

For example, if an initial $100 loan is made with 10% interest per pay
period, and a regular $20 payment each pay period:
At the time of the first payment interest of $100*.10 = $10 is accrued,
so the total owed is $110.  Right after the payment of $20, 
$110 - $20 = $90 remains.  That $90 gains interest of $90*.10 = $9 up to the
next payment, when $90 + $9 = $99 is owed.  After the regular payment of
$20, $99 - $20 = $79 is left, and so on.  When a payment of at most $20 brings
the amount owed to 0, the loan is done.
 
We can make a table showing 

* Payment number (starting from 1)
* The principal amount after the previous payment (or the beginning of the loan
  for the first payment) 
* The interest on that principal up until the next periodic payment
* The payment made as a result.  

Continuing the example above, the whole table
would look like:

.. code-block:: none

    Number Principal   Interest    Payment
         1    100.00      10.00      20.00
         2     90.00       9.00      20.00
         3     79.00       7.90      20.00
         4     66.90       6.69      20.00
         5     53.59       5.36      20.00
         6     38.95       3.90      20.00
         7     22.85       2.29      20.00
         8      5.14       0.51       5.65

In the final line, the principal plus interest equal the payment, finishing
off the loan.
     
Similarly, with a $1000.00 starting loan, 5% interest per pay period, and
$196 payments due, we would get

.. code-block:: none
      
    Number Principal   Interest    Payment
         1   1000.00      50.00     196.00
         2    854.00      42.70     196.00
         3    700.70      35.04     196.00
         4    539.74      26.99     196.00
         5    370.73      18.54     196.00
         6    193.27       9.66     196.00
         7      6.93       0.35       7.28

If a $46 payment were specified, the principal would not decrease from the
initial amount, and the loan would never be paid off.

There are a couple of wrinkles here:  ``double`` values do not hold decimal
values exactly.  The ``decimal`` type does hold decimal numbers exactly 
(and in an enormous range, see :ref:`numeric-type-limits`) and
hence are beter for monetary calculations.  Decimal literals end with m, like
``34.56m`` for *exactly* 34.56.    

Though decimals are exact, money only has two decimal places.  We make the 
assumption that interest will always be calculated as current 
principal*rate, rounded
to two decimal places:  ``Math.Round(principal*rate, 2)``.

Write :file:`loan_calc.cs``, completing ``LoanTable`` and write a 
``Main`` testing program::

    /// Print a loan table, showing payment number, principal at the 
    /// beginning of the payment period, interest over the period, and
    /// payment at the end of the period.
    /// The principal is the initial amount of the loan.
    /// The rate is fraction representing the rate of interest per PAYMENT.
    /// The periodic regular payment is also specified.
    /// If the payment is insufficient, merely print "payment too low".    
    public static void LoanTable(decimal principal, decimal rate, 
                                 decimal payment)

Note that the ``rate``, too, is a ``decimal``, 
even though it does not represent money.
That is important, because arithmetic with a ``decimal`` and a ``double`` is
forbidden:  A ``double`` would have to be explicitly cast to a ``decimal``.
Insisting on ``decimal`` parameter simplifies the function code.

This exercise is much more sophisticated than the :ref:`savings_exercise`,
so it is placed in this section, much later in the chapter.  Use what
ever form of loop makes the most sense to you.
