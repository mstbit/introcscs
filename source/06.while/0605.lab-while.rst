.. index::
   single: labs; string manipulations


.. index:: while; planning rubric
   loop; planning rubric
   rubric; planning a loop
   planning; loop rubric

.. _loop-rubric:

.. rubric:: Loop Planning Rubric
   
Looking ahead to more complicated and interesting problems,
here is a more complete list of questions to ask yourself when
designing a function with a ``while`` loop (and most will apply to 
later forms of loops, too):

-  What data is involved? Make sure you give good variable names.
-  What needs to be initialized and how? This certainly includes any
   variable tested in the condition.
-  What is the condition that will allow the loop to *continue*?  It
   may be easier to think of the condition that will *stop* the loop.
   That is fine - but remember to *negate* it (with ``!``) to turn it
   into a proper *continuation* condition.
-  Distinguish: What is the code that should only be executed once? 
   What action do I want to repeat? 
-  How do I write the repeating action so I can modify it for the next time
   through the loop to work with new data?
-  What code is needed to do modifications to make the same action code work
   the next time through the loop?
-  Have I thought of variables needed in the middle and declared them;
   do other things need initialization?
-  Will the continuation condition eventually fail?  
   *Be sure to think about this!*
-  Separate the actions to be done once before the repetition (code before the
   loop) from repetitive actions (in the loop) from actions not repeated, but
   done after the loop (code after the loop). Missing this distinction
   is a *common error*!

This is quite a sequence of steps!  Particularly looking forward to other forms of loops,
we can note a more basic split into two parts:

* Writing the code to make sure each desired iteration is reached 
  (loop dynamics: initialized data for the test condition, the test condition itself, 
  preparing for the next iteration)
* Doing the work for a specific item/ireration (most of the body of the loop)

You generally only need to concentrate on one of those at a time.  
If you set up how to reach all of the repetitions, giving names for the variables
to be acted on, then you can separately just concentrate on dealing with the the action/code
to deal with the *current* situation.


**Problem**:  Write a program with a ``while`` loop to print:

..  code-block:: none

     10
     9
     8
     7
     6
     5
     4
     3
     2
     1
     Blastoff!



.. _lab-number-game:

Number Guessing Game Lab
-------------------------

**Objectives**:  

- Work with functions
- Work with interactive while loops
- Use decisions
- Introduce random values

This lab is inspired by a famous children's game
known as the number-guessing game. We suppose two people are playing.

The rules are:

- Person A chooses a positive integer less than N and keeps it in his or
  her head.

- Person B makes repeated guesses to determine the number. Person A
  must indicate whether the guess is higher or lower.

- Person A must tell the truth.

So as an example:

- George and Andy play the game.

- George chooses a positive number less than 100 (29) and puts it in his
  head.

- Andy guesses 50. George says "Lower". Andy now knows that 
  :math:`1 \leq number < 50`.

- Andy guesses 25. George says "Higher". Andy now knows that 
  :math:`26 \leq number < 50`.

- Andy guesses 30. George says "Lower". Andy now knows that the
  :math:`26 \leq number < 30`.

- Andy starts thinking that he is close to knowing the correct answer. He
  decides to guess 29. Andy guesses the correct number. So George
  says, "Good job! You win."

We are going to elaborate this game in small steps.  You might save
the intermediate versions under new names.

The computer code for the
game is going to be acting like Player A.

Part 1: No Hints; Fixed Secret Number
-------------------------------------------

You will want to use the UI class, so either copy ui.cs into your project, or
(for Xamarin Studio) create a new project in a solution 
in which you already have added the ui library project, and add the ui project 
as a *reference* for the lab project.  
Make sure your program has ``namespace IntroCS;`` to match the UI class.

You are going to play a game, and later may repeat it, so put the code
for playing the number game in a function called ``Game``::

    static void Game()
        
For now your write a ``Main`` function to just call ``Game()``.

In ``Game``:

#. For the simplest versions, which help testing, have the
   program assign a specific
   secret number (like 29), and call it ``secret``.  
   Admittedly, this is not much fun for the player the second time!

#. Prompt the player for a guess.  
   Use ``UI.PromptInt``.
   Every time the player guesses wrong,
   print "Wrong!".  A later version will give clues.  Keep
   prompting for another number until the player guesses correctly.
   (Since you, the programmer, knows the secret number, this need not go
   on forever.)  
   
#.  When the player guesses the right number, print "Correct!  You win!"

Sample play could look like:

    | Guess the number: **55**
    | Wrong!
    | Guess the number: **12**
    | Wrong!
    | Guess the number:  **29**
    | Good job!  You win!
    
You could also make the game stop immediately, 
(since you know the secret number):

    | Guess the number:  **29**
    | Good job!  You win!

Part 2: Add Hints
-------------------------------------------

In ``Game``:  
Instead of just printing "Wrong!" when the player is incorrect,
print "Lower!" or "Higher!"  as appropriate.  For example:

    | Guess the number: **55**
    | Lower!
    | Guess the number: **12**
    | Higher!
    | Guess the number: **25**
    | Higher!
    | Guess the number:  **29**
    | Good job!  You win!

Part 3:  Add a Random Secret Number
-------------------------------------

In ``Game``, make the following alterations and additions:

#. For now set an ``int`` variable ``big`` to 100.  We will make sure 
   the secret number is less than ``big``.

#. Have the Game function print 
   "In this game you guess a positive number less than 100."
   For future use it is best if you have the printing statement
   reference the variable ``big``, rather than the literal ``100``.

.. index:: random number generator

#. Thus far the secret number was fixed in the program.  Now we are
   going to let it vary, by having the game generate a *random* number.
   For your convenience, we are going to give you the C#
   code to compute the random number.  Assuming we want a secret number
   so :math:`1 \leq secret < big`, we can use the code::

      Random r = new Random();
      int secret = r.Next(1, big);

   In case you are wondering, we are creating a *new object* 
   of the *class* ``Random`` which serves as the
   random number generator. We'll cover this in more detail when we
   get to the :ref:`classes` chapter. Here is some illustration using a ``Random``
   object in csharp.  Your answers will not be the same!  ::

      csharp> Random r = new Random();
      csharp> r.Next(1, 100);   
      55
      csharp> r.Next(1, 100); 
      31
      csharp> r.Next(1, 100); 
      79
      csharp> r.Next(2, 5); 
      2
      csharp> r.Next(2, 5); 
      4
      csharp> r.Next(2, 5); 
      3
      csharp> r.Next(2, 5); 
      3

   In general the minimum possible value of the number returned by ``r.Next``
   is the first parameter, and the value returned is always *less* than
   the second parameter, *never equal*.  
   
   You can see that ``r.Next()`` is smart enough to give what appears to
   be a randomly chosen number every time. 

   Example (where ``secret`` ended up as 68):
   
    | Guess a number less than 100!
    | Guess the number: **60**
    | Higher!
    | Guess the number: **72**
    | Lower!
    | Guess the number: **66**
    | Higher!
    | Guess the number: **68**
    | Good job!  You win!
   
   For debugging purposes, you might want to have ``secret`` 
   be printed out right away. 
   (Eliminate that part when everything works!)

Part 4:  Let the Player Set the Range of Values
------------------------------------------------

In ``Game``: 
Instead of declaring ``big`` and  automatically initializing it to 100,
make ``big`` be a parameter, so the heading looks like::
    
        static void Game(int big)

In ``Main``:  

#.  Prompt the player for the limit on the secret number.
    An exchange might look like:
    
        Enter a secret number bound: **10**

#.  Pass the value given by the player to the ``Game`` function 
    (so it will be ``big`` inside ``Game``).  

Hence the program might start with:

    | Enter a secret number bound: **10**
    | In this game you guess a number less than 10!
    | Guess the number: **5**
    | Higher!
    | Guess the number: **7**
    | Lower!
    | Guess the number: **6**
    | Good job!  You win!

Part 5:  Count the Guesses
------------------------------------------------

In ``Game``: When the player finally wins, print the number of guesses
the player made.  For example, for the game sequence shown above,
the last line would become:

    Good job!  You win on guess 3!
   
You need to keep a count, adding 1 with each guess.


Possible Extra Credit Improvements or Variations
--------------------------------------------------------

Should you finish everything early, try the following:

#. **(20% extra credit)**  In ``Main``:

   Use an outer ``while`` loop to allow the game to be played
   repeatedly. Change the prompt for the bound in ``Main`` to:
   
       Enter a secret number bound (or 0 to quit):
       
   Continue to play games until the player enters 0 for the bound.
   
#. **(40% extra credit)**
   In ``Main`` prompt users to see if they want to guess numbers or reverse roles and
   choose
   the secret number.  In the first case, just call the existing Game function.
   In the second case you need a new function, 
   where the user is the one who knows the secret
   number and the computer guesses numbers until the answer
   is obtained. Write and use a new function  ::
   
      static void GameReversed(int big)
      
   Pass it the parameter ``big``, still set in ``Main``.
   The new ``GameReversed`` will tell the user to put a number in
   his/her head, and press return to continue. 
   (You can throw away the string entered - this is just to cause a pause.)
   Then the computer guesses.
   For simplicity let the human enter "L" for lower, "H" for higher, and
   "E" for equal (when the computer wins).
   As you saw in the initial example with George and Andy,
   each hint reduces the range of the possible secret numbers.
   Have the computer guess a *random* number in the *exact* range that 
   remains possible.

   To do this you must note the asymmetry of the parameters for the method
   ``Next``:  suppose ``n = r.Next(low, higher)``, then 
   
       :math:`low \leq number < higher`
    
   The first parameter *may* be returned, but second 
   parameter is *never* returned.
   
   You will need two variables ``low`` and ``higher`` that keep
   bracketing the allowed range.  The simplest thing is to set them so they
   will be the parameters for the following call to ``Next``. 

   That would mean initially ``low``
   is 1 and ``higher`` is equal to ``big``.  
   With each hint you adjust one or the other of ``low`` and ``higher`` so they
   get closer together.
   The game ends after the human enters "E".
   
   Have the computer complain that the human is cheating (and stop the game) 
   if the computer
   guesses the only possible value, and the human does *not* respond with "E".
   
   
   
.. _SumToN:

Sum To ``n``
------------

Let us write a function to sum the numbers from 1 to ``n``::

    /// Return the sum of the numbers from 1 through n. 
    static int SumToN(int n) 
    {
       ...
    }

For instance SumToN(5) calculates 1 + 2 + 3 + 4 + 5 and returns 15.
We know how to generate a sequence of integers, but this is a place
that a programmer gets tripped up by the speed of the human mind.  
You are likely
so quick at this that you just see it all at once, with the answer.

.. index:: concrete example

In fact, you and the computer need to do this in steps.  To help see, let
us take a concrete example like the one above for SumToN(5), and write out a 
detailed sequence of steps like:

..  code-block:: none

    3 = 1 + 2
    6 = 3 + 3 
    10 = 6 + 4
    15 = 10 + 5
    
You could put this in code directly for a specific sum, but if ``n`` is general,
we need a loop, and hence we must see a *pattern* in code that we can repeat.

In each calculation the second term in the additions is a successive integer, 
that we can generate.  Starting in the second line, the first number
in each addition
is the sum from the previous line.  Of course the next integer and the next
partial sum change from step to step, so in order to use the same code over and
over we will need changeable variables, with names.  We can make the partial
sum be ``sum`` and we can call the next integer ``i``.  Each addition can be
in the form::

    sum + i

We need to remember that result, the new sum.  You might first think to introduce
such a name::

    newSum = sum + i;
    
This will work.  We can go through the ``while`` loop rubric:
    
The variables are ``sum``, ``newSum`` and ``i``.
    
To evaluate  ::

    newSum = sum + i;

the first time in the loop, we need *initial* values for sum and i.
Our concrete example leads the way::

   int sum = 1, i = 2;
   
We need a ``while`` loop heading with a continuation condition.  How
long do we want to add the next ``i``?  That is for all the value up to and
including n::

   while (i <= n) {

There is one more important piece - making sure the same code 

    newSum = sum + i;
    
works for the *next* time through the loop.  We have dealt before with
the idea of the next number in sequence::

   i = i + 1;
   
What about ``sum``?  What was the ``newSum`` 
on *one* time through the loop becomes the old or
just plain ``sum`` the *next* time through, so we can make an assignment::

   sum = newSum:
   
All together we calculate the sum with::

   int sum = 1, i = 2;
   while (i <= n) {
      int newSum = sum + i;
      sum = newSum:
      i = i + 1;
   }
   
This exactly follows our general rubric, with preparation for the next time
through the loop at the end of the loop.  
We can condense it in this case: Since ``newSum`` is only used
once, we can do away with this extra variable name, 
and directly change the value of sum::

   int sum = 1, i = 2;
   while (i <= n) {
      sum = sum + i;
      i = i + 1;
   }

Finally this was supposed to fit in a function.  The ultimate purpose
was to *return* the sum, which is the final value of the
variable ``sum``, so the whole function is::

  /// Return the sum of the numbers from 1 through n. 
  static int SumToN(int n)     // line 1
  {
     int sum = 1, i = 2;       // 2
     while (i <= n) {          // 3
        sum = sum + i;         // 4
        i = i + 1;             // 5
     }
     return sum;               // 6
  }

.. index:: testing; edge case
   range testing
   edge case
   
The comment before the function definition does not give a clear idea of the 
range of possible values for ``n``.  How small makes sense for the comment?
What actually works in the function?  The smallest expression 
starting with 1 would just be 1: (``n`` is 1).  Does that work in the function?
You were probably not thinking of that when developing the function!
Now look back now at this *edge case*.  You can play computer on the code
or directly test it.  In this case the initialization of ``sum`` is 1,
and the body of the loop *never* runs (2 <= 1 is false).  The function
execution jumps right to the return statement, and
does return 1, and everything is fine.

Also you should check the program in a more general situation, say with ``n`` 
being 4.  You should be able to play computer and generate this table,
using the line numbers shown in comments at the end of lines, 
and following one statement of execution at a time.  We only
make entries where variables change value.
      
====  ==  ====  ======================== 
Line   i   sum  Comment   
====  ==  ====  ======================== 
1               assume 4 is passed for n        
2      2     1  
3               2<=4: true, enter loop
4            3  1+2=3
5      3        2+1=3, bottom of loop
3               3<=4: true
4            6  3+3=6
5      4        3+1=4, bottom of loop
3               4<=4: true
4           10  6+4=10
5      5        4+1=5, bottom of loop
3               5<=4: false, skip loop
6               return 10
====  ==  ====  ======================== 

The return only happens once, so it is not in the loop.  You get *a* value 
for a sum each time through, but not the final one.  A common beginner
error is to put the return statement inside the loop, like ::

  static int SumToN(int n)  // 1   BAD VERSION!!!
  {                            
     int sum = 1, i = 2;    // 2
     while (i <= n) {       // 3
        sum = sum + i;      // 4
        i = i + 1;          // 5
        return sum;         // 6  WRONG!
     }
  }

Recall that *when a return statement is reached, function execution ends*,
*no matter what comes next in the code*.
(This is a way to break out of a ``while`` loop that we will find useful 
later.)  In this case however, it is not what we want at all.  The first sum
is calculated in line 4, so ``sum`` becomes 2 + 1, but when you get to line
6, the function terminates and never loops back, returning 3.
   
Now about large n....

.. index::
   big oh; order of n
   order of n
   
With loops we can make programs run for a long time.
The time taken becomes an issue.  In this case we go though the loop
n-1 times, so the total time is approximately proportional to n.
We write that the time is O(n), spoken "oh of n", or "big oh of n" or
"order of n".

.. index:: pitfall; limit on number size
   overflow
   
Computers are pretty fast, so you can try the testing program 
:repsrc:`sum_to_n_test/sum_to_n_test.cs`
and it will go by so fast, that you will hardly notice.  Try these specific
numbers in tests: 5, 6, 1000, 10000, 98765.  All look OK?  Now try 66000.
On many systems you will get quite a surprise!  
This is the first place we have to deal with the limited 
size of the ``int`` type.
On many systems the limit is a bit over 2 billion.  
You can check out the size of ``int.MaxValue`` in csharp.
The answer for 66000,
and *also* 98765, is bigger than the upper limit.  
Luckily the obviously wrong negative answer
for 66000 pops out at you.  Did you guess before you saw the answer for
66000, that there was an issue for 
98765?  It is a good thing that no safety component in a big bridge was being 
calculated!  It is a big deal that the system fails *silently* 
in such situations.  *Think* how large the data may be that you deal with!

Now look at and run :repsrc:`sum_to_n_long/sum_to_n_long.cs`.  The sum is
a ``long`` integer here. Check out in csharp how big
a ``long`` can be (``long.MaxValue``).  This version of the program
works for 100000 and for 98765.  We can get correct
answers for things that will take perceptible time.  Try working up to 
1 billion (1000000000, nine 0's).  It takes a while: O(n) can be slow!

.. index::sum through n example
   example; sum through n
   
By hand it is a lot slower, unless you totally change the algorithm:
There is a classic story about how a calculation like this
was done in grade school (n=100) by the famous
mathematician Gauss. His teacher was trying to keep him busy.
Gauss discovered the general, exact, mathematical formula:  
    
    1 + 2 + 3 + ... + n = n(n+1)/2.  
    
That is the number of terms (n), times the average term (n+1)/2.

.. index:: big oh; constant order
   constant order
   
Our loop was instructive, but not the fastest approach.  The simple exact
formula takes about the same time for any n.  
(That is as long as the result fits in
a standard type of computer integer!)  
This is basically constant time.  In discussing
how the speed relates to the size of n, we say it is O(1). 
The point is here that 1 is a constant.  The time is of *constant order*.

.. index:: 
   double: pitfall; division
   
We can write a ridiculously short
function following Gauss's model.  Here we introduce the variable average,
as in the motivation for Gauss's answer:

.. literalinclude:: ../../examples/introcs/sum_to_n_long_bad/sum_to_n_long_bad.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6

Run the example program containing it: :repsrc:`sum_to_n_long_bad/sum_to_n_long_bad.cs`.

Test it with 5, and then try 6. ???

"Ridiculously short" does not imply correct!  The problem goes back
to the fact that Gauss was in *math class* and you are doing 
Computer Science.  Think of a subtle difference that might come in here:
Though (n+1)/2 is fine as math, recall the division operator does not
always give correct answers in C#.  You get an integer answer from the
integer (or long) operands.  Of course the exact mathematical final answer
is an integer when *adding* integers, but splitting it according to
Gauss's motivation can put a mathematical non-integer in the middle.

The C# fix: The final answer is clearly an integer, so if we do the division
last, when we know the answer will be an integer (assuming a ``long`` integer), 
things should be better::

   long sum = n*(n+1)/2;
   return sum;

.. index:: cast
   
Here is a shot at the whole function:

.. literalinclude:: ../../examples/introcs/sum_to_n_long_bad2/sum_to_n_long_bad2.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6

Run the example program containing it: :repsrc:`sum_to_n_long_bad2/sum_to_n_long_bad2.cs`.

Test it with 5, and then try 6. Ok so far, but go on to long integer range:
try 66000 that messed us up before.  ??? You get an answer that is not
a multiple of 1000: not what we got before!  What other issues do we have
between math and C#?

Further analysis:  To make sure the function always worked, it made sense
to leave the parameter ``n`` an ``int``.  The function would not work
with ``n`` as the largest ``long``.  The result can still be big enough
to only fit in a ``long``, so the return value is a ``long``.  All
this is reasonable but the C# result is still wrong!  Look deeper.
While the result of ``n*(n+1)/2`` is *assigned* to a ``long`` variable,
the *calculation* ``n*(n+1)/2`` is done with ``int``\ s not mathematical
integers.  By the same general type rule that led to the (n+1)/2 error 
earlier, these operations on ``int``\ s produce an ``int`` result, even
when wrong.

We need to force the *calculation* to produce a ``long``. 
In the correct looping version ``sum`` was a ``long``, and that
forced all the later arithmetic to be with longs.  Here are two variations
that work::
    
    long nLong = n;
    return nLong*(nLong+1)/2;
    
or we can avoid a new variable name by :ref:`cast` to ``long``, converting
the first (left) operand to ``long``, so all the later left-to-right
operations are forced to be ``long``::

    return (long)n*(n+1)/2;
    
You can try example :repsrc:`sum_to_n_long_quick/sum_to_n_long_quick.cs` 
to finally get a result that is dependably fast and correct.

Important lessons from this humble summation problem:

- *Working* and being *efficient* are two different things in general.  

- *Math* operations and C# operations are not always the same. 
  Knowing this in theory is not the same as remembering it in practice!

Further special syntax that only makes sense in any kind of loop is discussed in 
:ref:`break-continue`, after we introduce the last kind of loop.


We have already processed strings a character at a time, with ``while`` loops.
We took advantage of the fact that strings could be indexed.  Our ``while``
loops directly controlled the sequence of indices. Then we could
look up the character at each index of a given string ``s``::

	int i = 0;
	while (i < s.Length) {
	   code using the value of s[i]...
	   i++;
	}

Examples have been in :ref:`While-Sequence`, like

.. literalinclude:: ../../examples/introcs/char_loop1/char_loop1.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6
 
In this example we really only care about the characters, not the indices.
Managing the indices is just a way to get at the 
underlying sequence of characters.


Variables declared in a ``for``    The variable ``i`` declared before
the ``while`` statement above is still defined after the ``while`` loop.


The C# for loop statement syntax is:

| ``for (`` *initialization* ``;`` *condition* ; *update* ``)`` {
|    statement(s)
| ``}``
   
translates to

| *initialization* ``;`` 
| ``while (`` *condition* ``)`` {
|    statement(s)
|    *update* ``;``
| ``}``


A ``for`` loop is an example of *syntactic sugar*: syntax that can 
simplify things for the programmer, but can be immediately translated 
into an equivalent syntax by the compiler. For example::

    for (i = 2; i <= n; i++) {
       sum = sum + i;
    }
   
is exactly equivalent to this code similar to part of 
:ref:`SumToN <SumToN>`::

    i= 2;
    while (i <= n) {
       sum = sum + i;
       i++;
    }

