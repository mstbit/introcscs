

.. index:: function; definition

.. _A-First-Function:

C# Method 
==============================

Functions/methods are subroutines in a computer program. When a function is a part of a class, 
it's called a method. In OOP languages, functions are called methods and they are 
always declared inside and operated through designated classes. It is, therefore, 
by definition, more accurate to call these code-blocks methods rather than functions in C# 
since C# is an OOP language. However, when discussing the construct of subroutine 
in general, the term function seems more appropriate and you will see people use the term 
interchangeably from time to time.

Some important characteristics of methods/functions are:

- We design functions to be **reusable** subroutines perform certain actions so that 
  we do not have to write the same/similar code repetitively. 
- Functions will not run until it is **called**. We say we are making a "function call" 
  or "method call" call when we invoke/use the subroutine. 
- When calling a function, we often pass data into the function and we usually 
  design the function to **return** values when called. 
- The data that are passed to the method are called **arguments** and the variables 
  defined for the argument intake are called **parameters** (although they are often 
  not differentiated from each others). [#f1]_


Method Signatures: The Recipe
------------------------------

The first method you have encountered in C# is the Main method, the only entry point 
of a C# application, or, the first method to be invoked in a class [#f2]_, looks like the 
follows if you generate it with ``dotnet new console --use-program-main``:

.. code-block:: csharp
   :linenos: 
   :emphasize-lines: 5-8

   namespace HelloWorld;

   class Program
   {
      static void Main(string[] args)
      {
         Console.WriteLine("Hello, World!");
      }
   }

Note that the **Main method** is contained in a **class** (Program), which is a 
standard arrangement for OOP languages. **Main method** code block. 
When defining methods, we follow a recipe (standard syntax) 
and the ingredients to use are called **method signature**. The 
standard syntax template for method signatures is as follows: [#f4]_

.. code-block:: none
   
   [Access Modifier] [static modifier] [Return Type] MethodName(Parameter List)
   {
      // Method Body
   }

In this template, the signatures include:

.. list-table:: Method Signatures
   :widths: 10 90
   :header-rows: 1

   * - Signature 
     - Description
   * - Access Modifier 
     - This determines visibility of methods between classes, and whether 
       or not it can instantiate new objects. Since our methods in this chapter are limited 
       to this class, we will leave them off for now.
   * - static modifier
     - Define the method as a static member method of the class. When not defined as 
       static, it is an instance member. [#f3]_
   * - Return Type
     - If the method is returning a value, this indicates what data type it will 
       be. Not all methods return values. Methods that do not return a value have a return 
       type of ``void``.
   * - Method Name
     - The methodâ€™s unique ``identifier``. This is what you use to call your method.
   * - Parameter List
     - A parameter is a placeholder for specific data that the method will 
       act upon. Parameters are optional. In these cases, the ``()`` are still part of the method 
       call, but remain empty.
   * - Method Body
     - This is where you code your method. Note it is contained between ``{}``.


With method signatures, you can design methods specifically to your needs. But for now, 
let us analyze the two methods in class TryMethods below to apply our understanding of signatures:

.. code-block:: csharp
   :linenos: 
   :emphasize-lines: 10-11

   using System;                          // the using statement
   class TryMethods                       // class declaration

   {
      static void Main(string[] args)     // static modifier, return modifier, and method name
      {                                   // static: can be invoked directly; void, no return to caller
         MyMethod();                      // method MyMethod (line# 9) is called
      }

      static void MyMethod()              // static modifier, return modifier, and method name 
      {                                   // static: can be invoked directly; void, no return to caller
         Console.WriteLine("IST 1551");   // Method body
         Console.WriteLine("T.Y. Chen");  // Method body
      }

   }

.. note:: 
   You have probably noticed that you can prepare this code by making the **MyMethod** 
   project folder (``mkdir MyMethod``), then creating the project by running ``dotnet new console 
   --use-program-main`` (or just do ``dotnet new console`` then change the code to include 
   the ``Main method``). After that, you run ``code .`` from the terminal to open 
   the project in VS Code and click on Program.cs to edit the source code.


Method Calls & Return
------------------------

In the preceding code, we add a new method, the ``MyMethod`` method in addition to 
the ``Main`` method. Since the Main method is the 
first method to be invoked by the .NET common 
language runtime (CLR) when the application is started. You then **call** (or **invoke**) 
other methods (making **method calls**) from the Main method. [#f5]_ 

Note that you build your methods outside of the Main method and you make method calls 
from within the Main method. Namely, you separate the Main method (app the entry point) 
from other methods (functionalities). The purpose of the Main method, therefore, is to 
execute your programs inside the class.

An important feature of functions/methods is that they **return** values to their 
**callers**. In the example below, you see that we can use the Take a look at the sample code below

.. code-block:: csharp
   
   using System;

   class MainClass {

      static int SquareTheNumber(int num)
      {
         return num * num;
      }

      public static void Main (string[] args) {

         int digit = 4;
         int squaredNum = SquareTheNumber(digit);
         int squaredAndSummed = squaredNum + SquareTheNumber(digit);

         Console.WriteLine(squaredNum);
         Console.WriteLine(squaredAndSummed);
         Console.WriteLine(SquareTheNumber(5));

      }
   }

Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

Understanding the jumping around in the code with function calls is
crucial.  Be sure you follow the sequence detailed above.  In particular,
be sure to distinguish function **definition** from function **call**.

If it also happens to be Andre's birthday, we might define a
function ``HappyBirthdayAndre``, too. Think how to do that before
going on ....

.. rubric:: Footnotes

.. [#f1] In C#, when methods of a type are nested in another member, they are 
   called *local functions*. 
.. [#f2] Note that if you have more than one Main method in you have to use the 
   `StartupObject <https://learn.microsoft.com/en-us/dotnet/csharp/language
   -reference/compiler-options/advanced#mainentrypoint-or-startupobject>`_ 
   compiler option to specify which Main method to use as the entry point. 
.. [#f3] A class has members such as field, properties, and methods. Static 
   members of the class can be used without creating a new instance of the class. 
   For example, we can access the square root method in Math class under the 
   System namespace directly, ``Console.Write(Math.Sqrt(x));``, without using the 
   ``new`` keyword to create a new instance of the Math class. 
.. [#f4] This template and explanation is adopted from https://education.launchcode.org/intro-to-programming-csharp/chapters/methods/method-signatures.html
.. [#f5] Main methed is required for console and Web apps in .NET.  