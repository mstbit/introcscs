
.. _foreach-syntax:

``foreach`` Statement 
=====================

.. index:: statement; foreach
   foreach; syntax 

A C# ``foreach`` works like a for loop, except it does not use the header 
(initializer, condition, and iterator) for ``conditional`` looping flow control. Instead, 
the ``foreach`` loop iterates through each element in a given sequence or collection of data and 
runs a set of instructions once for each of the elements. In other words, the 
``foreach`` loop is used exclusively to loop through elements in an array 
(or other data sets). 

In the case of ``for`` loop in C#, the local loop variable refers to the index of an 
array whereas, in the case of a ``foreach`` loop, the loop variable refers to 
the ``values`` of the array.

In ``for`` loop, the loop variable is of type ``int``. The reason for this is, 
here the ``loop variable`` refers to the index position of the array. For the ``foreach`` 
loop, the ``data type`` of the ``loop variable`` must be the same as the 
*type of the values stored in the array*. For example, if you have a string array, 
then the loop variable must be of type string. 

The syntax of the foreach loop is::

   foreach (type variableName in arrayName) 
   {
      // code block to be executed
   }

Observe the following code and test it in ``csharprepl`` to see how ``foreach`` differs from the ``for`` 
statement::

   > string str = "ABCabc";
     foreach (char ch in str) {
        Console.WriteLine("Unicode for {0} is {1}.", ch, (int)ch);
     }
   Unicode for A is 65.
   Unicode for B is 66.
   Unicode for C is 67.
   Unicode for a is 97.
   Unicode for b is 98.
   Unicode for c is 99. 

To achieve the same results, the C# ``for`` loop code could look like::
   
   > string str = "ABCabc";
   > for (int i = 0; i < 6; i++)  
     { 
         Console.WriteLine("Unicode for {0} is {1}", i, (int)str[i]); 
     }
   Unicode for 0 is 65
   Unicode for 1 is 66
   Unicode for 2 is 67
   Unicode for 3 is 97
   Unicode for 4 is 98
   Unicode for 5 is 99

   > 




Since strings are considered as arrays consisting of ``char`` type characters, we can loop 
through a string using a ``foreach`` statement. Here we print out the underlying ``int`` 
Unicode value of the characters of ``char`` type. As you see, to get the values we cast 
each ``char`` to an ``int``::
   
    (int)ch
   

One thing that you need to keep in mind is that the ``for`` loop 
in C# can be used both for accessing values from an array as well as assigning 
values to an array whereas the ``foreach`` loop in C# can only be used for 
accessing the values from an array.

Also note that for the for and foreach loops, you could do all the same things with ``while`` loops,
but there are many situations where ``foreach`` loops and ``for`` loops 
are more convenient and easier to read.  



A ``foreach`` statement only works with an object that holds .
We will see many more kinds of sequences later. For now we can illustrate
with a string, which is a sequence of characters.

We have already processed strings a character at a time, with ``while`` loops.
We took advantage of the fact that strings could be indexed.  Our ``while``
loops directly controlled the sequence of indices. Then we could
look up the character at each index of a given string ``s``::

	int i = 0;
	while (i < s.Length) {
	   code using the value of s[i]...
	   i++;
	}

Examples have been in :ref:`While-Sequence`, like

.. literalinclude:: ../../examples/introcs/char_loop1/char_loop1.cs
   :start-after: chunk
   :end-before: chunk
   :dedent: 6
 
In this example we really only care about the characters, not the indices.
Managing the indices is just a way to get at the 
underlying sequence of characters.

A conceptually simpler view is just::

   for each character in s
       use the value of the character
       
To *use* "the character" in C#, we must be able to refer to it.
We might name the current character ``ch``.
The following is a variant of ``OneCharPerLine`` with a ``foreach`` 
loop::

    static void OneCharPerLine(string s) 
    {
       foreach (char ch in s) {
           Console.WriteLine(ch);
       }
    }

That is all you need! The ``foreach`` heading feeds us one
character from ``s`` each time through, using the name ``ch`` 
to refer to it.  
Of course any new variable name must be declared in C#, so ``ch``
is preceded in the heading by its type, ``char``.
Then we can use ``ch`` inside the body of the loop.  
Advancing to the next element in the sequence is automatic in the next 
time through the loop.  No ``i++`` to remember; 
no possibility of an infinite loop!

The general syntax of a ``foreach`` loop is

| ``foreach (`` **type itemName** ``in`` *sequence* ``) {``
|      statement(s) using **itemName**
| ``}``

Here is a version of IsDigits::

    static Boolean IsDigits(string s) 
    {
       foreach (char ch in s) {
           if (ch < '0' || ch > '9') {
              return false;
           }
       }
       return (s.Length > 0);
    }

See the advantages of ``foreach`` in these examples:

- They are more concise than the indexing versions.
- They keep the emphasis on the characters, not the secondary indices.
- The ``foreach`` heading emphasizes that an entire particular sequence is being 
  processed.

.. warning::  
   
   *If* you have explicit need to refer to the indices of the items in the sequence,
   then a ``foreach`` statement does not work.  Also a ``foreach`` loop supplies the items in 
   a specific order; if you need a different order, it will not work.
   
Of course you can refer to the indices of items in  sequence with a flexible 
``while`` loop, or see :ref:`For-Loops`, coming soon....



With a ``foreach`` loop, which has no explicit continuation condition, 
the ``break`` would be more clearly useful.
Here is a variant if you do not care about the specific location of the target::

    bool found = false;
    
    foreach (string s in a) {
       if (s == target) {
          found = true;
          break;
       }
    }

    if (found) {
       Console.WriteLine("Target found");
    } else {
       Console.WriteLine("Target not found");
    } 
