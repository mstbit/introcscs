.. index:: statement; for

For-Statement Syntax
============================ 

Iteration/looping is one of the three basic computer programming 
constructs (sequence, selection, iteration). Iteration means looping through a block of code. 
The number of loops is controlled by a counter, so you need to know how many times 
you want to run the code block to use the for loops.  

The ``for`` statement executes a statement or a block of statements 
while a specified Boolean expression evaluates to true, and such evaluation involves 
comparing the local loop variable to a counter that increments over every loop. 


The C# for loop statement syntax is:

| ``for (`` *initializer* ``;`` *condition* ; *iterator* ``)`` {
|    statement(s)
| ``}``

Let us practice in ``csharprepl``::

   > for (int i = 1; i <= 5; i++) 
   {                                                                                                                     
         Console.WriteLine(i);                                                                                             
   }                                                                                                                     
   1
   2
   3
   4
   5


You can see that the ``for`` loop has four parts, a three-section **header** and a body:

- **Initializer**: This section is a **variable declaration statement** that 
  declares a ``local loop variable``, or the counter, and initialize it with an initial value. 
- **Condition**: The condition section is a boolean expression that determines 
  if the next iteration in the loop should be executed. If it evaluates to true, 
  the next iteration is executed; otherwise, the loop is exited. 
- **Iterator**: The iterator section that defines what happens to the counter after each 
  execution of the body of the loop. A common behavior is reassigning 
  (increment or decrement) the value of the counter. 
- The body of the loop, which must be a statement or a block of statements.

In the example above, *initializer* is ``i = 1``, *condition* is ``i <= n``, 
and *iterator* is ``i++`` (see :ref:`arithmetic operators <arithmetic-operators>`).

Note that the initializer section is executed **only once**, before entering the loop. 
Also, the declared variable is local to the ``for`` loop heading and 
the loop body and can not be accessed from outside the for statement. 

The two semicolons are always needed in the ``for`` heading, but any of the
parts they normally separate may be omitted.  
If the condition part is omitted, the condition is 
interpreted as always true, leading to an infinite loop, that can only
terminate due to a ``return`` or :ref:`break statement <break-continue>` in the body.  

.. index:: execution sequence; for loop

For the execution sequence of for loops, note that the different parts of 
the heading are used at different times:

* When starting the whole statement, the initialization is done, and then
  the test.
* After finishing the body and returning to the heading, the iteration operations
  are done, followed by the test.

Note that the arithmetic unary operators (decrement operator ``--`` and 
increment operator ``++``) are often used in for loops. The common usage is to use them 
as prefix operators. The result is the value of the local loop variable before the operation. 
For example::

   > int num = 3;

   > num 
   3
   > num++       // with postfix operators, the result is the value before the operation
   3
   > num         // i is evaluated again. Now it shows 4. 
   4
   > 

This behavior keeps the counter value consistent with the initialization for the 
loop's first iteration. 

``for`` loops are usually favored for iteration because the   
all the information about the local loop variable are available in one place at the top, 
which helps quickly visualize the overall sequence in the loop. 


**Other variations**

The declaration of a for loop header is flexible. There may be several variables of the
same type initialized, separated by commas. Also, at the end of the ``for`` loop heading, 
the iteration portion may include more than one expression, also separated by commas.  
For example::

      for (int i = 0, j = 10; i < j; i = i+2, j++) {
         Console.WriteLine("{0} {1}", i, j);
      }

Guess what this does, and then paste it into csharprepl to check.

.. The comma separated lists in a ``for`` statement heading 
.. are mentioned here for completeness. Later we will find a situation
.. where this is actually useful.

.. index::
   statement; break
   statement; continue
   break statement
   continue statement
   
.. _break-continue:

Break and Continue
------------------------------------------

This section concerns special *break* and *continue* statements 
that can *only* occur inside a loop (any kind:  
``while``, ``for`` or ``foreach``).

You can already stop a loop in the middle with an ``if`` statement 
that leads to a choice with a ``return`` statement.
Of course that forces you to completely leave the current function. If you only want to
break out of the *innermost current loop*, but *not* out of the whole function, use
a break statement:

  ``break;`` 
  
in place of return. Execution continues after the end of the whole innermost
currently running loop statement.  
The ``break`` and ``continue`` statements only 
make practical sense inside of an ``if`` statement that is inside the loop.

Examples, assuming ``target`` already has a string value and ``a`` is an array of
strings::

    bool found = false;
    
    for (int i = 0; i < a.Length; i++) 
    {
       if (a[i] == target) {
          found = true;
          break;
       }
    }
    
    if (found) 
    {
       Console.WriteLine("Target found at index " + i);
    } else {
       Console.WriteLine("Target not found");
    } 

When an element is reached that matches ``target``, 
execution goes on *past the loop* with ``if (found)``.

An alternate implementation with a compound condition in the heading and no ``break`` is::

    bool found = false;
    
    for (int i = 0; i < a.Length && !found; i++) {
       if (a[i] == target) {
          found = true;
       }
    }
    
    if (found) {
       Console.WriteLine("Target found at index " + i);
    } else {
       Console.WriteLine("Target not found");
    } 

With a ``foreach`` loop, which has no explicit continuation condition, 
the ``break`` would be more clearly useful.
Here is a variant if you do not care about the specific location of the target::

    bool found = false;
    
    foreach (string s in a) {
       if (s == target) {
          found = true;
          break;
       }
    }

    if (found) {
       Console.WriteLine("Target found");
    } else {
       Console.WriteLine("Target not found");
    } 

Using ``break`` statements is a matter of taste. There is some advantage in reading
and following a loop that has only one exit criteria, which is easily visible 
in the heading. On the other hand, in many situations,
using a break statement makes the code much less verbose, and hence easier to follow.
If you *are* reading through the loop, it may be clearer to have an immediate action
where it is certain that the loop should terminate. 

All the modifiers about *innermost* loop are important 
in a situation like the following::

   for (....) {
      for (....) {
         ...
         if (...) {
         ...
         break;
         }
         ...
      }
   } 

The break statement is in the inner loop. If it is reached, the inner loop ends,
but the **inner loop** is just a **single statement** inside the outer loop, 
and **the outer loop continues**.  
If the outer loop continuation condition remains true,
the inner loop will be executed again, 
and the break may or may not be reached that time. As an example::

  for (int i = 0; i <= 3; i++)
  {
      for (int j = 0; j <= 3; j++)
      {

         if (i == 2)
         {
            break;
         }

         Console.WriteLine("{0} -- {1}", i, j);
      }
   }

Can you determine the output of the preceding code? Try it in ``csharprepl`` or a test project 
in your tests folder. 



For completeness we mention the much less used ``continue`` statement:

  ``continue;``  

It does not break out of the whole loop: 
It just skips the rest of the *body* of the innermost current loop, *this time* through the loop.  
In the simplest situations, a ``continue`` statement just avoids an extra ``else`` clause. 
It can considerable shorten code if the test is inside of complicated, deeply nested 
``if`` statements. As an example::

   for (int i = 0; i <= 3; i++)
   {
      for (int j = 0; j <= 3; j++)
      {
         if (i == 2)
         {
              continue;
         }

         Console.WriteLine("{0} -- {1}", i, j);
      }
   }

Can you determine the output of the preceding code? Try it in ``csharprepl`` or a test project 
in your tests folder. 






