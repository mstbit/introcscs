Abstraction
=================

**Abstraction** is achieved by hiding implementation details of a class and showing only 
essential information to the user. Abstraction can be achieved with either **abstract** classes 
or **interfaces** (which you will learn more about in a later section). 

In C#, abstraction is implemented using abstract classes and methods. The ``abstract`` keyword 
is used to create abstract classes and abstract methods:

- **Abstract class**: is a restricted class that cannot be used to create objects; instead, 
  it must be **inherited** from a child class to be used.
- **Abstract method**: can **only** be used in an abstract class, and it **does not have a body**. 
  The body is provided by the derived (child) class.

Important characteristics of abstract classes include: 

- Members: An abstract class can contain both **abstract** and **non-abstract** members.
- ``override``: Derived classes that implement abstract methods must use the override keyword.
- **Use**: An abstract class cannot be instantiated using a ``new`` keyword; it must be inherited by a 
  derived (child) class in order to be used. 
- **Abstract members**: Abstract members of an abstract class may include methods, properties, or events that 
  **do not have an implementation**, and must be implemented in the derived class.
- If a class contains any abstract members, it must also be marked as abstract.
- **concrete class**: A derived class that implements all of the abstract members of its base class is considered to be a 
  **concrete class**, and can be instantiated.

Here is an example of an abstract class that contains an abstract method in C#:

.. code-block:: 
    :linenos:
    :emphasize-lines: 1, 3

    abstract class Shape
    {
        public abstract double GetArea();
    }

Note that, since an abstract cannot be instantiated, C# will give you an error message if you try to create an object 
from it::
    
    Shape shape = new Shape();
    
You will receive an error message like (in macOS):

.. code-block:: bash

    tcn85@mac:~/workspace/introcscs/Ch11OOP$ dotnet run
    /Users/tcn85/workspace/introcscs/Ch11OOP/Vehicle.cs(29,23): error CS0144: Cannot create an 
    instance of the abstract type or interface 'Shape' [/Users/tcn85/workspace/introcscs/Ch11OOP/Ch11OOP.csproj]

    The build failed. Fix the build errors and run again.

<<<<<<< HEAD:source/11.oop/1103.abstraction copy.rst
or in Windows::
=======
or in Windows:
>>>>>>> 74e7e86d (committed @ 2024-1104-160428):source/11.OOP/1103.abstraction.rst

.. code-block:: bash

    PS C:\Users\tcn85\workspace\introcscs\Ch11OOP> dotnet run
    C:\Users\tcn85\workspace\introcscs\Ch11OOP\Vehicle.cs(29,23): error CS0144: Cannot create an 
    instance of the abstract type or interface 'Shape' [C:\Users\tcn85\workspace\introcscs\Ch11OOP\Ch11OOP.csproj]

    The build failed. Fix the build errors and run again.
    PS C:\Users\tcn85\workspace\introcscs\Ch11OOP> 

This abstract class represents a shape, and has a single abstract method called GetArea() that 
returns the area of the shape. From Shape, you can define different classes inheriting Shape (such as Circle, 
Square, Triangle...) and each class would implement the ``GetArea`` method differently since this method is 
abstract and therefore it does not have an implementation and must be implemented in a derived class.

Here is an example of a derived class that implements the GetArea() method:

.. code-block:: csharp

    class Circle : Shape
    {
        private double radius;                  // field (data)

        public Circle(double radius)            // a constructor intaking argument double radius
        {
            this.radius = radius;               // create the variable to be used in the object
        }

        public override double GetArea()        // implementation of the GetArea method from Shape; override
        {
            return Math.PI * radius * radius;
        }
    }

 
    class Program
    {
        static void Main(string[] args)
        {
            Circle circle = new Circle(10);
            double area = circle.GetArea();
            Console.WriteLine(area);            // output: 314.1592653589793      
        }
    }


As another example, see the abstract class and methods defined and executed as follows.

.. code-block:: csharp
    :linenos: 
    :emphasize-lines: 1, 3, 5, 12, 14-17, 25

    abstract class Animal                       // Abstract class
    {
        public abstract void animalSound();     // Abstract method (does not have a body)
        
        public void sleep()                     // Regular method
        {
            Console.WriteLine("Zzz");
        }
    }

    
    class Pig : Animal                          // Derived class (inherit from Animal)
    {
        public override void animalSound()      // method implementation body of animalSound(); override 
        {
            Console.WriteLine("The pig says: wee wee");
        }
    }


    class Program
    {
        static void Main(string[] args)
        {
            Pig myPig = new Pig();              // Create a Pig object
            myPig.animalSound();                // Call the implemented abstract method: 
                                                // output The pig says: wee wee
            myPig.sleep();                      // Call the regular method
        }                                       // output: Zzz
        
    }


Abstraction is a powerful technique that allows for a **separation of concerns** between the 
interface and implementation of a class. It helps to reduce complexity and improve 
maintainability by allowing changes to be made to the implementation without affecting 
the overall behavior of the class. In this example below, you see that this time a ``Rectangle`` 
class is created to inherit the **abstract class** ``Shape`` and two **abstract methods** are 
implemented in the ``Rectangle`` class. 

.. code-block:: csharp
    :linenos:

    abstract class Shape
    {
        public abstract double GetArea();
        public abstract double GetPerimeter();
    }

    class Rectangle : Shape
    {
        private double width;
        private double height;

        public Rectangle(double width, double height)
        {
            this.width = width;
            this.height = height;
        }

        public override double GetArea()
        {
            return width * height;
        }

        public override double GetPerimeter()
        {
            return 2 * (width + height);
        }
    }