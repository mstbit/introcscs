%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Introduction to Computer Science in C\#}
\date{Jul 14, 2024}
\release{14 Jul 2024}
\author{Andrew N. Harrington and George K. Thiruvathukal}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Context}
\label{\detokenize{context/context:context}}\label{\detokenize{context/context::doc}}
\sphinxstepscope


\section{Motivation for This Book}
\label{\detokenize{context/motivation:motivation-for-this-book}}\label{\detokenize{context/motivation::doc}}
\sphinxAtStartPar
This is really a preface, but the otherwise very capable Sphinx publishing environment
that we use is not set up for a separate preface.


\subsection{Pedagogy}
\label{\detokenize{context/motivation:pedagogy}}
\sphinxAtStartPar
Our first aim is to provide a good introduction and
conceptual framework for more computer science, not an encyclopedic coverage of C\#.
C\# will not be most students’ only language, or necessarily the most used.
Designing and creating algorithms in a particular language is an important skill,
requiring ongoing effort, so most of the text is still centered on C\#.

\sphinxAtStartPar
C\# is an object\sphinxhyphen{}oriented language.  There is the ongoing argument about when to introduce
details of object\sphinxhyphen{}oriented programming.  We last taught Java, objects first.  Students
dutifully followed our lead.  Later, we saw quick programs that students wanted
to write for themselves,
that were layered with totally unnecessary and distracting instances of objects.

\sphinxAtStartPar
We have seen less problem with the opposite order, which we use:
start off with more procedural programming, then introduce the use of
instances of existing classes of objects, and then move to designing
classes with instance variables, constructors, and instance methods,
and see where they are truly useful.  If you prefer,
after the chapter on functions you can read the first couple
of sections in {\hyperref[\detokenize{classes/classes:classes}]{\sphinxcrossref{\DUrole{std,std-ref}{Classes and Object\sphinxhyphen{}Oriented Programming}}}}, that
cover defining your own simple objects.

\sphinxAtStartPar
We tend to introduce examples first, and then the general syntax,
and then more examples and exercises. Later examples
on a subject are sometimes essentially
links to documented code that is both directly visible on the web and
in the separate download of all of the example source code.

\sphinxAtStartPar
There are review questions at the end of most chapters.
The review questions may seem to be in a strange order: Often we invite students
to consider a general overarching theme in an early question.  In case that
was too much to bite off, later questions often explicitly address a specific
point that would have been an implicit part of an earlier general question.
Sometimes a later more pointed question even gives an answer to part of
an earlier question.

\sphinxAtStartPar
Labs are intended as early practice on a subject, with generally small
bits requested at a time.  They are usually included in the main body
of the book soon after the needed
background is introduced.
There are also larger assignments as some of the appendix sections.


\subsection{C\# and Mono}
\label{\detokenize{context/motivation:c-and-mono}}
\sphinxAtStartPar
We have taught introductory programming for many years,
through a progression of programming languages.  Our last language was Java,
still the language of the AP test, which drives so many introductory texts.

\sphinxAtStartPar
We had C\# in mind:  It is a more modern language.  Its designers got to reflect
on the glitches with Java, and address them effectively.

\sphinxAtStartPar
The key problem with C\# used to be that it was totally a Microsoft language for Windows.
Many of our students have their own machines: many are OS\sphinxhyphen{}X machines from Apple;
some are Linux.
We did not want to cut those students off.
Nor did we want to limit students to thinking of
a computer as a Windows machine.  Meanwhile the open source implementation
of C\#, Mono, has been maturing, along with its tool chains.

\sphinxAtStartPar
While many open\sphinxhyphen{}source tools have hackers jumping in to eliminate bugs, and maybe
providing enough documentation for a professional, documentation for a
beginner is often lacking.  This book contributes there, partly in the
documentation for Mono’s lovely interactive environment csharp, and also
for the integrated development environment, Xamarin Studio.
We show beginners how to start using the Xamarin Studio environment,
with its large array of features (not all needed by the
beginner), and introduce more features as needed.

\sphinxAtStartPar
We aim to end up with a book that provides a solid conceptual framework
for beginning computer scientists in the context of
the clean, well\sphinxhyphen{}established modern language,  C\#,
using multi\sphinxhyphen{}platform free and open\sphinxhyphen{}source
tools, with clear documentation.

\sphinxAtStartPar
We hope that you find this to be a winning combination.

\sphinxstepscope


\section{Resources Online}
\label{\detokenize{context/intro:resources-online}}\label{\detokenize{context/intro::doc}}
\sphinxAtStartPar
This book is designed for Comp 170 at Loyola University, Chicago.
The materials are available to all on the web.
Here are some important web links:

\index{book examples download@\spxentry{book examples download}}\index{examples download@\spxentry{examples download}}\index{source download@\spxentry{source download}}\ignorespaces \begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/archive/master.zip}{The course example file,}
is the \sphinxstyleemphasis{essential resource} to download and unzip onto your machine.
The zip file and the folder it unzips to have a long name,
introcs\sphinxhyphen{}csharp\sphinxhyphen{}master\sphinxhyphen{}examples.
We suggest you \sphinxstyleemphasis{rename the unzipped folder}
\sphinxcode{\sphinxupquote{examples}} to match later references.

\sphinxAtStartPar
Computer programs are designed to run on a computer and solve problems.
Though the initial problems will be tiny and often silly,
they will serve as learning tools to prepare for substantive problems.

\item {} 
\sphinxAtStartPar
\sphinxurl{http://introcs.cs.luc.edu} is an online text version for your web browser.
See also {\hyperref[\detokenize{context/download:alt-formats}]{\sphinxcrossref{\DUrole{std,std-ref}{Downloading and Reading Options}}}} for pdf and epub versions.
Except on very geometrically oriented topics,
\sphinxstyleemphasis{text\sphinxhyphen{}oriented learners may be happiest just reading the book}
in one of these formats.

\item {} 
\sphinxAtStartPar
\sphinxurl{https://luc.box.com/CSharpVideos} is a box.com
folder containing all the videos.
The numbers
at the beginning of the titles are chapter and section numbers from the text.
These make it easy to sequence the videos, even though there is not an
automatic \sphinxstyleemphasis{playlist}.
The listing in box.com takes up several pages.
These box.com videos may be
\begin{itemize}
\item {} 
\sphinxAtStartPar
streamed, including at full size (though generally after an initial delay),

\item {} 
\sphinxAtStartPar
downloaded individually or

\item {} 
\sphinxAtStartPar
the whole gigabyte folder can be downloaded at once to play later on your machine.
(This is a choice on the menu under the page’s Folder Options.)

\end{itemize}

\sphinxAtStartPar
There is a mixture of new high\sphinxhyphen{}def videos and older
lower resolution
800x600 pixel videos.   In that folder see 00README.html,
\sphinxurl{https://luc.box.com/s/2lqak4pbsdcyw08ds3ia},
for a description of the differences
between the old videos and the latest update of the online book.

\sphinxAtStartPar
For those who learn best with
spoken words combined with written words, the videos should be a good
start.  Even if you use a video for a section, you are encouraged to
\sphinxstyleemphasis{review the written text afterward}.
Then be aware of the written version for quick reference.
The written text may include extra details and exercises, and it
will have the latest revisions.

\end{itemize}

\sphinxAtStartPar
In various formats, be aware of these helpful features:
\begin{itemize}
\item {} 
\sphinxAtStartPar
We have picked out particularly important words, phrases, and symbols,
and put them in our
\sphinxhref{genindex.html}{index}, which is accessible from the banner
of each web page.  The banner stays visible if the window is big enough,
and if the window is smaller, the baner only appears at the beginning
of the page with a dropdown menu for most of the options.

\item {} 
\sphinxAtStartPar
In a web version on our website, you can use the
\sphinxhref{search.html?q=\&check\_keywords=yes\&area=default}{Search option} to
look for words, in general.  The search link is also accessible from
the web page banner.  This does \sphinxstyleemphasis{not} work on a downloaded
local html copy.

\item {} 
\sphinxAtStartPar
The web version and pdf versions display mathematical formulas
prettily.  If you use the local html version when not connected to the
internet, you see only the LaTex encoded source for formulas.
While offline reading sections
with math formulas, we suggest using the pdf version.

\item {} 
\sphinxAtStartPar
We start with a brief table of contents for the whole book.
\sphinxstyleemphasis{In the web versions}
you can get the most detailed table of contents for a single chapter by
clicking on a chapter title in the main table of contents or a
chapter title in the Site drop\sphinxhyphen{}down menu in the banner.

\item {} 
\sphinxAtStartPar
The web version shifts the behavior of the top banner depending  on
screen resolution, so it adapts for anything from large monitors
to small mobile devices. With a wide screen the banner stays at the
top of your screen, and shows all the standard internal links and
drop\sphinxhyphen{}down menus.  On a narrower screen the banner is only at the top
of each webpage, and scrolls off the screen; the only direct
link is to the main table of contents, while the rest of the links
of the wide version can be accessed via the icon at the right side of
the banner.

\end{itemize}

\sphinxAtStartPar
Here are further links that may be useful in our repository:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp/}
is the home page for the repository of all the sources for the book.
To read this book, you do \sphinxstyleemphasis{not} need to go to that URL, but if you do, the home page
gives you an idea of what \sphinxstyleemphasis{updates have been made recently} to the book or
accompanying examples. Since improvements are made on an ongoing basis,
the notes about recent changes may be useful to you.

\sphinxAtStartPar
The multiple production versions are generated largely by
\sphinxhref{http://sphinx.pocoo.org/}{Sphinx} software from the common
set of sources in the repository.  The sources are
largely plain text files.

\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/}
is another repository containing the \sphinxstyleemphasis{latest versions}
of the source code files.
You can quickly browse and view individual files under the Source tab.
Example file links throughout this text refer to these repository files.

\end{itemize}

\sphinxstepscope

\index{book alternate formats@\spxentry{book alternate formats}}\ignorespaces 

\section{Downloading and Reading Options}
\label{\detokenize{context/download:downloading-and-reading-options}}\label{\detokenize{context/download:alt-formats}}\label{\detokenize{context/download:index-0}}\label{\detokenize{context/download::doc}}
\sphinxAtStartPar
Most readers will want to download the C\# examples in ZIP format. More experienced readers (with
previous background) may prefer using GitHub directly. (See below.)


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Example Source Code and Videos}\label{\detokenize{context/download:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{15}{45}|\X{30}{45}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
URL
\\
\hline
\sphinxAtStartPar
C\# Examples (as ZIP)
&
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/releases/latest/}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We offer the book in HTML, PDF, and EPUB formats. Kindle users should use EPUB, which can be converted
to MOBI format. (We plan to offer it soon through our main site.)


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Alternate Book Formats}\label{\detokenize{context/download:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{15}{45}|\X{30}{45}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Format
&\sphinxstyletheadfamily 
\sphinxAtStartPar
URL
\\
\hline
\sphinxAtStartPar
Web Site
&
\sphinxAtStartPar
\sphinxurl{http://introcs.cs.luc.edu}
\\
\hline
\sphinxAtStartPar
PDF
&
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp/releases/latest/download/comp170.pdf}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The following is for developers only!
\end{sphinxadmonition}

\sphinxAtStartPar
The book source code and examples are all maintained on GitHub. We welcome pull requests and
will acknowledge any helpful and constructive contributions.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{GitHub}\label{\detokenize{context/download:id3}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{15}{45}|\X{30}{45}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
URL
\\
\hline
\sphinxAtStartPar
C\# Examples
&
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples}
\\
\hline
\sphinxAtStartPar
Book Source
&
\sphinxAtStartPar
\sphinxurl{https://github.com/LoyolaChicagoBooks/introcs-csharp}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope

\index{computer science@\spxentry{computer science}}\ignorespaces 

\section{Computer Science, Broadly}
\label{\detokenize{context/computerscience:computer-science-broadly}}\label{\detokenize{context/computerscience:computer-science}}\label{\detokenize{context/computerscience:index-0}}\label{\detokenize{context/computerscience::doc}}
\sphinxAtStartPar
We intend this book as an introduction to computer science, with a focus on
creating problem solutions in the C\# programming language.
We should not jump in too quickly.  You can get lost in our details and
miss an idea of the much larger breadth of computer science.

\index{information processing@\spxentry{information processing}}\ignorespaces 

\subsection{Information Processing}
\label{\detokenize{context/computerscience:information-processing}}\label{\detokenize{context/computerscience:index-1}}
\sphinxAtStartPar
Computer Science is the study and practice of information processing.
This can take many forms.  Many forms appear in electronic computers,
but information processing takes place in many other contexts, too:

\sphinxAtStartPar
In the early days of electronic computers,
the information was largely numerical, calculating mathematical functions.

\sphinxAtStartPar
Later analyzing textual information
has become much more important, for instance:
What can you tell about the severity of the current flu outbreak by
analyzing the phrasing in Google searches?

\sphinxAtStartPar
Images are analyzed:  What can a satellite image tell you about the
distribution of drought?

\sphinxAtStartPar
Sounds:  how do you convert verbal speech accurately
into written sentences?

\sphinxAtStartPar
DNA holds information that our bodies process into proteins.

\sphinxAtStartPar
Our brain chemicals and
electronic signals process information.  There is  rich interplay
between cognitive scientists and computer scientists modeling
problem solving in the brain with \sphinxstyleemphasis{neural nets} on a computer,
sometimes to better understand brains and
sometimes to
better solve problems on an electronic computer.

\sphinxAtStartPar
Economic systems are becoming better understood in terms of the
flow of information.

\sphinxAtStartPar
The \sphinxstyleemphasis{computer} doing computations and processing can be a familiar \sphinxstyleemphasis{electronic}
computer, but it can be genes or brain chemicals,
or a whole society as its economy adapts.

\index{algorithms@\spxentry{algorithms}}\ignorespaces 

\subsection{Algorithms}
\label{\detokenize{context/computerscience:algorithms}}\label{\detokenize{context/computerscience:index-2}}
\sphinxAtStartPar
Algorithms are at the heart of traditional problem solving .  An \sphinxstyleemphasis{algorithm}
is a clearly expressed sequence of steps leading to a result in a
finite amount of time.

\sphinxAtStartPar
A recipe for baking a pound cake is an algorithm.

\sphinxAtStartPar
Such an algorithm has useful concepts that we use later in computer
programming:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A named sub\sphinxhyphen{}problem: your recipe may include the instruction
“Beat 4 eggs.”  The recipe probably says no more about it, but this is
\sphinxstyleemphasis{shorthand}, a name for a simpler sequence of steps, an
algorithm like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Beating Any Number of Eggs
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
1. Get a bowl large enough for the eggs.
2. For each egg:
   a. Crack its shell on the edge of the bowl.
   b. Add the contents of the shell to the bowl.
3. Mix the eggs with a whisk.
4. Continue with step 3 until you cannot
   distinguish the white and yolks.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Parameters: The egg beating instructions work, in general, for any number
of eggs.  To use these instructions for a \sphinxstyleemphasis{particular} pound cake,
you must supply a specific value to use to make the general instructions
become clear.  The pound cake recipe that uses
the egg beating instructions, uses the number \sphinxstylestrong{4} as the actual data.

\item {} 
\sphinxAtStartPar
Repetition: The instructions for cracking an egg are not \sphinxstyleemphasis{written} repeatedly,
for every egg.  The instruction is stated once, and we are told how
long to go on: for each egg in step 2.  Step 4 says
when to stop repeating step 3.

\end{itemize}

\index{data representation@\spxentry{data representation}}\index{Jaquard loom@\spxentry{Jaquard loom}}\index{Pascaline@\spxentry{Pascaline}}\ignorespaces 

\subsection{Data Representation}
\label{\detokenize{context/computerscience:data-representation}}\label{\detokenize{context/computerscience:index-3}}\label{\detokenize{context/computerscience:id1}}
\sphinxAtStartPar
A recipe represents data by words that get processed by a human reader.
Machines have used different representations.  One of the earliest
adding machines, the Pascaline,
\sphinxhref{http://en.wikipedia.org/wiki/Pascal's\_calculator}{http://en.wikipedia.org/wiki/Pascal’s\_calculator},
represented numbers by the angle of
rotation of interlocked gears.
An abacus uses the positions of groups of sliding beads to represent digits.
The Jacquard loom,
\sphinxurl{http://en.wikipedia.org/wiki/Jacquard\_weaving},
used cards with each row of holes punched in them
indicating which warp threads are raised and which lowered when a cross
thread is woven in.

\index{bit@\spxentry{bit}}\index{byte@\spxentry{byte}}\index{binary number system@\spxentry{binary number system}}\index{base 2@\spxentry{base 2}}\ignorespaces 
\sphinxAtStartPar
In modern electronic computers the most basic bit of data
(actually called a \sphinxstyleemphasis{bit}) is held by two\sphinxhyphen{}state switches, often
in the form of a higher voltage vs. a grounded state.  The symbolic representation
is often 0 vs. 1.  This symbolism comes from the representation of integers
in \sphinxstyleemphasis{binary notation}, also called \sphinxstyleemphasis{base 2}:
It is a place value system, but where each place
in a numeral is a 0 or a 1 and represents a power of two, so 1101 in binary
can be viewed in our decimal system as
\((1)2^3+(1)2^2+(0)2^1+(1)2^0=8+4+0+1=13\).

\sphinxAtStartPar
Computer hardware can only handle a limited number of bits at a time,
and memory space is limited, so usually integers are stored in a limited
space, like 8, 16, 32 or 64 bits.
We illustrate with the smallest, 8 bits, called a \sphinxstyleemphasis{byte}.  Since
each bit has two possible states, 8 bits have \(2^8=256\) possible states.
Directly considered as binary numerals, they represent 0 through
\(2^8-1=255\).

\sphinxAtStartPar
We also want to represent negative numbers, and have about half of the available
codes for them.  An 8\sphinxhyphen{}bit signed integer in \sphinxstyleemphasis{twos complement} notation
represents 0 through \(2^7-1\)
just as the unsigned numbers do.  These are all the 8\sphinxhyphen{}bit codes with a leading 0.
A negative number \(n\) in the range \(-2^7=-128\) through \sphinxhyphen{}1,
is represented by what would be
the unsigned notation for \(n+2^8\).  These will be all the
8\sphinxhyphen{}bit codes with a leading 1.
For example \sphinxhyphen{}3 is represented like unsigned 256 \sphinxhyphen{} 3 = 253: 11111101 in binary.

\index{mantissa and exponent@\spxentry{mantissa and exponent}}\ignorespaces 
\sphinxAtStartPar
Limited precision approximation of real numbers are stored in something like
scientific notation, except in binary,  roughly \(\pm(m)2^e\),
with a sign, mantissa m and exponent e. Both e and m have
fixed numbers of bits, so the limited options for the
mantissa restricts the \sphinxstyleemphasis{precision} of the numbers, and the limited options
for the exponent restricts the \sphinxstyleemphasis{range}. Data on these limits for
different sized numeric codes is in {\hyperref[\detokenize{data/types-and-conversions:value-types}]{\sphinxcrossref{\DUrole{std,std-ref}{Value Types and Conversions}}}}.

\sphinxAtStartPar
Once you have numbers, all sorts of other kinds of data can be encoded:
Characters
like on your keyboard each have a numerical code associated with each one.  For
example the unicode for the letter A is 65.  Images are often
represented as a sequence of colored pixels.  Since the human eye is only
sensitive to three specific colors, red, green, and blue,
a pixel is represented by a numerical intensity
for each of the three colors.

\index{instruction representation@\spxentry{instruction representation}}\index{machine language@\spxentry{machine language}}\index{assembler@\spxentry{assembler}}\index{interpreter@\spxentry{interpreter}}\index{architecture@\spxentry{architecture}}\ignorespaces 

\subsection{Instruction Representation}
\label{\detokenize{context/computerscience:instruction-representation}}\label{\detokenize{context/computerscience:index-6}}
\sphinxAtStartPar
Besides the data, instructions need a representation too, and an agent to
interpret them.  In the earliest electronic computers the two\sphinxhyphen{}state switches
were relays or later vacuum tubes, and the machine was \sphinxstyleemphasis{manually rewired} when a
new set of instructions/program was needed.  It was a great advance in the 1940’s
when the instructions also became symbolic,
represented by binary codes that the computer
could recognize and act on,
\sphinxurl{http://en.wikipedia.org/wiki/Von\_Neumann\_architecture}.
This code is called \sphinxstyleemphasis{machine language}.
With machine language the instructions became a form of data that could be stored
in computer memory.  We distinguish the \sphinxstyleemphasis{hardware} on which programs are run
from the stored programs, the \sphinxstyleemphasis{software}.  The \sphinxstyleemphasis{architecture} of the
hardware determines the form and capacities of the machine language, so
machines with a different hardware architecture are likely to have distinct
machine languages.

\sphinxAtStartPar
Biologists have a fair idea of how protein sequence data is encoded in DNA,
but they are still working on how the DNA instructions are encoded
controlling which proteins should be made when.

\sphinxAtStartPar
In this book we will not be writing instructions shown as
sequences of 0’s and 1’s!
Some of the earliest programs were to help programmers
work with more human\sphinxhyphen{}friendly tools, and an early one
was an \sphinxstyleemphasis{assembler}, a program that took easier to understand instructions
and automatically translated them into machine language.  An example
assembler instruction would be like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
MOV 13, X
\end{sphinxVerbatim}

\sphinxAtStartPar
to move the value 13 to a storage location identified by the name X.

\sphinxAtStartPar
Machine instructions are very elementary, so programming
was still tedious, and code could not be reused on a
machine with a different architecture.

\sphinxAtStartPar
The next big step past assembler was the advent of
\sphinxstyleemphasis{high level} languages, with instructions more like normal mathematical or
English expressions.  Examples are Fortran (1954) and Cobol (1959).
A Fortran statement for calculating a slope like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
S=(Y\PYGZhy{}V)/(X\PYGZhy{}U)
\end{sphinxVerbatim}

\sphinxAtStartPar
might require seven or or more machine code instructions.

\sphinxAtStartPar
To use a Fortran program required three steps: write it (onto punch cards
originally), compile it to machine code, and execute the machine code.
The compiler would still be architecture specific, but the compiler for
an architecture would only need to be written once, and then any number of
programs could be compiled and run.

\sphinxAtStartPar
A later variant for executing a high\sphinxhyphen{}level language is
an \sphinxstyleemphasis{interpreter}.  An interpreter translates the high\sphinxhyphen{}level language
into machine code, and immediately executes it, not storing the
machine code for later
use, so every time a statement in the code is executed again,
the translation needs to be redone.  Interpreters are also
machine\sphinxhyphen{}specific.

\sphinxAtStartPar
Some later languages like Java and C\# use a hybrid approach: A compiler,
that can run on any machine, does most of the work by
translating the high\sphinxhyphen{}level language program
into a low\sphinxhyphen{}level \sphinxstyleemphasis{virtual machine}
language called a \sphinxstyleemphasis{bytecode}.  This is not the machine language for any real machine,
but the bytecode is simple
enough that writing an interpreter for it is very easy.
Again the interpreter for the bytecode must be machine\sphinxhyphen{}specific.
In this approach:

\sphinxAtStartPar
Program source =\textgreater{} COMPILER =\textgreater{} bytecode =\textgreater{} INTERPRETER =\textgreater{} execution

\index{program development cycle@\spxentry{program development cycle}}\ignorespaces 

\subsection{Program Development Cycle}
\label{\detokenize{context/computerscience:program-development-cycle}}\label{\detokenize{context/computerscience:index-7}}
\sphinxAtStartPar
The easiest way to check your understanding of small new pieces of C\# is to write
a highly specified small program that will be sure to test the new ideas.
That is totally unlike the real world of programming.  Here is a more realistic
sequence:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Clients have a problem that they want solved.

\item {} 
\sphinxAtStartPar
They connect with software developers.

\item {} 
\sphinxAtStartPar
The clients discuss the needs of their users.

\item {} 
\sphinxAtStartPar
The software developers work with them to make sure they
understand the desired deliverables, and work through the
design decisions and their tradeoffs.

\item {} 
\sphinxAtStartPar
Software developers start building and testing and showing off the
core pieces of the software, and build on out.

\item {} 
\sphinxAtStartPar
The clients may not have a full idea of what they want and the
software developers may not have a full idea of what is feasible, and
seeing the latest version leads both sides to have a clearer vision.
Then the previous process steps are repeated, iteratively refining
the product.

\item {} 
\sphinxAtStartPar
After a production version is out, there may be later versions and error
fixes, again cycling back to the earlier steps.

\end{enumerate}

\sphinxAtStartPar
Note that very important parts of this process are not centered on coding,
but on communicating clearly with a possibly non\sphinxhyphen{}technical client.
Communication skills are critical.

\index{computer science@\spxentry{computer science}!key concepts@\spxentry{key concepts}}\ignorespaces 

\subsection{Key Computer Science Areas}
\label{\detokenize{context/computerscience:key-computer-science-areas}}\label{\detokenize{context/computerscience:index-8}}
\sphinxAtStartPar
Most of the introduction so far has been about key concepts that underlie
basic programming. Most of the parts so far about electronic computers
could have been written decades ago.  Much has emerged since then,
\begin{itemize}
\item {} 
\sphinxAtStartPar
the Internet

\item {} 
\sphinxAtStartPar
the development of economical multi\sphinxhyphen{}processor machines
distributing computation into many parallel parts

\item {} 
\sphinxAtStartPar
the massive explosion of the amount of information to be stored
from diverse parts of life

\item {} 
\sphinxAtStartPar
the coming \sphinxstyleemphasis{Internet of things}, where sensors are coming to all
sorts of previously “dumb” parts of the world, that now can be tracked
by GPS and reacted to in real time.

\item {} 
\sphinxAtStartPar
Computers are now embedded in all sorts of devices:  toasters, thermostats,….
Automobiles of today have more computing power embedded in various devices
than early mainframe computers.

\end{itemize}

\sphinxAtStartPar
We conclude with a brief discussion of some of the other organizing
principles of
computer science.
\begin{description}
\sphinxlineitem{Communication}
\sphinxAtStartPar
As the world is criss\sphinxhyphen{}crossed with media transmitting gigabytes of
data per second, how do we keep the communication reliable and secure?

\sphinxlineitem{Coordination}
\sphinxAtStartPar
With multiple networked entities, how do we
enhance cooperation, so more work is done in parallel?

\sphinxlineitem{Recollection}
\sphinxAtStartPar
As the amount of data stored skyrockets, how do we effectively store
and efficiently retrieve information?

\sphinxlineitem{Evaluation}
\sphinxAtStartPar
How do we predict the performance and plan the necessary capacity
for computer systems?  The most spectacular recent public failure
in this area was the rollout of the federal Affordable Care
website.

\sphinxlineitem{Design}
\sphinxAtStartPar
How do we design better/faster/cheaper/reliable hardware and software systems?
What new programming languages will be more expressive, lead to fewer
time\sphinxhyphen{}consuming errors, or be useful in proving that a major program never
makes a mistake?  Errors in programs controlling machines delivering
radiation for cancer treatment have had errors and led to patient death.

\sphinxAtStartPar
Hardware changes can be evolutionary or revolutionary:
Instead of electric circuits can we use light, quantum particles, DNA…?

\sphinxlineitem{Computation and Automation}
\sphinxAtStartPar
What can we compute and automate?  Some useful
sounding problems have been proven to be unsolvable.  What are the limits?

\end{description}

\index{Denning \sphinxhyphen{} Peter@\spxentry{Denning \sphinxhyphen{} Peter}}\index{Miles \sphinxhyphen{} Rob@\spxentry{Miles \sphinxhyphen{} Rob}}\index{C\# Yellow Book@\spxentry{C\# Yellow Book}}\ignorespaces 
\sphinxAtStartPar
A detailed discussion of these principles and the breadth of
importance of computer science can be found at
\sphinxurl{http://denninginstitute.com/pjd/GP/GP-site/welcome.html}.

\sphinxAtStartPar
For an alternate general introduction to programming and the context of C\# in particular,
there is another free online source,
Rob Miles’
C\# Yellow Book, available at
\sphinxurl{http://www.csharpcourse.com}.
Note that it is written specifically for Microsoft Windows use, using
Visual Studio software development environment, which works only on Windows machines,
and costs a lot if you are not a student.

\sphinxAtStartPar
The {\hyperref[\detokenize{data/lab-edit-compile-run:lab-edit-compile-run}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab: Editing, Compiling, and Running with Xamarin Studio}}}} will introduce an alternative to the
Microsoft environment: Xamarin Studio and Mono, which are free,
open\sphinxhyphen{}source software projects that make C\# available for multiple platforms:
Windows, Mac, or Linux machines.  With a substantial fraction of students having their own
machine that does  \sphinxstyleemphasis{not} run Windows, this flexibility is important.

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{context/reviewcontext:chapter-review-questions}}\label{\detokenize{context/reviewcontext::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What is an algorithm?

\item {} 
\sphinxAtStartPar
Are computers the only things that can perform the operations
in an algorithm?

\item {} 
\sphinxAtStartPar
What are important types of information?

\item {} 
\sphinxAtStartPar
What are very distinct important ways that information is stored?

\item {} 
\sphinxAtStartPar
What is a \sphinxstyleemphasis{bit}?

\item {} 
\sphinxAtStartPar
Look at our brief mention of a Jaquard loom.
In a Jacquard loom, how is a single bit of information stored?
What two choices does it represent?

\item {} 
\sphinxAtStartPar
Does a computer generally execute a C\# program directly?
Briefly, what transformation happens first?

\item {} 
\sphinxAtStartPar
Is coding the only thing important in developing a real\sphinxhyphen{}world
application?  What are other important parts of the process?

\item {} 
\sphinxAtStartPar
Is computer science all about writing computer programs?  What are
some important large areas of concern in computer science?

\end{enumerate}

\sphinxstepscope


\chapter{C\# Data and Operations}
\label{\detokenize{data/data:c-data-and-operations}}\label{\detokenize{data/data::doc}}
\sphinxstepscope

\index{introduction@\spxentry{introduction}}\ignorespaces 

\section{A Sample C\# Program}
\label{\detokenize{data/sampleprogram:a-sample-c-program}}\label{\detokenize{data/sampleprogram:sample-program}}\label{\detokenize{data/sampleprogram:index-0}}\label{\detokenize{data/sampleprogram::doc}}
\sphinxAtStartPar
As a start let us consider a ridiculously simple problem and a program to solve it.
Suppose you paint the walls of rooms in one color and the ceiling in another, and
you want to calculate the size of the areas to cover with paint.
For simplicity ignore doors.
What data do you need to start with?  Clearly the dimensions of the room.
Suppose we consider modern houses where the height of the room is predictably 8 feet,
so the new starting data is just the length and width of the room.

\sphinxAtStartPar
You need to
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Obtain the length and width from the user.

\item {} 
\sphinxAtStartPar
Calculate the wall area and ceiling area.

\item {} 
\sphinxAtStartPar
Let the user know the results.

\end{enumerate}

\sphinxAtStartPar
This is a very simple programming pattern:  data in, calculate results,
output results.  In this case the calculations in the middle are very easy.

\sphinxAtStartPar
In the examples that you should have downloaded is a first simple program,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/painting/painting.cs}{painting/painting.cs}.

\sphinxAtStartPar
Here is what it looks like when it runs, with the user typing the 20.5 and the 10:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Calculation of Room Paint Requirements
Enter room length: 20.5
Enter room width: 10
The wall area is 488 square feet.
The ceiling area is 205 square feet.
\end{sphinxVerbatim}

\sphinxAtStartPar
This is not very exciting, but it is a simple place to start seeing
basic program features.  We will refer back to this sample run while
discussing the program.
Here is the text of the program:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Painting}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wallArea}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ceilingArea}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{widthString}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{lengthString}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{HEIGHT}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}

\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Calculation of Room Paint Requirements\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter room length: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{lengthString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{lengthString}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter room width: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{widthString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{widthString}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{n}{wallArea}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{length}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{HEIGHT}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ignore doors}
\PYG{+w}{      }\PYG{n}{ceilingArea}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{;}

\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The wall area is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{wallArea}
\PYG{+w}{                        }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} square feet.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The ceiling area is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{ceilingArea}
\PYG{+w}{                        }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} square feet.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This section gives an overview of a working
program, even if all the explanations do not make total sense yet.
This is a first introduction of concepts and syntax that gets fully explained
in further sections.

\sphinxAtStartPar
Do not worry if you not totally understand the
explanations! Try to get the gist now and the details later.

\sphinxAtStartPar
The different colors are used in modern program editors to
emphasize the different uses of the parts of the program.

\sphinxAtStartPar
We give a line by line explanation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The C\# environment supplies an enormous number of parts that you can
reference.
Nobody is familiar with all of them.
If you had to make sure you always used names that did not conflict with other
names supplied, you would be in trouble.  To avoid this C\# has \sphinxstyleemphasis{namespaces}.  The
same name can be used in different namespaces without conflict.  The central
standard namespace is \sphinxcode{\sphinxupquote{System}}.  We will always include this first line,
\sphinxcode{\sphinxupquote{using System;}}.

\sphinxAtStartPar
Lines 2, 10, 18, and 21 are blank.
This is merely for the human reader to separate sections visually.  The computer
ignores them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Painting}
\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A basic unit in C\# is a \sphinxstyleemphasis{class}.  Our code sits inside a class.  Each class
has a \sphinxstyleemphasis{heading} with \sphinxcode{\sphinxupquote{class}} followed by a name.
This class is \sphinxcode{\sphinxupquote{Painting}}.  After the heading comes
a \sphinxstyleemphasis{body} delimited by braces.  The opening brace \sphinxcode{\sphinxupquote{\{}} in line 4, is matched
by the closing brace \sphinxcode{\sphinxupquote{\}}} on the last line of the program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A class is broken up with chunks called \sphinxstyleemphasis{functions} or \sphinxstyleemphasis{methods}.  Each has
a \sphinxstyleemphasis{heading}.  C\# allows the currently popular programming paradigm called
\sphinxstyleemphasis{object\sphinxhyphen{}oriented programming}, where classes generally
describe new kinds of objects.
This is useful in complicated situations,
but we start more simply with the older \sphinxstyleemphasis{procedural} programming.
Unfortunately for now,
the more common situation is with objects, so a function that does \sphinxstyleemphasis{not}
involve such new objects must be marked specially as \sphinxcode{\sphinxupquote{static}}.

\sphinxAtStartPar
Functions can be like in math, where they produce a function value
for later use.  In C\# they can
also just \sphinxstyleemphasis{do} something (like write to the screen), and not produce a value
for later use in the program.
To show that
no function value is produced, the word \sphinxcode{\sphinxupquote{void}} is used.

\sphinxAtStartPar
Every program must start running somewhere.  In C\# that is at a function with
name \sphinxcode{\sphinxupquote{Main}}.  So our program starts running here.
This syntax for this function needs to start just like here, with
\sphinxcode{\sphinxupquote{static void Main}}.

\sphinxAtStartPar
Even though this is not a mathematical function producing a value, a function in
C\# must be followed by parentheses \sphinxcode{\sphinxupquote{( )}}.

\sphinxAtStartPar
After the function heading comes a \sphinxstyleemphasis{body}.  Like with a class, a function body
is delimited by braces.  The opening brace here is matched by the closing
brace on the second to last line of the program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wallArea}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ceilingArea}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A program works with data of many different possible types.  One type
is \sphinxcode{\sphinxupquote{double}}.  A \sphinxcode{\sphinxupquote{double}} can hold an approximate numerical value,
including a possible fractional part.

\sphinxAtStartPar
To refer to data in a program we use names called \sphinxstyleemphasis{variables}.
This line says that
\sphinxcode{\sphinxupquote{width}}, \sphinxcode{\sphinxupquote{length}}, \sphinxcode{\sphinxupquote{wallArea}}, and \sphinxcode{\sphinxupquote{ceilingArea}} are all
the names for variables that can hold a \sphinxcode{\sphinxupquote{double}} value.  We will assign
values to these variables later.

\sphinxAtStartPar
This line is a \sphinxstyleemphasis{declaration} statement.
Most statements in C\#, like this one, end with \sphinxcode{\sphinxupquote{;}} \sphinxhyphen{} a semicolon.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{widthString}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{lengthString}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is another declaration.  This time the type of the variables is
\sphinxcode{\sphinxupquote{string}}, which means a sequence of characters, like a line you
might type at the keyboard.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{HEIGHT}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is another declaration for a \sphinxcode{\sphinxupquote{double}}, looking slightly different.
In this case we follow a convention, using all capital letters, to
suggest that the value of \sphinxcode{\sphinxupquote{HEIGHT}} will be constant (unchanging),
and we assign its value at the same time with \sphinxcode{\sphinxupquote{= 8}}.  This naming of
constants is not
strictly necessary, but it makes the program’s intention easier to follow.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Calculation of Room Paint Requirements\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Console}} refers to the terminal or console window where text output
appears for the program.  One of the things you can do with the Console
is \sphinxcode{\sphinxupquote{WriteLine}}, to write a line.  The period between \sphinxcode{\sphinxupquote{Console}} and
\sphinxcode{\sphinxupquote{WriteLine}} indicates \sphinxcode{\sphinxupquote{WriteLine}} is a named part of the \sphinxcode{\sphinxupquote{Console}}.
This \sphinxcode{\sphinxupquote{WriteLine}} is a function.  Like in math, it can have
a parameter in parentheses.  While you are used to a parameter for a
function in math being a number, functions in C\# are much more general.
A function can be defined with any type of parameters.
Here the parameter is a string,
\sphinxcode{\sphinxupquote{"Calculation of Room Paint Requirements"}},
delimited by the quotes at either end.  Notice that the contents
of this string appear at the start of the screen output
displayed for this program.  The program did \sphinxstylestrong{write} this \sphinxstylestrong{line}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter room length: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This statement is similar to the last one, except that it uses \sphinxcode{\sphinxupquote{Write}}
rather than \sphinxcode{\sphinxupquote{WriteLine}}.  The \sphinxcode{\sphinxupquote{WriteLine}} function wrote a whole line \sphinxhyphen{}
see that the output next \sphinxstyleemphasis{after} the \sphinxcode{\sphinxupquote{WriteLine}} statement
started on the next line.
Here \sphinxcode{\sphinxupquote{Write}} does not advance the printing position to the next line
after it.

\sphinxAtStartPar
This statement serves as a \sphinxstyleemphasis{prompt}: letting the user know that information is being
requested (a room length).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lengthString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is where the program takes in the information requested from the user.
Its action is actually right to left:  \sphinxcode{\sphinxupquote{Console.ReadLine}} is another
function available with the \sphinxcode{\sphinxupquote{Console}}, that reads a line typed in by the
user on the keyboard.  Here in the sample run,
on the same line as the prompt string
(because of the previous \sphinxcode{\sphinxupquote{Write}}, not \sphinxcode{\sphinxupquote{WriteLine}}),
the user types
\sphinxcode{\sphinxupquote{20.5}} and the Enter or Return key.

\sphinxAtStartPar
In the sample run,
the value produced by the \sphinxcode{\sphinxupquote{Console.ReadLine}} function is these four
characters \sphinxcode{\sphinxupquote{20.5}}.

\sphinxAtStartPar
Recall that \sphinxcode{\sphinxupquote{lengthString}} was declared as a variable to hold a string.
The  \sphinxcode{\sphinxupquote{=}} indicates an \sphinxstyleemphasis{assignment statement}.
It is an \sphinxstyleemphasis{assignment} of the value on the right of the equal sign
to be the current value of the variable on the left
of the equal sign.  In the sample run, this would mean that the variable
\sphinxcode{\sphinxupquote{lengthString}} would end up holding the value \sphinxcode{\sphinxupquote{"20.5"}}.  Though these
characters happen  to look like a number,
any sequence of characters can be typed.
The \sphinxcode{\sphinxupquote{Console.ReadLine()}} function produces this sequence of characters
as a \sphinxstyleemphasis{string} type.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{lengthString}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course we want to interpret the user’s input as a number in order to do
our arithmetic.  This line makes the conversion between the types.

\sphinxAtStartPar
It is another assignment statement (with the \sphinxcode{\sphinxupquote{=}}).  We are assigning to
the variable \sphinxcode{\sphinxupquote{length}}, which we declared as a \sphinxcode{\sphinxupquote{double}}.
The value assigned comes from the
expression on the right of the \sphinxcode{\sphinxupquote{=}}, \sphinxcode{\sphinxupquote{double.Parse(lengthString)}}.
The function \sphinxcode{\sphinxupquote{double.Parse}}, is just the one we want, it takes a string parameter
\sphinxcode{\sphinxupquote{lengthString}} containing the string from the user input,
and the value produced is the corresponding \sphinxcode{\sphinxupquote{double}} number.  In
the sample run that assigns to \sphinxcode{\sphinxupquote{length}} the value 20.5.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter room width: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{widthString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{widthString}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
These lines are analogous to the previous three lines:
give a prompt for the user;
get the user response; convert it to a \sphinxcode{\sphinxupquote{double}}, and assign to a variable
(\sphinxcode{\sphinxupquote{width}} in this case).  In the sample run the variable \sphinxcode{\sphinxupquote{width}} is assigned
the value 10.

\index{comment@\spxentry{comment}}\index{// comment@\spxentry{// comment}}\ignorespaces 
\sphinxAtStartPar
At this point we have all the data we need from the user.  The next part is
the brief calculations of results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{wallArea}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{length}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{HEIGHT}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ignore doors}
\PYG{n}{ceilingArea}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
At the end of the first line is a \sphinxstyleemphasis{comment}.  It starts with \sphinxcode{\sphinxupquote{//}} and ends
at the end of the same line.  It is ignored by the compiler.  It is there for humans,
hopefully to add something that helps understanding of the program.

\sphinxAtStartPar
We have two assignment statements.  The values to assign are given by arithmetic
expressions on the right side of the equal signs.  It looks pretty much like
regular math, except in math class you may be used to only having one letter names
for variables, unlike \sphinxcode{\sphinxupquote{length}}, \sphinxcode{\sphinxupquote{width}}, and \sphinxcode{\sphinxupquote{HEIGHT}}.

\sphinxAtStartPar
The tradeoff for allowing multiple character names is that multiplication must
have an explicit operation symbol.
The symbol used for multiplication in C\# is \sphinxcode{\sphinxupquote{*}} an asterisk.  The \sphinxcode{\sphinxupquote{+}}
and parentheses serve their normal mathematical purpose.  In the sample run,
the value of \sphinxcode{\sphinxupquote{2 * (length + width) * HEIGHT}} is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2 * (20.5 + 10) * 8
\end{sphinxVerbatim}

\sphinxAtStartPar
which simplifies to 488.

\sphinxAtStartPar
With the sample run, \sphinxcode{\sphinxupquote{ceilingArea}} would get the value 20.5 * 10, or 205.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The wall area is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{wallArea}
\PYG{+w}{                  }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} square feet.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a single statement.  Line endings act just like a space in C\#.
The statement ends with the semicolon on the second line.

\sphinxAtStartPar
Again \sphinxcode{\sphinxupquote{Console.WriteLine}} will print something to the computer console.  This
time the string printed is more complicated:  It starts off with
the literal string \sphinxcode{\sphinxupquote{"The wall area is "}}, but then we want to print out
the calculated result.  The \sphinxcode{\sphinxupquote{+ wallArea}} allows that.  The \sphinxcode{\sphinxupquote{+}} sign
after the string is not a mathematical operator here.  Coming after a string,
it has a special string meaning:  It converts the next part
\sphinxcode{\sphinxupquote{wallArea}} to be a string.  In the sample run that would be converting the
\sphinxcode{\sphinxupquote{double}} value 488 to be the string \sphinxcode{\sphinxupquote{"488"}}.  The plus sign then “adds” the strings
in a manner appropriate for strings, \sphinxstyleemphasis{concatenating} them.  That means joining
them together, end to end.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{+ " square feet."}} then tacks on the last part to the string.
In the sample output you see what is printed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The wall area is 488 square feet.
\end{sphinxVerbatim}

\sphinxAtStartPar
sandwiching the value taken from the variable \sphinxcode{\sphinxupquote{wallArea}} between
two literal string, given in quotes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The ceiling area is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{ceilingArea}
\PYG{+w}{                  }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} square feet.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This statement behave like the previous one, except with different
quoted strings and the value of a different variable.  See the sample output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally we have the matching closing braces marking the end of the body of the
\sphinxcode{\sphinxupquote{Main}} function and the end of the body of the \sphinxcode{\sphinxupquote{Painting}} class.

\sphinxAtStartPar
Of course the display would look different if the user entered different data.
Here is what is displayed when the user enters length 15 and width 6.5:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Calculation of Room Paint Requirements
Enter room length: 15
Enter room width: 6.5
The wall area is 344 square feet.
The ceiling area is 97.5 square feet.
\end{sphinxVerbatim}

\index{whitespace@\spxentry{whitespace}}\ignorespaces 
\sphinxAtStartPar
The blank space in the program was there to aid human understanding.
In a C\# program \sphinxstyleemphasis{whitespace} is any consecutive combination of spaces,
newlines, and tabs.  C\# treats any amount of whitespace
just the same as a single space, except inside quoted strings,
where every character is important.

\sphinxAtStartPar
Also the compiler does not require whitespace around special symbols
like \sphinxcode{\sphinxupquote{\{\};().=*+,}}.  Hence
the \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/painting/painting.cs}{painting/painting.cs} program above would be just as well translated
by the compiler if it were written as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
using System;class Painting\PYGZob{}static void Main()\PYGZob{}double width,length
,wallArea,ceilingArea;string widthString,lengthString;double HEIGHT
=8;Console.WriteLine(\PYGZdq{}Calculation of Room Paint Requirements\PYGZdq{});Console.
Write(\PYGZdq{}Enter room length: \PYGZdq{});lengthString=Console.ReadLine();length=
double.Parse(lengthString);Console.Write(\PYGZdq{}Enter room width: \PYGZdq{});
widthString=Console.ReadLine();width=double.Parse(widthString);wallArea
=2*(length+width)*HEIGHT;ceilingArea=length*width;Console.WriteLine(
        \PYGZdq{}The wall area is \PYGZdq{}                  +                 wallArea
+\PYGZdq{} square feet.\PYGZdq{});Console.WriteLine
      (\PYGZdq{}The ceiling area is \PYGZdq{}
               +ceilingArea+
\PYGZdq{} square feet.\PYGZdq{});\PYGZcb{}\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since human understanding is very important, we will emphasize good
whitespace conventions, and expect you to use them.

\sphinxAtStartPar
Next we give you an even simpler program to run in the lab.  After
that we return to how you can get the painting program to run on your computer.

\sphinxstepscope

\index{Xamarin Studio@\spxentry{Xamarin Studio}}\index{labs@\spxentry{labs}!Xamarin Studio@\spxentry{Xamarin Studio}}\ignorespaces 

\section{Lab: Editing, Compiling, and Running with Xamarin Studio}
\label{\detokenize{data/lab-edit-compile-run:lab-editing-compiling-and-running-with-xamarin-studio}}\label{\detokenize{data/lab-edit-compile-run:lab-edit-compile-run}}\label{\detokenize{data/lab-edit-compile-run:index-0}}\label{\detokenize{data/lab-edit-compile-run::doc}}
\sphinxAtStartPar
This first lab is aimed at taking you through the end\sphinxhyphen{}to\sphinxhyphen{}end process of
writing and running a basic computer program with the Xamarin Studio
environment. As with all things in
life, we will learn in this lab that becoming a programmer requires you
to learn a number of other things along the way.

\sphinxAtStartPar
In software development/engineering parlance, we typically describe a
scenario as a \sphinxstyleemphasis{workflow}, which can be thought of as a series of steps
that are possibly repeated. The workflow of programming can loosely be
defined as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use a text editor to write your source code (human readable).

\item {} 
\sphinxAtStartPar
Compile your code using the Software Development Kit (SDK) into
object code.

\item {} 
\sphinxAtStartPar
Link your object code to create an executable. (There are other
kinds of results to produce, but we will start with the idea of an
executable program to keep things simple.)  The default is to have
an executable program created with compilation, automatically.

\item {} 
\sphinxAtStartPar
Run your program. Even for the most seasoned developers, your
program may not work entirely right the first time, so you may end
up repeating these steps (debugging).

\end{enumerate}

\sphinxAtStartPar
These steps can all be done with different tools.  Many find it simpler to have
an integrated tool, like Xamarin Studio, that does them all in the same place,
and automates the steps that do not need human interaction!

\sphinxAtStartPar
If you are doing this on your own
machine, make sure you have Mono and Xamarin Studio installed as in
{\hyperref[\detokenize{appendix/monotools:development-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{Development Tools}}}}.

\sphinxAtStartPar
Other tools are available, like
the development environment
Visual Studio (from Microsoft, focused on Windows).

\sphinxAtStartPar
Understanding the lower level tools that accomplish each step is important,
but we defer
a discussion to get you going with Xamarin Studio.


\subsection{Goals}
\label{\detokenize{data/lab-edit-compile-run:goals}}
\sphinxAtStartPar
Our primary goal to create and understand an Xamarin Studio setup
that you can use to do all of
the remaining homework assignments and labs for this course.


\subsection{Steps}
\label{\detokenize{data/lab-edit-compile-run:steps}}\label{\detokenize{data/lab-edit-compile-run:id1}}
\sphinxAtStartPar
Xamarin Studio files and interactions
are organized hierarchically.  At a low level are
individual C\# source code files.  One, or possibly more, are used for a
particular \sphinxstyleemphasis{project}.  Multiple projects are gathered together under a single
\sphinxstyleemphasis{solution}.  Xamarin Studio deals with one solution at a time, though you can
separately create multiple solutions.  The simplest thing is to create
a \sphinxstyleemphasis{single solution for this course},
and put each of the projects that you create in that one solution.
You can keep adding onto previous efforts without having to start over
with a new solution each time.

\sphinxAtStartPar
We start by creating a \sphinxstyleemphasis{solution} with a \sphinxstyleemphasis{project} in it.  The images are from
a Mac.  Windows versions should be similar.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open Xamarin Studio, in the appropriate way for an application in your
operating system.  It should be in the Start menu for Windows.
Using Spotlight is quick on a Mac.

\item {} 
\sphinxAtStartPar
You get a Welcome screen.  Toward the upper left corner is a link for
New Solution.  Click on it.  Alternately you can follow the path through the menus:
File \sphinxhyphen{}\textgreater{} New \sphinxhyphen{}\textgreater{} Solution…

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=150bp]{{newSolution}.png}\hspace*{\fill}}

\sphinxAtStartPar
You should get a popup New Project Window, with a banner.
“Choose a template for your new project”.  It may initially show the
wrong template choice, like in the left column shown here:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=110bp]{{newProjectTemplateApp}.png}\hspace*{\fill}}

\sphinxAtStartPar
Make sure the template selection gets set to .NET (under Other) as in:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{newProjectTemplateNet}.png}\hspace*{\fill}}

\sphinxAtStartPar
The center part of the screen then shows further choices appropriate to
a .NET project.  Make sure \sphinxstylestrong{Console Project} is selected, and the language
shown in the highlighted line should be set to C\#.

\sphinxAtStartPar
Then click Next.

\item {} 
\sphinxAtStartPar
The banner on the next form is “Configure your new project”. The
image shows the initial state for the author:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{configureProjectForm}.png}\hspace*{\fill}}

\sphinxAtStartPar
Follow the order below to modify the form.
Later parts may not be visible until you do the previous parts.  The
image shows the final form as filled out by Dr. Harrington.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=360bp]{{configureCreate}.png}\hspace*{\fill}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Enter \sphinxstylestrong{hello} in the Project Name field, for the name of the project.

\item {} 
\sphinxAtStartPar
If you want to keep all your work together, we suggest that you
change the name of the solution from the copied “hello” and
enter any name you like:  We recommend \sphinxstylestrong{work}, which will make
sense for all your work for the course.

\item {} 
\sphinxAtStartPar
On \sphinxstyleemphasis{your} computer the Location field should start off showing a
Projects folder under \sphinxstyleemphasis{your} home folder,
(not the author’s home folder as in the image).  You can leave
it as is or change it if you like.

\item {} 
\sphinxAtStartPar
Make sure \sphinxstyleemphasis{Create a project within the solution directory} is checked
in the box under the Location.

\item {} 
\sphinxAtStartPar
You may skip version control for now, though it is very handy.

\item {} 
\sphinxAtStartPar
After the three fields are filled in, the Create button in the lower right
should become active.  After checking your entires, click on Create.

\end{itemize}

\sphinxAtStartPar
You now have created a solution in Xamarin Studio, with one project
inside it. Later we can add further \sphinxstyleemphasis{projects} to \sphinxstyleemphasis{this solution}.

\item {} 
\sphinxAtStartPar
Look at the Xamarin Studio window that appears.  It should have two main sub\sphinxhyphen{}windows or
“Pads” as Xamarin Studio calls them.  A narrow one on the left is the Solution Pad,
containing a hierarchical view of the solution.  If you somehow close a pad,
you can recover it going to the main Xamarin menu: View =\textgreater{} Pads =\textgreater{} Solution.

\sphinxAtStartPar
In the Solution Pad you should see your solution name
at the top and the hello project under that.
Folders have a little triangle shown to their
left.  You can click on the triangle.  A triangle pointing down
means the inside of the folder is displayed.  A triangle pointing to the right
means the contents are not being displayed. Listed under hello are References,
Packages and
Properties, that we will ignore for now.  Below them is the line for the automatically
generated sample code file Program.cs.
The file should also appear in the Edit Pad to the right.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300bp]{{Program}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
Program.cs should be selected in the Solution Pad, as shown above.
Change the selection by clicking on hello.

\sphinxAtStartPar
UPDATE: The pictures show an icon at the right side of a selected project line
in the Solution pad.  This appears to have disappeared in the latest version.
To get the context sensitive popup window for such a line, you can right\sphinxhyphen{}click on
Windows or control\sphinxhyphen{}click on a Mac. Ignore later references to this now missing icon
and remember the new approach.
Other items in the Solution Pad will also have a context sensitive menu accessed by
right\sphinxhyphen{}clicjk or control\sphinxhyphen{}click.

\item {} 
\sphinxAtStartPar
Bring up the context menu on the hello project in the Solution Pad.
Select Run Item.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250bp]{{runMainMenu}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
Here Xamarin Studio combines several steps: saving the file,
compiling it into an executable program,
and starting running it if compilation succeeded.
With the canned file it should succeed!  You see a Console window
something like

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=283.5bp]{{pressKey}.png}\hspace*{\fill}}

\sphinxAtStartPar
Here you see the output of this simple program.
On Windows you can follow the instructions and press the space or Enter key.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This console window must be closed before you can run a program again.
If you go to run a program and the Run Item line is grayed out,
look for the unclosed terminal window you still have!
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
On Microsoft Windows, pressing spacebar or Enter kills the window.
\sphinxstylestrong{On a Mac only, this makes the window gets two more lines, but still be visible:}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=198.75bp]{{processComplete}.png}\hspace*{\fill}}

\sphinxAtStartPar
You have to actively close the Mac terminal window by clicking the
red window closing button, or using the keyboard, with Command\sphinxhyphen{}W.  You
can either do that now, or replace the previous spacebar/Enter
step with this action.

\item {} 
\sphinxAtStartPar
This one time it is convenient to get the immediate practice of running
this automatically generated program
file, \sphinxcode{\sphinxupquote{Program.cs}}.  Hereafter this file is an annoyance.
The file name and contents are always the same, and not useful.
You would need to redo the whole
code for your own program.  A general approach for all your projects
is to \sphinxstyleemphasis{delete} this
file and put in a file of your own:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Make sure Program.cs is selected in the Solution Pad.
You save a step by closing the Edit Pad for Program.cs,
clicking on the X in the Program.cs tab at the top of the Edit Pad.

\item {} 
\sphinxAtStartPar
In the Solution Pad open the context sensitive menu for Program.cs, and select
Remove.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=200bp]{{menuRemoveMain}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
You get another popup, with the \sphinxstyleemphasis{wrong} (rightmost) button selected,
Remove From Project.
Instead select the \sphinxstyleemphasis{left} button, \sphinxstylestrong{Delete}, as in
the image below.
Otherwise the file is left in the hello
folder, but it is just not listed as being in the project.
Each project is associated with a folder, but not everything
in the folder may be cataloged by Xamarin as part of the project.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=360bp]{{sureRemove}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
If you forgot to close the Edit Pad tab containing Program.cs earlier,
you can still do it \textendash{} just say not to save changes to the file when asked.

\end{itemize}

\item {} 
\sphinxAtStartPar
To get in code that you want, there are several approaches.  The one we take
now is to start from a completely
new empty file:  Pop up the context sensitive menu for the hello project.
Select the submenu Add…  and  then New File….

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=340bp]{{addNewFileMenu}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
In the popup New File Dialog Window, it is likely that the wrong kind of file is
highlighted (likely Empty Class).

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{makeEmptyFileDialog}.png}\hspace*{\fill}}

\sphinxAtStartPar
Click on \sphinxstylestrong{Empty File} instead.
Change the Name field from EmptyCSharpFile to hello.cs.
Always remember the “.cs”.
Click the New button.

\item {} 
\sphinxAtStartPar
This should add hello.cs to the hello project and open an editing window for hello.cs.
The file should have no text.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=180bp]{{editEmptyHello}.png}\hspace*{\fill}}

\sphinxAtStartPar
If it does have text, delete this file, too, and
go back to the previous step and be sure to select \sphinxstylestrong{Empty File}, not Empty Class.

\sphinxAtStartPar
Much like in most word processors type in (or paste)
the following code.  This is actually an equivalent
\sphinxstyleemphasis{Hello, World!} program to the automatically generated one,
but it is a bit shorter.
It only introduces the syntax we actually \sphinxstyleemphasis{need} at the beginning,
and will be discussing more shortly.  The automatically generate line numbers
are not a part of the text:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Hello}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Hello World!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This program is deliberately simple, so you can type it into the text
editor quickly and become familiar with how
to create, edit, and save a program.  Here is how it looks pasted or typed
into the editor pad:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=230bp]{{pasteHello}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
You can run the project just as before.  You should ge the same result, unless
you made a typing error.  In that case look for what does not match,
fix it, and try again.  Remember to close the
execution Console Window.

\item {} 
\sphinxAtStartPar
Now try a bit of editing:  Look at the program to see where output came
from.  Change what is printed and run it, but don’t eliminate the
output console
window for now (so you can show it off).

\item {} 
\sphinxAtStartPar
Now grab the instructor or teaching assistant so
they can perform a quick inspection of your work and check it off
(including the varied message printed).

\end{enumerate}

\sphinxAtStartPar
Labs need to be completed to receive
credit. If you are unable to make class on a lab day, please make sure
that you complete the work and demonstrate it by the beginning of the
next lab.

\sphinxAtStartPar
At this point, you have accomplished the major objective for this
introductory lab: to create a Xamarin Studio project, and
enter, compile, and run a C\# program.


\subsubsection{For further reinforcement}
\label{\detokenize{data/lab-edit-compile-run:for-further-reinforcement}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Can you make a new program variant print out two \sphinxstyleemphasis{separate} lines?
This is possible with an added statement.  It is also possible
changing one statement, but not adding an additional statement.

\item {} 
\sphinxAtStartPar
Download and install Mono Software Development Kit and Xamarin Studio on
your home computer or laptop.

\item {} 
\sphinxAtStartPar
You can now add further projects to your \sphinxstyleemphasis{current} solution.
To add a new project in your solution, in the Solution Pad open the context
sensitive menu for the whole solution (top line), select Add,
and in the submenu select New project, and you go to the Project Template form.
It should remember your last settings, but do check:  Later we will
sometimes want a Library instead of a Console project.

\sphinxAtStartPar
Complete the remaining parts in the same
way as before, giving a new name for the project.

\end{enumerate}

\sphinxstepscope

\index{arithmetic@\spxentry{arithmetic}}\ignorespaces 

\section{Arithmetic}
\label{\detokenize{data/arithmetic:arithmetic}}\label{\detokenize{data/arithmetic:index-0}}\label{\detokenize{data/arithmetic:id1}}\label{\detokenize{data/arithmetic::doc}}
\sphinxAtStartPar
We start with the integers and integer arithmetic, not because
arithmetic is exciting, but because the symbolism should be mostly
familiar. Of course arithmetic is important in many cases, but
C\# is often used to manipulate text and other
sorts of data.

\index{csharp@\spxentry{csharp}}\ignorespaces 

\subsection{Csharp}
\label{\detokenize{data/arithmetic:csharp}}\label{\detokenize{data/arithmetic:index-1}}\label{\detokenize{data/arithmetic:id2}}
\sphinxAtStartPar
Of course we could write programs to demonstrate arithmetic,
but there is a fair amount of overhead with a full program.
For just testing little bits, there is another alternative:
The Mono system comes with a program \sphinxstyleemphasis{csharp}.  Let us
try it out.

\sphinxAtStartPar
Open a terminal (Linux or OS X) or {\hyperref[\detokenize{appendix/monotools:mono-command-prompt}]{\sphinxcrossref{\DUrole{std,std-ref}{Mono Command Prompt}}}}
window in Windows, and enter the command \sphinxcode{\sphinxupquote{csharp}}.  You should see  :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mono C\PYGZsh{} Shell, type \PYGZdq{}help;\PYGZdq{} for help

Enter statements below.
csharp\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{csharp\textgreater{}}} prompt tells you that the C\# interpreter has started
and is awaiting input. This allows you to create small bits of C\#
and test them, interactively, without having to write a full program!

\index{operator@\spxentry{operator}!+ with numbers@\spxentry{+ with numbers}}\index{+@\spxentry{+}!with numbers@\spxentry{with numbers}}\ignorespaces 
\sphinxAtStartPar
Play along with the examples here, entering what comes after the prompt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 2 + 3
5
\end{sphinxVerbatim}

\sphinxAtStartPar
The csharp program just has a \sphinxstyleemphasis{read, evaluate, and print loop}: the acronym is
\sphinxstyleemphasis{repl}.  It evaluated the expression \sphinxcode{\sphinxupquote{2 + 3}} and printed the result,
on a line without a prompt.
Csharp can evaluate arbitrary C\# expressions.  It is very handy for
testing as you get used to new syntax.

\index{operator@\spxentry{operator}!\sphinxhyphen{}@\spxentry{\sphinxhyphen{}}}\index{\sphinxhyphen{}@\spxentry{\sphinxhyphen{}}!subtraction@\spxentry{subtraction}}\ignorespaces 
\sphinxAtStartPar
Subtraction works as you would expect.
Blanks are optional around symbols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 10 \PYGZhy{} 3
7
\end{sphinxVerbatim}

\sphinxAtStartPar
For the binary arithmetic operators,
you are encouraged to add blanks to make the expression
more easily readable by humans.

\sphinxAtStartPar
The csharp program is more line\sphinxhyphen{}oriented than the C\# language.
If you press the return key when what you have entered is a complete expression
you see the value as a response.
If your expression is clearly incomplete you get another \sphinxcode{\sphinxupquote{\textgreater{}}} prompt (with no
“csharp”), until you have entered enough for a full expression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 10\PYGZhy{}
      \PYGZgt{} 3
7
\end{sphinxVerbatim}

\index{operator@\spxentry{operator}!*@\spxentry{*}}\index{* multiplication@\spxentry{* multiplication}}\ignorespaces 
\sphinxAtStartPar
In math class you could enter something like 4(10) for multiplication:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 4(10)
\PYGZob{}interactive\PYGZcb{}(1,2): error CS0119: Expression denotes a \PYGZsq{}value\PYGZsq{},
where a \PYGZsq{}method group\PYGZsq{} was expected
\end{sphinxVerbatim}

\sphinxAtStartPar
Unfortunately the error messages are not always easy to follow:
it is hard to guess the
intention of the user making a mistake.

\sphinxAtStartPar
The issue here is that the multiplication operator must be \sphinxstyleemphasis{explicit} in
C\#.  Recall that an asterisk is used as a multiplication operator:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 4 * 10
40
\end{sphinxVerbatim}

\index{( )@\spxentry{( )}!grouping@\spxentry{grouping}}\index{grouping ( )@\spxentry{grouping}\spxextra{ }}\index{\sphinxhyphen{}@\spxentry{\sphinxhyphen{}}!negation@\spxentry{negation}}\ignorespaces 
\sphinxAtStartPar
Enter each of the following expressions into csharp, and think what they
will produce (and then check):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2*5
2 + 3 * 4
\end{sphinxVerbatim}

\sphinxAtStartPar
If you expected the last answer to be 20, think again: C\# uses
the normal \sphinxstyleemphasis{precedence} of arithmetic operations: Multiplications
divisions, and negations are done before addition and subtraction, unless
there are parentheses forcing the order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} \PYGZhy{}(2+3)*4
\PYGZhy{}20
\end{sphinxVerbatim}

\sphinxAtStartPar
A sequence of operations with equal precedence also work like in math:
left to right in most cases, like for combinations of addition and subtraction:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 10 \PYGZhy{} 3 + 2
9
\end{sphinxVerbatim}

\index{remainder \%@\spxentry{remainder \%}}\index{\% remainder@\spxentry{\% remainder}}\index{operator@\spxentry{operator}!/, \%@\spxentry{/, \%}}\index{division@\spxentry{division}}\index{/@\spxentry{/}!division@\spxentry{division}}\index{.@\spxentry{.}!double literal@\spxentry{double literal}}\index{double@\spxentry{double}}\index{int@\spxentry{int}}\index{type@\spxentry{type}!int@\spxentry{int}}\index{type@\spxentry{type}!double@\spxentry{double}}\ignorespaces 

\subsection{Division and Remainders}
\label{\detokenize{data/arithmetic:division-and-remainders}}\label{\detokenize{data/arithmetic:index-6}}\label{\detokenize{data/arithmetic:id3}}
\sphinxAtStartPar
We started with the almost direct translations from math.  Division is
more complicated.  We continue in the csharp program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 5.0/2.0;
2.5
csharp\PYGZgt{} 14.0/4.0;
3.5
\end{sphinxVerbatim}

\sphinxAtStartPar
So far so good.  Now consider:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 14/4
3
\end{sphinxVerbatim}

\sphinxAtStartPar
What?  Some explanation is in order.  All data has a \sphinxstyleemphasis{type} in C\#.
When you write an explicit number
without a decimal point, like 2, 17, or \sphinxhyphen{}237,
it is interpreted as the type of an integer, called \sphinxcode{\sphinxupquote{int}} for short.

\sphinxAtStartPar
When you include a decimal point, the type is \sphinxcode{\sphinxupquote{double}}, representing a more
general real number.  This is true even if the value of the number is an
integer like 5.0: the type is still \sphinxcode{\sphinxupquote{double}}.

\sphinxAtStartPar
Addition, subtraction, and multiplication work as you would expect for
\sphinxcode{\sphinxupquote{double}} values, too:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 0.5 * (2.0 + 4.5)
3.25
\end{sphinxVerbatim}

\sphinxAtStartPar
If one or both
of the operands to \sphinxcode{\sphinxupquote{/}} is a \sphinxcode{\sphinxupquote{double}}, the result is a \sphinxcode{\sphinxupquote{double}},
close to the actual quotient.
We say close,
because C\# stores
values with only a limited precision, so in fact results are
only approximate in general.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 1.0/3
0.333333333333333
\end{sphinxVerbatim}

\sphinxAtStartPar
Small errors are also possible with the \sphinxcode{\sphinxupquote{double}} type
and the other arithmetic operations.  See {\hyperref[\detokenize{data/types-and-conversions:type-double}]{\sphinxcrossref{\DUrole{std,std-ref}{Type double}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In C\#, the result of the / operator depends on the
\sphinxstyleemphasis{type} of the operands, not on the \sphinxstyleemphasis{mathematical value} of the operands.
\end{sphinxadmonition}

\sphinxAtStartPar
Division with \sphinxcode{\sphinxupquote{int}} data is handled completely differently.

\sphinxAtStartPar
If you think about it, you learned several ways to do division.
Eventually you learned how to do division resulting in a decimal.
In the earliest grades, however, you would say
\begin{quote}

\sphinxAtStartPar
“14 divided by 4 is 3 with a remainder of 2.”
\end{quote}

\sphinxAtStartPar
Note the quotient is an integer 3, that matches the C\# evaluation of 14/4,
so having a way to generate an integer quotient is not actually too strange.
The problem here is that the answer from grade school is in \sphinxstyleemphasis{two} parts,
the integer quotient 3 and the remainder 2.

\sphinxAtStartPar
C\# has a \sphinxstyleemphasis{separate} operation symbol to generate the remainder part.
There is no standard
single operator character operator for this in regular math,
so C\# grabs an unused symbol:
\sphinxcode{\sphinxupquote{\%}} is the remainder operator.
(This is the same as in many other computer languages.)

\sphinxAtStartPar
Try in the csharp shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 14 / 4
3
csharp\PYGZgt{} 14 \PYGZpc{} 4
2
\end{sphinxVerbatim}

\sphinxAtStartPar
You see that with the combination of the \sphinxcode{\sphinxupquote{/}} operator and the \sphinxcode{\sphinxupquote{\%}} operator,
you get both the quotient and the remainder from our grade school division.

\sphinxAtStartPar
Now predict and then try each of these expression in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
23/5
23\PYGZpc{}5
20\PYGZpc{}5
6/8
6\PYGZpc{}8
6.0/8
\end{sphinxVerbatim}

\sphinxAtStartPar
Finding remainders will prove more useful than you might think in
the future!  Remember the strange \sphinxcode{\sphinxupquote{\%}} operator.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The precedence of \sphinxcode{\sphinxupquote{\%}} is the same as \sphinxcode{\sphinxupquote{/}} and \sphinxcode{\sphinxupquote{*}}, and hence
higher than addition and subtraction, \sphinxcode{\sphinxupquote{+}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
When you are \sphinxstyleemphasis{done with csharp}, you can enter the special expression

\begin{sphinxVerbatim}[commandchars=\\\{\}]
quit
\end{sphinxVerbatim}

\sphinxAtStartPar
There are some more details about numeric types in {\hyperref[\detokenize{data/types-and-conversions:value-types}]{\sphinxcrossref{\DUrole{std,std-ref}{Value Types and Conversions}}}}.

\index{expression@\spxentry{expression}}\ignorespaces 
\sphinxAtStartPar
We have been testing arithmetic expressions, with the word
\sphinxstyleemphasis{expression} used pretty much like with normal math.  More generally in C\#
an \sphinxstyleemphasis{expression} is any syntax that evaluates to a single value of some type.
We will introduce many more types and operations that can be used in expressions.


\subsubsection{Divisible by 17 Exercise}
\label{\detokenize{data/arithmetic:divisible-by-17-exercise}}
\sphinxAtStartPar
What is a simple expression that lets you see if an int x is divisible by 17?


\subsubsection{Mixed Arithmetic Exercise}
\label{\detokenize{data/arithmetic:mixed-arithmetic-exercise}}
\sphinxAtStartPar
\sphinxstyleemphasis{Think} of the result of one of these at a time; write your prediction,
and \sphinxstyleemphasis{then} test, and write the correct answer afterward if you were wrong.
Then go on to the next….
For the ones you got wrong, can you explain the result after seeing it?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{1.5}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{7.0}\PYG{o}{/}\PYG{l+m}{2.0}
\PYG{l+m}{7.0}\PYG{o}{/}\PYG{l+m}{2}
\PYG{l+m}{7}\PYG{o}{/}\PYG{l+m}{2.0}
\PYG{l+m}{4.0}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{8}
\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{8}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{2.0}\PYG{o}{/}\PYG{l+m}{3}\PYG{p}{)}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{2}\PYG{o}{/}\PYG{l+m}{3}\PYG{p}{)}
\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{6}
\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{3}
\end{sphinxVerbatim}

\sphinxstepscope

\index{variable@\spxentry{variable}!assignment@\spxentry{assignment}}\index{assignment statement@\spxentry{assignment statement}}\index{statement@\spxentry{statement}!assignment@\spxentry{assignment}}\index{=@\spxentry{=}!assignment@\spxentry{assignment}}\ignorespaces 

\section{Variables and Assignment}
\label{\detokenize{data/variables:variables-and-assignment}}\label{\detokenize{data/variables:index-0}}\label{\detokenize{data/variables:id1}}\label{\detokenize{data/variables::doc}}
\sphinxAtStartPar
Each piece of data in a C\# program has a \sphinxstyleemphasis{type}.  Several types have been introduced:
\sphinxcode{\sphinxupquote{int}} for integers, \sphinxcode{\sphinxupquote{double}} for numbers allowing a fractional part,
approximating more general real numbers.
There are many other numeric types and also non\sphinxhyphen{}numeric types, but we can use \sphinxcode{\sphinxupquote{int}}
and \sphinxcode{\sphinxupquote{double}} for examples now.  Data gets stored in computer memory.  Specific
locations in memory are associated with the type of data stored there
and with a name to refer to it.

\sphinxAtStartPar
A program allocates a named storage spot for a particular type of data with a
\sphinxstyleemphasis{declaration statement}, like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each declaration must specify a type for the data to be stored and give a name to
refer to it.  These names associated with a data storage location are called
\sphinxstyleemphasis{variables}.

\sphinxAtStartPar
The declaration statement above sets aside a location to store an \sphinxcode{\sphinxupquote{int}}, and names
the location \sphinxcode{\sphinxupquote{width}}.  Several variables of the same type can be
listed together, like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
identifying three storage locations for variables of type \sphinxcode{\sphinxupquote{double}}.

\sphinxAtStartPar
To be useful, data needs to be stored in these locations.  This is done with
an \sphinxstyleemphasis{assignment statement}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A simple schematic diagram with a name for a location in memory (the box):

\noindent\sphinxincludegraphics[width=72bp]{{variableDeclaration}.png}

\sphinxAtStartPar
Although we are used to reading left to right, an assignment statement works
\sphinxstyleemphasis{right to left}.  The value on the right side of the equal sign is calculated
and then placed in the memory location associated with the variable on the left
side of the equal sign, either giving an initial value or
\sphinxstyleemphasis{overwriting} any previous value stored there.

\noindent\sphinxincludegraphics[width=72bp]{{variableAssignment}.png}

\index{initializer@\spxentry{initializer}}\index{=@\spxentry{=}!initializer@\spxentry{initializer}}\index{declaration initializer@\spxentry{declaration initializer}}\ignorespaces 
\sphinxAtStartPar
Variables can also be initialized as they are declared:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{12.5}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{27}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0.5}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or initializations and plain declarations can be mixed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{area}\PYG{p}{;}
\PYG{n}{height}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Stylistically the example above is inconsistent, but it illustrates what is
possible.  Technically an initialization is not an assignment.  We will see
some syntax that is legal in initializers, but not in assignment statements.

\sphinxAtStartPar
We could continue with a further assignment statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{area}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Look at this in detail.  The assignment statement starts by evaluating the
expression on the right\sphinxhyphen{}hand side: \sphinxcode{\sphinxupquote{width * height}}.  When variables are
used in an expression, their current values are substituted,
like in evaluating an expression in math, so the value is the same as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5 * 7
\end{sphinxVerbatim}

\sphinxAtStartPar
which finally evaluates to 35.  In the last step of the assignment statement,
the value 35 is then assigned to the variable on the left, \sphinxcode{\sphinxupquote{area}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
You want \sphinxstyleemphasis{one} spot in memory prepared for \sphinxstyleemphasis{each} variable.  This happens
with declaration, not assignment:  Assignment just changes the value
at the current location.  Do not \sphinxstyleemphasis{declare} the same variable more than once.
You will get an error.  More on the fine points around that in {\hyperref[\detokenize{functions/localscope:local-scope}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Scope}}}}.
\end{sphinxadmonition}

\index{csharp@\spxentry{csharp}}\ignorespaces \phantomsection\label{\detokenize{data/variables:more-csharp}}
\sphinxAtStartPar
We continue introducing {\hyperref[\detokenize{data/arithmetic:csharp}]{\sphinxcrossref{\DUrole{std,std-ref}{Csharp}}}}:
Remember that in csharp you can just give an expression,
and csharp responds with a value.  That syntax and reaction is special to
csharp.   In csharp you can also test regular C\# statements,
like declarations and assignments.  The most recent versions of csharp
do not require you to end a statement with a semicolon, though we tend to
put semicolons after statements in our illustrations (and no semicolon for just
an expression).
As in a regular program, statements
do not give an immediate visible response in csharp.  Still in
csharp you can display a variable value easily:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int width = 5, height, area;
csharp\PYGZgt{} height = 7;
csharp\PYGZgt{} area = width * height;
csharp\PYGZgt{} area
35
\end{sphinxVerbatim}

\sphinxAtStartPar
In the last line, \sphinxcode{\sphinxupquote{area}} is an expression, and csharp will give back its value,
which is just the current value of the variable.

\index{csharp@\spxentry{csharp}!help@\spxentry{help}}\index{csharp@\spxentry{csharp}!quit;@\spxentry{quit;}}\index{csharp@\spxentry{csharp}!ShowVars@\spxentry{ShowVars}}\ignorespaces 
\sphinxAtStartPar
At this point you should be able to make sense of some more features of csharp.
You can start with the csharp special help command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} help
\PYGZdq{}Static methods:
  Describe (object)       \PYGZhy{} Describes the object\PYGZsq{}s type
  LoadPackage (package);  \PYGZhy{} Loads the given Package (like \PYGZhy{}pkg:FILE)
  LoadAssembly (assembly) \PYGZhy{} Loads the given assembly (like \PYGZhy{}r:ASSEMBLY)
  ShowVars ();            \PYGZhy{} Shows defined local variables.
  ShowUsing ();           \PYGZhy{} Show active using declarations.
  Prompt                  \PYGZhy{} The prompt used by the C\PYGZsh{} shell
  ContinuationPrompt      \PYGZhy{} The prompt for partial input
  Time(() \PYGZhy{}\PYGZgt{} \PYGZob{} \PYGZcb{})         \PYGZhy{} Times the specified code
  print (obj)             \PYGZhy{} Shorthand for Console.WriteLine
  quit;                   \PYGZhy{} You\PYGZsq{}ll never believe it \PYGZhy{} this quits the repl!
  help;                   \PYGZhy{} This help text
  TabAtStartCompletes \PYGZhy{} Whether tab will complete even on empty lines
\end{sphinxVerbatim}

\sphinxAtStartPar
A lot of this is still beyond us but these parts are useful:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ShowVars ();            \PYGZhy{} Shows defined local variables.
quit;                   \PYGZhy{} You\PYGZsq{}ll never believe it \PYGZhy{} this quits the repl!
help;                   \PYGZhy{} This help text
\end{sphinxVerbatim}

\sphinxAtStartPar
We can continue the csharp session above and illustrate ShowVars():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} ShowVars();
int width = 5
int height = 7
int area = 35
\end{sphinxVerbatim}

\sphinxAtStartPar
displaying all the variables currently known to csharp, plus their current values.

\sphinxAtStartPar
We refer to “current values”.  An important distinction between variables in math
and variables in C\# is that C\# values can \sphinxstyleemphasis{change}.  Follow this csharp sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int n = 3;
csharp\PYGZgt{} n
3
csharp\PYGZgt{} n = 7;
csharp\PYGZgt{} n
7
\end{sphinxVerbatim}

\sphinxAtStartPar
showing we can change the value of a variable.  The most \sphinxstyleemphasis{recent} assignment is remembered
(until the next assignment….)  We can imagine a schematic diagram:

\noindent\sphinxincludegraphics[width=43.5bp]{{variableChange}.png}

\sphinxAtStartPar
We can carry this csharp session one step further,
illustrating a difference between C\# and math:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} n = n + 1;
csharp\PYGZgt{} n
8
\end{sphinxVerbatim}

\sphinxAtStartPar
Clearly \sphinxcode{\sphinxupquote{n = n + 1}} is not a true mathematical equation:  It \sphinxstyleemphasis{is} a C\# assignment,
executing with a
specific sequence of steps.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First the right hand side expression
is evaluated, \sphinxcode{\sphinxupquote{n + 1}}.

\item {} 
\sphinxAtStartPar
This involves looking up the current value of \sphinxcode{\sphinxupquote{n}},
which we set to 7, so the expression is the same as \sphinxcode{\sphinxupquote{7 + 1}} which is 8.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{After} this evaluation, an assignment is made to the left hand variable,
which happens to be \sphinxcode{\sphinxupquote{n}} again.

\item {} 
\sphinxAtStartPar
Then the \sphinxstyleemphasis{new} value of \sphinxcode{\sphinxupquote{n}} is 8, replacing the old 7.

\end{enumerate}

\sphinxAtStartPar
There are many occasions in which such an operation will be useful.

\sphinxAtStartPar
Assignment syntax does have two strikes against it:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
It appropriates math’s equal sign to mean something quite different.

\item {} 
\sphinxAtStartPar
The right to left operation is counter to the English reading direction.

\end{enumerate}

\sphinxAtStartPar
Still this usage is common to many programming languages.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Remember in an assignment that the sides of the equal sign have totally
different meanings.  You assign to a variable on the left side \sphinxstyleemphasis{after}
evaluating the expression on the right.
\end{sphinxadmonition}

\sphinxAtStartPar
We can illustrate a likely mistake in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} 3 = n;
\PYGZob{}interactive\PYGZcb{}(1,2): error CS0131: The left\PYGZhy{}hand side of an assignment
must be a variable, a property or an indexer
\end{sphinxVerbatim}

\sphinxAtStartPar
Students commonly try to assign left to right.  At least in this case you get
an error message so you see a mistake.  If you mean to assign the value of
x to y, and write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
you get the opposite effect, changing x rather than y, with \sphinxstyleemphasis{no} error statement.
Be careful!

\sphinxAtStartPar
There is some weirdness in csharp because it adds special syntax for expressions
which does not appear in regular programs, but it also wants to allow syntax
of regular programs.  Some conflict can occur when trying to display
an expression, sometimes leading to csharp giving
a strange error for apparently no reason.  In that case,
try putting \sphinxstyleemphasis{parentheses} around the expression, which is always legal for an
expression, but would never start a regular statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int width = 3;
csharp\PYGZgt{} int height = 5;
csharp\PYGZgt{} width * height
\PYGZob{}interactive\PYGZcb{}(1,2): error CS0246: The type or namespace name \PYGZsq{}width\PYGZsq{} could
not be found. Are you missing a using directive or an assembly reference?
csharp\PYGZgt{} (width * height)
15
\end{sphinxVerbatim}

\index{literal@\spxentry{literal}}\index{identifier@\spxentry{identifier}}\ignorespaces 

\subsection{Literals and Identifiers}
\label{\detokenize{data/variables:literals-and-identifiers}}\label{\detokenize{data/variables:index-4}}\label{\detokenize{data/variables:id2}}
\sphinxAtStartPar
Expressions like \sphinxcode{\sphinxupquote{27}} or \sphinxcode{\sphinxupquote{32.5}} or \sphinxcode{\sphinxupquote{"hello"}} are called \sphinxstyleemphasis{literals},
coming from the fact that they \sphinxstyleemphasis{literally} mean exactly what they
say. They are distinguished from variables, whose value the compiler \sphinxstyleemphasis{cannot} infer
directly from the name alone.

\sphinxAtStartPar
The sequence of characters used to form a variable name (and names
for other C\# entities later) is called an \sphinxstyleemphasis{identifier}. It
identifies a C\# variable or other entity.

\index{keyword@\spxentry{keyword}}\ignorespaces 
\sphinxAtStartPar
There are some restrictions on the character sequence that make up
an identifier:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The characters must all be letters, digits, or underscores \sphinxcode{\sphinxupquote{\_}},
and must start with a letter. In particular, punctuation and blanks
are not allowed.

\item {} 
\sphinxAtStartPar
There are some words that are \sphinxstyleemphasis{keywords} for special use in
C\#. You may not use these words as your own identifiers. They
are easy to recognize in editors like in Xamarin Studio,
that know about C\# syntax:  They are colored differently.

\end{itemize}

\sphinxAtStartPar
We will only discuss a small fraction of the keywords in this course, but the curious
may look at the
\sphinxhref{http://msdn.microsoft.com/en-us/library/x53a06bb.aspx}{full list}.

\index{case sensitive@\spxentry{case sensitive}}\ignorespaces 
\sphinxAtStartPar
C\# is case sensitive: The identifiers \sphinxcode{\sphinxupquote{last}}, \sphinxcode{\sphinxupquote{LAST}}, and
\sphinxcode{\sphinxupquote{LaSt}} are all different. Be sure to be consistent. The compiler
can usually catch these errors, since it is the version used in the \sphinxstyleemphasis{one}
declaration that matters.

\index{identifier@\spxentry{identifier}!multi\sphinxhyphen{}word naming convention@\spxentry{multi\sphinxhyphen{}word naming convention}}\index{camel case@\spxentry{camel case}}\ignorespaces 
\sphinxAtStartPar
What is legal is distinct from what is conventional or good
practice or recommended. Meaningful names for variables are
important for the humans who are looking at programs, understanding
them, and revising them. That sometimes means you would like to use
a name that is more than one word long, like \sphinxcode{\sphinxupquote{price at opening}},
but blanks are illegal! One poor option is just leaving out the
blanks, like \sphinxcode{\sphinxupquote{priceatopening}}. Then it may be hard to figure out
where words split. Two practical options are
\begin{itemize}
\item {} 
\sphinxAtStartPar
underscore separated: putting underscores (which are legal) in
place of the blanks, like \sphinxcode{\sphinxupquote{price\_at\_opening}}.

\item {} 
\sphinxAtStartPar
using \sphinxstyleemphasis{camel\sphinxhyphen{}case}: omitting spaces and using all lowercase,
except capitalizing all words after the first, like
\sphinxcode{\sphinxupquote{priceAtOpening}}

\end{itemize}

\sphinxAtStartPar
Use the choice that fits your taste (or the taste or convention of
the people you are working with).  We will tend to use
camel\sphinxhyphen{}case for variable inside programs, while we use underscores in
program file names (since different operating systems deal with case
differently).


\subsubsection{Assignment Exercise}
\label{\detokenize{data/variables:assignment-exercise}}
\sphinxAtStartPar
\sphinxstyleemphasis{Think} what the result would be in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{x}
\end{sphinxVerbatim}

\sphinxAtStartPar
Write your prediction.  Then test.  Can you explain it if you got it wrong?


\subsubsection{Another Assignment Exercise}
\label{\detokenize{data/variables:another-assignment-exercise}}
\sphinxAtStartPar
If you had trouble with the last, one try this one, too:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{n}{a}
\end{sphinxVerbatim}

\sphinxstepscope

\index{syntax template typography@\spxentry{syntax template typography}}\index{typography of syntax templates@\spxentry{typography of syntax templates}}\ignorespaces 

\section{Syntax Template Typography}
\label{\detokenize{data/typography:syntax-template-typography}}\label{\detokenize{data/typography:index-0}}\label{\detokenize{data/typography:id1}}\label{\detokenize{data/typography::doc}}
\sphinxAtStartPar
When new C\# syntax is introduced, the usual approach will be to
give both specific examples and general templates. In general
templates for C\# syntax the typeface indicates the the category
of each part:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Typeface
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Typewriter font}}
&
\sphinxAtStartPar
Text to be written \sphinxstyleemphasis{verbatim}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Bold}
&
\sphinxAtStartPar
A place where you can use an arbitrary
identifier.
\\
\hline
\sphinxAtStartPar
\sphinxstyleemphasis{Emphasized}
&
\sphinxAtStartPar
A place where you can use an arbitrary
expression (which might be a single variable name).
\\
\hline
\sphinxAtStartPar
Normal text
&
\sphinxAtStartPar
A description of what goes in that position,
without giving explicit syntax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
An attempt is made with the parts that are not verbatim to be
descriptive of the use expected.

\sphinxAtStartPar
As a start we can give some general syntax for declarations and assignment statements:

\index{statement@\spxentry{statement}!declaration@\spxentry{declaration}}\index{declaration statement@\spxentry{declaration statement}}\ignorespaces 

\subsection{Declaration Syntax Options}
\label{\detokenize{data/typography:declaration-syntax-options}}\label{\detokenize{data/typography:index-1}}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type} \sphinxstylestrong{variableName} \sphinxcode{\sphinxupquote{;}}
\end{quote}

\sphinxAtStartPar
or with initialization:
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type} \sphinxstylestrong{variableName} \sphinxcode{\sphinxupquote{=}} \sphinxstyleemphasis{initialValue} \sphinxcode{\sphinxupquote{;}}
\end{quote}

\sphinxAtStartPar
or there can be a list of variables of the same type, for instance a list
of three variables:
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type} \sphinxstylestrong{variableName1} \sphinxcode{\sphinxupquote{,}} \sphinxstylestrong{variableName2} \sphinxcode{\sphinxupquote{,}} \sphinxstylestrong{variableName3} \sphinxcode{\sphinxupquote{;}}
\end{quote}

\sphinxAtStartPar
Some or all of the variables in the list could also have initializers.

\sphinxAtStartPar
Space is allocated for each variable named, according to its type.  Where there is
an initializer, an initial value is set for the variable.

\index{assignment statement@\spxentry{assignment statement}}\index{statement@\spxentry{statement}!assignment@\spxentry{assignment}}\ignorespaces 

\subsection{Assignment Syntax}
\label{\detokenize{data/typography:assignment-syntax}}\label{\detokenize{data/typography:index-2}}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{variableName} \sphinxcode{\sphinxupquote{=}} \sphinxstyleemphasis{expression} \sphinxcode{\sphinxupquote{;}}
\end{quote}

\sphinxAtStartPar
The \sphinxstyleemphasis{expression} is evaluated before its value is assigned to \sphinxstylestrong{variableName}.

\sphinxstepscope


\section{Strings, Part I}
\label{\detokenize{data/strings1:strings-part-i}}\label{\detokenize{data/strings1::doc}}
\sphinxAtStartPar
Enough with numbers for a while. Strings of characters are another
important type in C\#.

\index{string@\spxentry{string}}\index{""..."" for string literal@\spxentry{""..."" for string literal}}\ignorespaces 
\sphinxAtStartPar
A string in C\# is a sequence of characters. For C\# to
recognize a literal sequence of characters, like \sphinxcode{\sphinxupquote{hello}}, as a string, it
must be enclosed in quotes \sphinxcode{\sphinxupquote{"}} to delimit the string: \sphinxcode{\sphinxupquote{"hello"}}.
Special cases are considered later in {\hyperref[\detokenize{data/strings2:strings2}]{\sphinxcrossref{\DUrole{std,std-ref}{String Special Cases}}}}.

\index{string@\spxentry{string}!concatenation with +@\spxentry{concatenation with +}}\index{concatenation@\spxentry{concatenation}}\index{+@\spxentry{+}!string concatenation@\spxentry{string concatenation}}\index{operator@\spxentry{operator}!+ string concatenation@\spxentry{+ string concatenation}}\ignorespaces 

\subsection{String Concatenation}
\label{\detokenize{data/strings1:string-concatenation}}\label{\detokenize{data/strings1:index-1}}\label{\detokenize{data/strings1:id1}}
\sphinxAtStartPar
Because everything in C\# is typed, C\# can give a special meaning to
operators depending on the types involved,
as we saw with \sphinxcode{\sphinxupquote{/}}.
We can operate on numbers with arithmetic operators, including \sphinxcode{\sphinxupquote{+}}.
With strings \sphinxcode{\sphinxupquote{+}} has a completely different meaning. Look at the example
in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} \PYGZdq{}never\PYGZdq{} + \PYGZdq{}ending\PYGZdq{};
\PYGZdq{}neverending\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The plus operation with strings means \sphinxstyleemphasis{concatenate} the strings: join them
together end to end.

\sphinxAtStartPar
C\# is even a bit smarter.  If you use a \sphinxcode{\sphinxupquote{+}} with a string, presumable you
are looking to produce a string, so even if the second operand to the \sphinxcode{\sphinxupquote{+}} is
\sphinxstyleemphasis{not} a string, it is automatically converted to a string representation before
concatenating:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int x = 42;
csharp\PYGZgt{} string result;
csharp\PYGZgt{} result = \PYGZdq{}We get \PYGZdq{} + x;
csharp\PYGZgt{} result;
\PYGZdq{}We get 42\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can chain concatenations.  We could make a full sentence adding a period:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} \PYGZdq{}We get \PYGZdq{} + x + \PYGZdq{}.\PYGZdq{};
\PYGZdq{}We get 42.\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note to Python programmers:  Unfortunately there is no \sphinxcode{\sphinxupquote{*}}
multiplication operator for strings in C\#.


\subsubsection{Four Copies Exercise}
\label{\detokenize{data/strings1:four-copies-exercise}}
\sphinxAtStartPar
In csharp declare and initialize a string variable.  Write an expression that
evaluates to four copies of the string, so it works no matter what value you
gave your string.


\subsubsection{Sum String Exercise}
\label{\detokenize{data/strings1:sum-string-exercise}}
\sphinxAtStartPar
In csharp declare and initialize two int’s, x and y.  Then enter an expression whose
value is “x + y is 56”, except that 56 is replaced by the sum of x and y, and is not
a literal, but calculated from the actual values of variables x and y (which do not
need to add up to 56 specifically).

\sphinxAtStartPar
This has a trick to it.


\subsubsection{Ints and Strings Added}
\label{\detokenize{data/strings1:ints-and-strings-added}}
\sphinxAtStartPar
In csharp enter

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Think} what the csharp response
is to each of these then write one predicted response at a time,
\sphinxstyleemphasis{then} test it,
and put the right answer beside your answer if you were wrong:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{p}{;}
\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}??\PYGZdq{}}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Can you explain the ones you got wrong, after looking at the actual answer?
Precedence and operation order is important.

\sphinxstepscope

\index{Console@\spxentry{Console}!WriteLine@\spxentry{WriteLine}}\index{WriteLine@\spxentry{WriteLine}!Console@\spxentry{Console}}\ignorespaces 

\section{Writing to the Console}
\label{\detokenize{data/print1:writing-to-the-console}}\label{\detokenize{data/print1:write-to-console}}\label{\detokenize{data/print1:index-0}}\label{\detokenize{data/print1::doc}}
\sphinxAtStartPar
In interactive use of csharp, you can type an
expression and immediately see the result of its evaluation. This
is fine to test out syntax and maybe do simple calculator
calculations. In a regular C\# program run from a file like in
{\hyperref[\detokenize{data/sampleprogram:sample-program}]{\sphinxcrossref{\DUrole{std,std-ref}{A Sample C\# Program}}}},
you must explicitly give instructions to print to a
console or terminal window.  This will be a window like you see
when running csharp.

\sphinxAtStartPar
This printing is accomplished through a function with a long name: \sphinxcode{\sphinxupquote{Console.WriteLine}}.
Like with math, you can pass a function a value to work on, by placing it in
parentheses after the name of the function.  Unlike in high school algebra classes,
in C\# we have many types of data to supply other than numbers.  The simplest
way to use the \sphinxcode{\sphinxupquote{Console.WriteLine}} function is to give it a string.
We can demonstrate in csharp.  The response is just the line that would
be printed in a regular program:

\index{.@\spxentry{.}!class static member@\spxentry{class static member}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{data/print1:index-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}Hello, world!\PYGZdq{});
Hello, world!
\end{sphinxVerbatim}

\sphinxAtStartPar
What is printed to the screen does \sphinxstyleemphasis{not} have the quotes which we needed to
define the literal string \sphinxcode{\sphinxupquote{"Hello, world!"}} inside the program.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Console}} is a C\# class maintained by the system, that
interacts with the terminal or console window where text output
appears for the program.  A function defined in that class is \sphinxcode{\sphinxupquote{WriteLine}}.
To refer to a function like \sphinxcode{\sphinxupquote{WriteLine}} in a different class, you must indicate
the location of the function with the “dot” notation shown:
class name, then \sphinxcode{\sphinxupquote{.}}, then the function.  This
gives the more elaborate name needed in the program.

\sphinxAtStartPar
The string that gets printed can be the result of evaluating an expression,
for instance concatenating:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int total = 5;
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}All together: \PYGZdq{} + total);
All together: 5
\end{sphinxVerbatim}

\sphinxAtStartPar
More elaborate use of \sphinxcode{\sphinxupquote{WriteLine}} is discussed in {\hyperref[\detokenize{data/writeline-substitution:format-strings}]{\sphinxcrossref{\DUrole{std,std-ref}{String Format Operation}}}}.

\index{Console@\spxentry{Console}!Write@\spxentry{Write}}\ignorespaces 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Console.WriteLine}} function automatically makes the printing
position advance to the next line, as when you press the Enter or Return key.
A variant, \sphinxcode{\sphinxupquote{Console.Write}}, prints the parameter exactly, and nothing else.
The statement\sphinxhyphen{}at\sphinxhyphen{}a\sphinxhyphen{}time approach in csharp is not good for illustrating the
differences.

\sphinxAtStartPar
Printing is better shown off in a real program….

\sphinxstepscope

\index{program structure@\spxentry{program structure}}\ignorespaces 

\section{C\# Program Structure}
\label{\detokenize{data/programstructure:c-program-structure}}\label{\detokenize{data/programstructure:program-structure}}\label{\detokenize{data/programstructure:index-0}}\label{\detokenize{data/programstructure::doc}}
\sphinxAtStartPar
We discuss the most basic syntax satisfied by all C\# programs, which are plain text files,
with names ending in \sphinxcode{\sphinxupquote{.cs}}.  There will be additions
later, but any program you can run will include:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{using System;}}
\item[] 
\item[] \sphinxcode{\sphinxupquote{class}} \sphinxstylestrong{ClassName}
\item[] \sphinxcode{\sphinxupquote{\{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{\sphinxupquote{static void Main()}}
\item[] \sphinxcode{\sphinxupquote{\{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] program statements go here….
\item[] 
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
By convention class names are capitalized.

\sphinxAtStartPar
You can see that both the example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/painting/painting.cs}{painting/painting.cs} and the lab program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/hello/hello.cs}{hello/hello.cs} follow this pattern.  The discussion of these parts through
line 6 in
{\hyperref[\detokenize{data/sampleprogram:sample-program}]{\sphinxcrossref{\DUrole{std,std-ref}{A Sample C\# Program}}}} are about all we have to say at this point.  For now this
is the boilerplate code.  We will make additions as necessary.  We choose not to
clutter up the basic setup with features that we are not about to use and discuss.

\sphinxAtStartPar
Here is a silly little test illustrating the difference between \sphinxcode{\sphinxupquote{Console.WriteLine}}
and \sphinxcode{\sphinxupquote{Console.Write}}, in example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/write\_test/write\_test.cs}{write\_test/write\_test.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{WriteTest}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}hello\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}there\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Another line\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Starting \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}yet another line\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When run, the program prints:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hellotherehello
Another line
Starting yet another line
\end{sphinxVerbatim}

\sphinxAtStartPar
Do you see how the output shows the differences between \sphinxcode{\sphinxupquote{WriteLine}} and \sphinxcode{\sphinxupquote{Write}}?
If we added another printing statement, where would the beginning of
the output appear:
after the final \sphinxcode{\sphinxupquote{e}} or under the \sphinxcode{\sphinxupquote{S}} of Starting?

\index{Xamarin Studio@\spxentry{Xamarin Studio}!indentation options setting@\spxentry{indentation options setting}}\index{indentation options in Xamarin Studio@\spxentry{indentation options in Xamarin Studio}}\index{tabs changed to spaces@\spxentry{tabs changed to spaces}}\ignorespaces 

\subsection{Indentation Help}
\label{\detokenize{data/programstructure:indentation-help}}\label{\detokenize{data/programstructure:index-1}}\label{\detokenize{data/programstructure:id1}}
\sphinxAtStartPar
Using conventional indentation helps understand a program and find errors,
like unmatched braces. When you press return in a C\# source file
(i.e. a file with name ending in \sphinxcode{\sphinxupquote{.cs}}), Xamarin Studio makes a guess at the proper
indentation of the next line.  The exact reaction can be set in the \sphinxstyleemphasis{options}.
The simplest approach is to set these options \sphinxstyleemphasis{once} for all new files
in a solution, like your work solution:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Access the context menu for the \sphinxstyleemphasis{whole solution} (not one project).

\item {} 
\sphinxAtStartPar
Select Options.

\noindent\sphinxincludegraphics[width=200bp]{{select_options}.png}

\item {} 
\sphinxAtStartPar
In the popup Solution Options Window, you will see “Code Formatting”
in the left column.  If you do not see “C\# source code” and then “Text file”
right underneath it
click on “Code Formatting” to expand the hierarchy.

\noindent\sphinxincludegraphics[width=300bp]{{set_indent}.png}

\item {} 
\sphinxAtStartPar
Click on \sphinxstylestrong{C\# source code}, and then the right side should show options.
Adjust them to look like the picture: tab and indent widths 3,
first and last check boxes \sphinxstyleemphasis{checked}
(Convert tabs to spaces. Remove trailing spaces),
and have the middle check box (Allow tabs after non\sphinxhyphen{}tabs) \sphinxstyleemphasis{unchecked}.

\item {} 
\sphinxAtStartPar
Click OK in the bottom right corner.

\end{enumerate}

\sphinxAtStartPar
Tabs vs. spaces is not a significant issue inside a consistent environment,
like Xamarin Studio, but if there are tab characters in a file,
they can be expanded different amounts by different display programs.
Then particularly if you mix tab characters and spaces you can get
something very strange.
If only spaces are used, there is no ambiguity in different displays.

\sphinxAtStartPar
The 3 vs. 4 spaces is not a big deal, but 3 appears to be large enough to see
easily, and makes lines with nested indentation have more room.

\index{compiler error@\spxentry{compiler error}!explanation link@\spxentry{explanation link}}\ignorespaces 

\subsection{Compiler Error Help}
\label{\detokenize{data/programstructure:compiler-error-help}}\label{\detokenize{data/programstructure:index-2}}
\sphinxAtStartPar
There are an enormous number of possible \sphinxstyleemphasis{syntactic} errors in your source code
that the compiler
can detect.

\index{editor error annotations@\spxentry{editor error annotations}}\index{syntax error annotations in editor@\spxentry{syntax error annotations in editor}}\index{Xamarin Studio@\spxentry{Xamarin Studio}!editor error annotations@\spxentry{editor error annotations}}\index{logical error@\spxentry{logical error}}\index{run\sphinxhyphen{}time error@\spxentry{run\sphinxhyphen{}time error}}\ignorespaces 
\sphinxAtStartPar
\sphinxstylestrong{Errors shown} \sphinxstyleemphasis{while} \sphinxstylestrong{editing}:  If you use an editor like Xamarin Studio,
some of these errors are even checked while you type and are
noted while you are editing.  They may be indicated with a
red squiggly underline, and possibly a red comment at the right.  Sometimes
the squiggle is just because you are in the middle of something, but if it
is still there after you complete a whole statement, there may well
be an issue to look at.  Sometimes fixing the issue makes the annotation
go away, but sometimes your program may really be fixed,
even though the error annotation
does not go away \sphinxstyleemphasis{until you formally compile/build the whole program}.
This annoying ambiguity leads some people to turn off error annotations,
and just let
the system note errors after a complete compile cycle.

\sphinxAtStartPar
After compiling and getting an error, sometimes reading the error description
carefully  will help you
understand the problem.  Sometimes the error is very cryptic.   In those cases
it might help to look at the C\# .NET error documentation,
\begin{quote}

\sphinxAtStartPar
\sphinxurl{http://msdn.microsoft.com/en-us/library/ms228296.aspx}.
\end{quote}

\sphinxAtStartPar
Each compiler error you make has a number shown in its description.
Many of these error numbers are shown in the left column
of the linked page.  You can click to get a more complete explanation and
examples.

\sphinxAtStartPar
Another important way to learn about the error messages is to leverage your
experience:  After
you have eventually found how to fix your error, \sphinxstyleemphasis{allow the extra time} to
use your new knowledge,
look \sphinxstyleemphasis{back} at the original error message,
and see if the error description text makes more sense now.
That should help next time,
(and there usually is a next time). Even when the error description still
makes no particular sense, you may well get into the same situation again,
with the same error number.  Then
remembering the issue you found in a previous time could help.

\sphinxAtStartPar
Debugging can eat up an enormous amount of time,
so it is really worth your effort to understand the errors that you tend to make
and the errors’ relation to the error messages that you get.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is certainly helpful that the compiler finds \sphinxstyleemphasis{syntactic} errors for you,
but be sure to remember that compiling does \sphinxstyleemphasis{not} mean the program
will “work” and correctly do what you desire.  Test your compiled program
thoroughly to reduce the chance of \sphinxstyleemphasis{logical} errors remaining, that
cause \sphinxstyleemphasis{run\sphinxhyphen{}time} errors, or just the wrong results.
\end{sphinxadmonition}

\index{sequential execution order@\spxentry{sequential execution order}}\index{execution@\spxentry{execution}!sequential order@\spxentry{sequential order}}\index{playing computer@\spxentry{playing computer}}\ignorespaces 

\subsection{Sequential Execution}
\label{\detokenize{data/programstructure:sequential-execution}}\label{\detokenize{data/programstructure:index-4}}\label{\detokenize{data/programstructure:id2}}
\sphinxAtStartPar
A function like \sphinxcode{\sphinxupquote{Main}} involves a sequence of statements to execute.
The basic order of execution is \sphinxstyleemphasis{sequential}:
first statement, then second, ….
This is the same as the \sphinxstyleemphasis{textual order}, so it is easy to follow.  Later in
{\hyperref[\detokenize{functions/functions:defining-own-functions}]{\sphinxcrossref{\DUrole{std,std-ref}{Defining Functions of your Own}}}}, {\hyperref[\detokenize{decisions/decisions:if-statements}]{\sphinxcrossref{\DUrole{std,std-ref}{Decisions}}}}, and {\hyperref[\detokenize{while/while:while-loops}]{\sphinxcrossref{\DUrole{std,std-ref}{While Loops}}}},
we will see more complicated
execution orders that do \sphinxstyleemphasis{not} match textual order.
Whatever the order of execution given by the program, it is important to
always keep track of the current state of the program,
one statement at a time: what statement was just executed,
what are the values of variables after that statement’s execution,
and what will be executed next.

\sphinxAtStartPar
For now consider a small,
artificial example program,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/update\_vars/update\_vars.cs}{update\_vars/update\_vars.cs},
emphasizing the ability to \sphinxstyleemphasis{reassign} variable values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UpdateVars}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// simple sequential code updating two variables}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Can you \sphinxstyleemphasis{predict} the result? Run the program and check.
Particularly if you did not guess right, it is important to
understand what happens, one step at a time. That means keeping
track of what changes to variables are made by each statement.

\sphinxAtStartPar
In the table below, statements are referred to by the numbers labeling
the lines in the code above. We can track the state of each
variable after each line is executed. A dash is shown where a
variable is not yet defined. For instance after line 7 is executed, a
value is given to x, but y is still undefined. Then y gets a value
in line 8.
The comment space can be used any time
it is helpful.  In particular it should be used  when something
is printed, since this
important action does \sphinxstyleemphasis{not} affect the variable list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
x
&\sphinxstyletheadfamily 
\sphinxAtStartPar
y
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Start at beginning of Main
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
initialize x
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
5=3+2, using the value of x from the previous line
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
10=2*5 on the right; use the value of y from the
previous line
\\
\hline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
7=10\sphinxhyphen{}3 on the right; use the value of x and y from the
previous line
\\
\hline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
print: 7 10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The critical point here is to always use the most recently assigned value
of each variable.  Unlike in math, symbol values change!

\sphinxAtStartPar
The order of execution will always be the order of the lines in our
table. In this simple \sphinxstyleemphasis{sequential} code, that \sphinxstyleemphasis{also} follows the
textual order of the program.

\sphinxAtStartPar
Following each line of execution of a
program in the proper order of execution, carefully,
keeping track of the current values of
variables, will be called \sphinxstyleemphasis{playing computer}. A table like the one
above is an organized way to keep track.

\sphinxAtStartPar
The line numbering is not very exciting in a simple sequential program,
but it will become very important when we get to other execution sequences.
We start with the simple sequential numbering now for consistency, as
we get used to the idea of such a table following execution sequence.

\index{playing computer@\spxentry{playing computer}!exercise@\spxentry{exercise}}\index{exercise@\spxentry{exercise}!playing computer@\spxentry{playing computer}}\ignorespaces 

\subsubsection{Play Computer Exercise}
\label{\detokenize{data/programstructure:play-computer-exercise}}\label{\detokenize{data/programstructure:playing-computer-exercise}}\label{\detokenize{data/programstructure:index-5}}
\sphinxAtStartPar
Here is a similar program,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/update\_vars2/update\_vars2.cs}{update\_vars2/update\_vars2.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UpdateVars2}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// for first Playing Computer Exercise}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}:\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Play computer, completing the table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
a
&\sphinxstyletheadfamily 
\sphinxAtStartPar
b
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Start at beginning of Main
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
initialize a
\\
\hline
\sphinxAtStartPar
8
&&&\\
\hline
\sphinxAtStartPar
9
&&&\\
\hline
\sphinxAtStartPar
10
&&&\\
\hline
\sphinxAtStartPar
11
&&&\\
\hline
\sphinxAtStartPar
12
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Another Play Computer Exercise}
\label{\detokenize{data/programstructure:another-play-computer-exercise}}
\sphinxAtStartPar
A silly one on the same line:
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/update\_vars3/update\_vars3.cs}{update\_vars3/update\_vars3.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UpdateVars3}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// another sequentail Playing Computer Exercise}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}b\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Play computer, completing the table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
s
&\sphinxstyletheadfamily 
\sphinxAtStartPar
t
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Start at beginning of Main
\\
\hline
\sphinxAtStartPar
7
&&&\\
\hline
\sphinxAtStartPar
8
&&&\\
\hline
\sphinxAtStartPar
9
&&&\\
\hline
\sphinxAtStartPar
10
&&&\\
\hline
\sphinxAtStartPar
11
&&&\\
\hline
\sphinxAtStartPar
12
&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{Combining Input and Output}
\label{\detokenize{data/io:combining-input-and-output}}\label{\detokenize{data/io:io}}\label{\detokenize{data/io::doc}}
\index{Console@\spxentry{Console}!ReadLine@\spxentry{ReadLine}}\index{ReadLine@\spxentry{ReadLine}!Console@\spxentry{Console}}\ignorespaces 

\subsection{Reading from the Keyboard}
\label{\detokenize{data/io:reading-from-the-keyboard}}\label{\detokenize{data/io:read-from-console}}\label{\detokenize{data/io:index-0}}
\sphinxAtStartPar
If you want users to type something at the keyboard, you should let them know first!
The jargon for this is to give them a \sphinxstyleemphasis{prompt}:  Instructions written to the screen,
something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter your name: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then the user should respond.
What the user types is automatically shown (\sphinxstyleemphasis{echoed})
in the terminal or console window.  For a program to
read what is typed, another function in the \sphinxcode{\sphinxupquote{Console}} class is used:
\sphinxcode{\sphinxupquote{Console.ReadLine}}.

\sphinxAtStartPar
Here the data for the function comes from a line typed at the keyboard by the user,
so there is no need for a parameter between
the parentheses: \sphinxcode{\sphinxupquote{Console.ReadLine()}}.
The resulting sequence of characters,
typed before the user presses the Enter (Return) key,
form the string \sphinxstyleemphasis{value} of the function.
Syntactically in C\#,
when a function with a value is used, it is an \sphinxstyleemphasis{expression} in the
program, and the
expression evaluation is the value produced by the function.
This is the same as in normal use of functions in math.

\sphinxAtStartPar
With any function producing a value,
the value is \sphinxstyleemphasis{lost} unless it is \sphinxstyleemphasis{immediately} used.
Often this is done by immediately assigning the value to a variable like in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}
\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or in the shorter

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\index{Console@\spxentry{Console}!ReadKey@\spxentry{ReadKey}}\index{ReadKey@\spxentry{ReadKey}}\ignorespaces 
\sphinxAtStartPar
Fine point:  Notice that in most operating systems you can edit and correct your line
before pressing the Return key.  This is handy,
but it means that the Return key \sphinxstyleemphasis{must} always be pressed to signal the end
of the response.
Hence a whole line must be read, and there is \sphinxstyleemphasis{no} function \sphinxcode{\sphinxupquote{Console.Read()}}.
Just for completeness we mention that you can read a raw single keystroke immediately
(no editing beforehand).  If you want to explore that later, see
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_readkey/test\_readkey.cs}{test\_readkey/test\_readkey.cs}.

\index{string@\spxentry{string}!Parse to int or double@\spxentry{Parse to int or double}}\index{Parse int and double@\spxentry{Parse int and double}}\index{int@\spxentry{int}!Parse@\spxentry{Parse}}\index{double@\spxentry{double}!Parse@\spxentry{Parse}}\ignorespaces 

\subsection{Numbers and Strings of Digits}
\label{\detokenize{data/io:numbers-and-strings-of-digits}}\label{\detokenize{data/io:numbers-and-digit-strings}}\label{\detokenize{data/io:index-2}}
\sphinxAtStartPar
You may well want to have the user supply you with numbers.
There is a complication.  Suppose you want to get numbers and add them.
What happens with this code, in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/bad\_sum/bad\_sum.cs}{bad\_sum/bad\_sum.cs}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{BadSum}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter an integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter another integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}They add up to \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is a sample run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Enter an integer: 23
Enter another integer: 9
They add up to 239
\end{sphinxVerbatim}

\sphinxAtStartPar
C\# has a type for everything and
\sphinxcode{\sphinxupquote{Console.ReadLine()}} gives you a string.
Adding strings with \sphinxcode{\sphinxupquote{+}} is not the same as adding numbers!

\sphinxAtStartPar
We must explicitly convert the strings to the proper kind of number.
There are functions to do that:  \sphinxcode{\sphinxupquote{int.Parse}} takes a string parameter
that should be the characters in an \sphinxcode{\sphinxupquote{int}}, like “123” or “\sphinxhyphen{}25”, and
produces the corresponding \sphinxcode{\sphinxupquote{int}} value, like 123 or \sphinxhyphen{}25.
In \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/good\_sum/good\_sum.cs}{good\_sum/good\_sum.cs}, we changed the names to emphasize the type
conversions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{GoodSum}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter an integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{xString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{xString}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Enter another integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{yString}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{yString}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}They add up to \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that the values calculated by \sphinxcode{\sphinxupquote{int.Parse}} for the strings
\sphinxcode{\sphinxupquote{xString}} and \sphinxcode{\sphinxupquote{yString}} are immediately remembered in
assignment statements.  Be careful of the distinction here.
The \sphinxcode{\sphinxupquote{int.Parse}} function does not magically \sphinxstyleemphasis{change}
the variable \sphinxcode{\sphinxupquote{xString}} into an \sphinxcode{\sphinxupquote{int}}:  the string \sphinxcode{\sphinxupquote{xString}} is unchanged,
but the corresponding \sphinxcode{\sphinxupquote{int}} value is calculated,
and gets assigned to an \sphinxcode{\sphinxupquote{int}} variable, \sphinxcode{\sphinxupquote{x}}.

\sphinxAtStartPar
Note that this would not work if the string represents the wrong kind of number,
but there is an alternative:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} string s = \PYGZdq{}34.5\PYGZdq{};
csharp\PYGZgt{} int.Parse(s);
System.FormatException: Input string was not in the correct format ....
csharp\PYGZgt{} double.Parse(s);
34.5
\end{sphinxVerbatim}

\sphinxAtStartPar
We omitted the long tail of the error message.
There is no decimal point in an \sphinxcode{\sphinxupquote{int}}.
You see the fix with the corresponding function that returns a double.


\subsection{Example Projects and the Source Repository}
\label{\detokenize{data/io:example-projects-and-the-source-repository}}
\sphinxAtStartPar
We have started to refer to whole programs that we have written.  You will
want to have your own copies to test and modify for related work.

\sphinxAtStartPar
All of our examples are set up in a Xamarin Studio solution in our
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/archive/master.zip}{zip file that you can download}.

\sphinxAtStartPar
The zip file and the folder it unzips to have the long name
introcs\sphinxhyphen{}csharp\sphinxhyphen{}examples\sphinxhyphen{}master.  We suggest you \sphinxstyleemphasis{rename the folder} simply
\sphinxcode{\sphinxupquote{examples}} to match the name of the Xamarin Studio solution it contains.

\sphinxAtStartPar
There are various way to access our files.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
One way is to look at individual files from your download
under our examples directory.

\item {} 
\sphinxAtStartPar
If you open the examples solution in Xamarin Studio,
you can select files from the Solutions pad.
(Instructions are in the next section.)

\item {} 
\sphinxAtStartPar
In the notes we refer to individual code file names that are hyperlinked.
They link to the \sphinxstyleemphasis{latest version} in our online source repository.
You get a display of color\sphinxhyphen{}coded web page with numbered lines.  If you
want to adapt a chunk, you can select it, and copy.
If you want to copy all of a large file, your editing shortcuts
for Select All do \sphinxstyleemphasis{not} work:  You get a bunch of extra html.
An alternative is to click the \sphinxstylestrong{Raw} button in the web page
to the left above the source code.
That brings up a plain text page with just the code.
You can either download it or select all of it, and you
\sphinxstyleemphasis{only} get the code.

\end{enumerate}

\sphinxAtStartPar
We have one main convention in naming our projects:  Most projects are
examples of full, functional programs to run.  Others are intended to be
copied by you as \sphinxstyleemphasis{stubs} for your solutions, for you to elaborate.
These project folders all end with
“\_stub”, like \sphinxcode{\sphinxupquote{string\_manip\_stub}}.  Even the stubs can be compiled
immediately, though they may not accomplish anything.

\index{chunk in source comments@\spxentry{chunk in source comments}}\ignorespaces 
\sphinxAtStartPar
A further convention is using “chunk” comments inside example source files:
To keep the book and the source code in sync, our
\sphinxhref{http://sphinx-doc.org/}{Sphinx}
building routine directly uses excerpts from
the exact source code that is in the
examples download.  We have to mark the limits of the excerpts that we want
for the book.
Our convention is to have a comment referring to the beginning or the
end of an excerpt “chunk”.
Hence a comment including “chunk” in a source file is
\sphinxstyleemphasis{not} intended as commentary on the code, but merely a marker for
automatically regenerating a revision of the book.


\subsection{Running our Xamarin Studio Examples Solution}
\label{\detokenize{data/io:running-our-xamarin-studio-examples-solution}}\label{\detokenize{data/io:our-md-projects}}
\sphinxAtStartPar
If you are just starting Xamarin Studio, and you have \sphinxstyleemphasis{not} run our solution before:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure you have downloaded and unzipped our
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/archive/master.zip}{examples}.
You get a folder with a mouythfull of a name \sphinxcode{\sphinxupquote{introcs\sphinxhyphen{}csharp\sphinxhyphen{}examples\sphinxhyphen{}master}}.  We will
assume you reduce the name of the folder to the much shorter \sphinxcode{\sphinxupquote{examples}}.

\item {} 
\sphinxAtStartPar
On the Xamarin Studio Welcome screen select the button Open….

\item {} 
\sphinxAtStartPar
You get an open\sphinxhyphen{}file dialog.  Navigate to our \sphinxcode{\sphinxupquote{examples}} solution.

\item {} 
\sphinxAtStartPar
Select \sphinxcode{\sphinxupquote{examples/examples.sln}}.  The sln is short for solution.

\end{enumerate}

\sphinxAtStartPar
The next time you come to the Welcome screen, our examples should be listed in the
Recent Projects, and you can click to open it directly.


\subsection{Copying and Modifying Our Example Xamarin Studio Projects}
\label{\detokenize{data/io:copying-and-modifying-our-example-xamarin-studio-projects}}
\sphinxAtStartPar
We strongly encourage you \sphinxstyleemphasis{not} to modify our examples in place, if you want
to keep the changes, because we will make additions and modifications to
our source download, and we would not want you to overwrite any of
your modified files after downloading a later version of the examples.

\sphinxAtStartPar
If you do want to alter our code, we suggest you copy it to a project in your
solution (“work”, discussed in the first lab in the {\hyperref[\detokenize{data/lab-edit-compile-run:steps}]{\sphinxcrossref{\DUrole{std,std-ref}{Steps}}}}).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open your solution.

\item {} 
\sphinxAtStartPar
Create a new project, maybe with the same name as the one we had.  If it was a
“\_stub” project, remove the “\_stub” from your project’s name.

\item {} 
\sphinxAtStartPar
In the Solution Pad open the menu on your new project
(\sphinxstyleemphasis{not} the whole solution), select, Add, and then in the
further submenu, select Add Files….

\item {} 
\sphinxAtStartPar
This brings up an operating system open\sphinxhyphen{}file dialog.  Switch folders into our
example projects.  Select the files you want to copy.
(It makes things easier if you put the examples folder
in the same parent folder as your work folder.)

\item {} 
\sphinxAtStartPar
A further dialog window pops up, with the choice \sphinxstylestrong{Copy} selected.
Click to approve copy (as opposed to move or link).

\item {} 
\sphinxAtStartPar
Now the desired files should appear in your project,
along with the unfortunate default Program.cs.  If you have not already
deleted Program.cs, as described in {\hyperref[\detokenize{data/lab-edit-compile-run:steps}]{\sphinxcrossref{\DUrole{std,std-ref}{Steps}}}}, do it now.

\item {} 
\sphinxAtStartPar
If you intended to copy everything for a project, test by running the project.
Even our stub projects should compile, though a stub project may not do anything
when you run it until you add your own code to it.  To make successful incremental
additions, it is always good to start from something that compiles!

\end{enumerate}

\sphinxAtStartPar
When creating modifications of previous examples, like the exercise below,
you can often save time by copying in the related example, particularly avoiding
retyping the standard boiler plate code at the top.  However, when you are first
learning and getting used to new syntax, typing reinforces learning.
Perhaps after looking over the related example, you are encouraged to write your
version \sphinxstyleemphasis{from scratch}, to get used to all the parts of the code.  Later, when
you can produce such text automatically, feel free to switch to just
copying from a place that you had it before.


\subsubsection{Interview Exercise/Example}
\label{\detokenize{data/io:interview-exercise-example}}\label{\detokenize{data/io:interviewproblem}}
\sphinxAtStartPar
Write a program that prompts the user for a name (like Elliot)  and a time
(like 10AM) and prints out a sentence like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Elliot has an interview at 10AM.
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are having a hard time and want a further example,
or want to compare to your work,
see our solution, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interview/interview.cs}{interview/interview.cs}.


\subsubsection{Exercise for Addition}
\label{\detokenize{data/io:exercise-for-addition}}\label{\detokenize{data/io:additionproblem}}
\sphinxAtStartPar
Write a version, \sphinxcode{\sphinxupquote{add3.cs}}, that
prompts the user for three numbers, \sphinxstyleemphasis{not necessarily integers},
and lists all three, and their sum, in
similar format to \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/good\_sum/good\_sum.cs}{good\_sum/good\_sum.cs}.


\subsubsection{Exercise for Quotients}
\label{\detokenize{data/io:exercise-for-quotients}}\label{\detokenize{data/io:quotientproblem}}
\sphinxAtStartPar
Write a program, \sphinxcode{\sphinxupquote{quotient.cs}}, that
prompts the user for two integers, and then prints them out in a
sentence with an integer division problem like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The quotient of 14 and 3 is 4 with a remainder of 2.
\end{sphinxVerbatim}

\sphinxAtStartPar
Review {\hyperref[\detokenize{data/arithmetic:division-and-remainders}]{\sphinxcrossref{\DUrole{std,std-ref}{Division and Remainders}}}} if you forget the integer
division or remainder operator.

\sphinxstepscope


\section{String Special Cases}
\label{\detokenize{data/strings2:string-special-cases}}\label{\detokenize{data/strings2:strings2}}\label{\detokenize{data/strings2::doc}}
\index{escape code \textbackslash{}@\spxentry{escape code \textbackslash{}}}\index{\textbackslash{}@\spxentry{\textbackslash{}}!character escape code@\spxentry{character escape code}}\index{character escape code \textbackslash{}@\spxentry{character escape code \textbackslash{}}}\ignorespaces 
\sphinxAtStartPar
There are some special cases for creating literal strings.
For instance you might want quotes
as characters inside your string.  In this case you need special
symbolism using a character \sphinxstyleemphasis{escape code}, starting with  \sphinxcode{\sphinxupquote{\textbackslash{}}} backslash.
Then the character after the backslash has a special meaning.

\sphinxAtStartPar
For instance a quote character after a backslash, \sphinxcode{\sphinxupquote{\textbackslash{}"}},
does not mean the end of a string literal.  It means a quote character
is literally used \sphinxstyleemphasis{in} the string:  \sphinxcode{\sphinxupquote{"He said, \textbackslash{}"Hello!\textbackslash{}", over and over."}}

\sphinxAtStartPar
We can illustrate with csharp, first with a simple string:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}Hello world!\PYGZdq{});
Hello world!
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}He said, \PYGZbs{}\PYGZdq{}Hello!\PYGZbs{}\PYGZdq{}, over and over.\PYGZdq{});
He said, \PYGZdq{}Hello!\PYGZdq{}, over and over.
\end{sphinxVerbatim}

\sphinxAtStartPar
There are many other special cases of escape code.  The main ones
you are likely to use are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Escape code
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}"}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"}} (quote)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}\textquotesingle{}}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textquotesingle{}}} ( single quote in char literal)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}}} (backslash)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}n}}
&
\sphinxAtStartPar
newline
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Hence if you really want a backslash character in a literal,
you need to write two of them.

\sphinxAtStartPar
The newline character indicates further text will appear on the next line down
when \sphinxstyleemphasis{printed} with the \sphinxcode{\sphinxupquote{Console.WriteLine}} function.

\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}Windows path: c:\PYGZbs{}\PYGZbs{}Users\PYGZbs{}\PYGZbs{}aharrin\PYGZdq{});
Windows path: c:\PYGZbs{}Users\PYGZbs{}aharrin
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}a\PYGZbs{}nbc\PYGZbs{}n\PYGZbs{}ndef\PYGZdq{})
a
bc

def
\end{sphinxVerbatim}

\index{string@\spxentry{string}!"@@\spxentry{"@}}\index{"@ string literal@\spxentry{"@ string literal}}\index{verbatim string with "@@\spxentry{verbatim string with "@}}\ignorespaces 
\sphinxAtStartPar
Literal strings that are simply delimited by quotes \sphinxcode{\sphinxupquote{"}}
must start and end on the same line.
There is also a notation for \sphinxstyleemphasis{@\sphinxhyphen{}quoting}, with an at\sphinxhyphen{}sign \sphinxcode{\sphinxupquote{@}} before the first
quote.  In an @\sphinxhyphen{}quoted string, all characters are treated verbatim, including
all backslashes.  Also the string may go on for several lines, and all newlines
are included literally.  (The csharp program does not recognize
multi\sphinxhyphen{}line @\sphinxhyphen{}quoted strings.)
This fragment in a program would produce the same output as the statements in
the csharp example above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{@\PYGZdq{}Windows path: c:\PYGZbs{}Users\PYGZbs{}aharrin\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{@\PYGZdq{}a}
\PYG{l+s}{bc}

\PYG{l+s}{def\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The only thing this example does not show off well is the amount of
left margin indentation.
That is significant in a multiline @\sphinxhyphen{}quoted string.
A whole simple program with this code is in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/at\_sign\_strings/at\_sign\_strings.cs}{at\_sign\_strings/at\_sign\_strings.cs}.

\index{csharp@\spxentry{csharp}!verbatim string display@\spxentry{verbatim string display}}\ignorespaces 
\sphinxAtStartPar
Caution:  When you give csharp an expression evaluating to a string at the
prompt, you get back a verbatim string with \sphinxstyleemphasis{quotes added around it},
but no \sphinxcode{\sphinxupquote{@}} to remind you that it is verbatim:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} \PYGZdq{}Windows path: c:\PYGZbs{}\PYGZbs{}Users\PYGZbs{}\PYGZbs{}aharrin\PYGZdq{}
\PYGZdq{}Windows path: c:\PYGZbs{}Users\PYGZbs{}aharrin\PYGZdq{}
csharp\PYGZgt{} \PYGZdq{}a\PYGZbs{}nbc\PYGZbs{}n\PYGZbs{}ndef\PYGZdq{}
\PYGZdq{}a
bc

def\PYGZdq{}
\end{sphinxVerbatim}


\subsection{Multiline String Exercise}
\label{\detokenize{data/strings2:multiline-string-exercise}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Write a statement that initializes a string \sphinxcode{\sphinxupquote{s}} with a \sphinxstylestrong{single}
string literal that, when printed, shows something on one line then three
empty lines, and then a final line with text.

\item {} 
\sphinxAtStartPar
Declare the same string with a different string literal expression, that
produces the same string.  (Just one of your literals should start
with \sphinxcode{\sphinxupquote{@}}.)

\end{enumerate}

\sphinxstepscope


\section{Substitutions in Console.WriteLine}
\label{\detokenize{data/writeline-substitution:substitutions-in-console-writeline}}\label{\detokenize{data/writeline-substitution:substitution-in-writeline}}\label{\detokenize{data/writeline-substitution::doc}}

\subsection{Output With \sphinxstyleliteralintitle{\sphinxupquote{+}}}
\label{\detokenize{data/writeline-substitution:output-with}}
\sphinxAtStartPar
An elaboration of a “Hello, World” program, could greet the user,
after obtaining the user’s name.  If the user enters the name
Elliot, the program could print
\begin{quote}

\sphinxAtStartPar
Hello, Elliot!
\end{quote}

\sphinxAtStartPar
This is a very simple
input\sphinxhyphen{}process\sphinxhyphen{}output program (in fact with almost no “process”).
Think how would you code it.

\sphinxAtStartPar
You need to obtain a name, remember it and use it in your output.
A solution is in the next section.

\index{WriteLine@\spxentry{WriteLine}!\sphinxleftcurlybrace{} \sphinxrightcurlybrace{} for format@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{} for format}}\index{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}!Format@\spxentry{Format}}\ignorespaces 

\subsection{String Format Operation}
\label{\detokenize{data/writeline-substitution:string-format-operation}}\label{\detokenize{data/writeline-substitution:format-strings}}\label{\detokenize{data/writeline-substitution:index-0}}
\sphinxAtStartPar
A common convention is fill\sphinxhyphen{}in\sphinxhyphen{}the blanks. For instance,
\begin{quote}

\sphinxAtStartPar
Hello, \_\_\_\_\_!
\end{quote}

\sphinxAtStartPar
and you can fill in the name of the person greeted, and combine
given text with a chosen insertion. C\# has a similar
construction, better called fill\sphinxhyphen{}in\sphinxhyphen{}the\sphinxhyphen{}braces,
that can be used with \sphinxcode{\sphinxupquote{Console.WriteLine}}.

\sphinxAtStartPar
Instead of inserting user input with the \sphinxcode{\sphinxupquote{+}} operation as in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/hello\_you1/hello\_you1.cs}{hello\_you1/hello\_you1.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{HelloYou1}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}What is your name?\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Hello, \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
look at a variation, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/hello\_you2/hello\_you2.cs}{hello\_you2/hello\_you2.cs}, shown below.
Both programs
look exactly the same to the user:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{HelloYou}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}What is your name?\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Hello, \PYGZob{}0\PYGZcb{}!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
All the new syntax is in the line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Hello, \PYGZob{}0\PYGZcb{}!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Console.WriteLine}} actually can take parameters \sphinxstyleemphasis{after} an initial string,
but only when  the string is in the form of a \sphinxstyleemphasis{format string},
with expression(s) in braces where substitutions are to be made,
(like in fill\sphinxhyphen{}in\sphinxhyphen{}the\sphinxhyphen{}blanks). Here the format string is \sphinxcode{\sphinxupquote{"Hello, \{0\}!"}}.

\sphinxAtStartPar
The remaining parameters, after the initial string,
give the values to be substituted.  To
know \sphinxstyleemphasis{which} further parameter to substitute, the parameters after the
initial string are implicitly numbered,
\sphinxstyleemphasis{starting from 0}.
Starting with 0 is consistent with other numbering sequences in C\#.
So here, where there is just one value to substitute (\sphinxcode{\sphinxupquote{name}}), it gets the index 0,
and where it is substituted, the braces get 0 inside, to indicate
that parameter with index 0 is to be substituted.

\sphinxAtStartPar
Everything in the initial string that is \sphinxstyleemphasis{outside} the braces is just
\sphinxstyleemphasis{repeated verbatim}.  In particular, if the only parameter is a string
with no braces, it is printed completely
verbatim (reducing to the situations where we have used \sphinxcode{\sphinxupquote{Console.WriteLine}} before).

\sphinxAtStartPar
A more elaborate silly examples that you could test in csharp would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{first}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Peter\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{last}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Piper\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{what}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}pick\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{first}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{last}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{what}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It would print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Peter}\PYG{+w}{ }\PYG{n}{Piper}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Peter}\PYG{+w}{ }\PYG{n}{Piper}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pick}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
where parameter 0 is \sphinxcode{\sphinxupquote{first}} (value \sphinxcode{\sphinxupquote{"Peter"}}),
parameter 1 is \sphinxcode{\sphinxupquote{last}} ( value \sphinxcode{\sphinxupquote{"Piper"}}), and
parameter 2 is \sphinxcode{\sphinxupquote{what}} (value \sphinxcode{\sphinxupquote{"pick"}}).

\sphinxAtStartPar
Make sure you see why the given output is exactly what is printed.

\sphinxAtStartPar
Or try in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} plus \PYGZob{}1\PYGZcb{} is \PYGZob{}2\PYGZcb{}; \PYGZob{}0\PYGZcb{} times \PYGZob{}1\PYGZcb{} is \PYGZob{}3\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and see it print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
7 plus 5 is 12; 7 times 5 is 35.
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the following features of the parameters after the first string:
\begin{itemize}
\item {} 
\sphinxAtStartPar
These parameters can be any expression,
and the expressions get evaluated before printing.

\item {} 
\sphinxAtStartPar
These parameters to be substituted can be of any type.

\item {} 
\sphinxAtStartPar
These parameters are automatically converted to a string form, just as in the
use of the string \sphinxcode{\sphinxupquote{+}} operation.

\end{itemize}

\sphinxAtStartPar
In fact the simple use of format strings
shown so far can be completed replaced by long expressions with \sphinxcode{\sphinxupquote{+}},
if that is your taste.  We later discusses fancier formatting in {\hyperref[\detokenize{for/forexamples:tables}]{\sphinxcrossref{\DUrole{std,std-ref}{Tables}}}},
that \sphinxstyleemphasis{cannot} be duplicated with a simple string \sphinxcode{\sphinxupquote{+}} operation.
We will use the simple numbered substitutions for now just
to get used to the idea of substitution.

\index{format@\spxentry{format}!literal \sphinxleftcurlybrace{}\sphinxrightcurlybrace{}@\spxentry{literal \sphinxleftcurlybrace{}\sphinxrightcurlybrace{}}}\ignorespaces 
\sphinxAtStartPar
A technical point: Since braces have special meaning in a format
string, there must be a special rule if you want braces to actually
be included in the final \sphinxstyleemphasis{formatted} string. The rule is to double
the braces: \sphinxcode{\sphinxupquote{"\{\{"}} and \sphinxcode{\sphinxupquote{"\}\}"}}. The fragment

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The set is \PYGZob{}\PYGZob{}\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}\PYGZcb{}\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
produces

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The set is \PYGZob{}2, 3\PYGZcb{}.
\end{sphinxVerbatim}

\sphinxAtStartPar
Note:  Braces only get their special meaning if there are at least two
parameters (forcing the first parameter to be a format string).
If there is just a single parameter,
braces are interpreted as regular characters.


\subsubsection{Format Reading Exercise}
\label{\detokenize{data/writeline-substitution:format-reading-exercise}}
\sphinxAtStartPar
What is printed?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{}\PYGZob{}1\PYGZcb{}\PYGZob{}1\PYGZcb{}\PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Mi\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}ssi\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}ppi\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Check yourself.


\subsubsection{Exercise for Format}
\label{\detokenize{data/writeline-substitution:exercise-for-format}}\label{\detokenize{data/writeline-substitution:quotientformat}}
\sphinxAtStartPar
Write a program, \sphinxcode{\sphinxupquote{quotient\_format.cs}}, that behaves like
{\hyperref[\detokenize{data/io:quotientproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercise for Quotients}}}}, but generate the sentence using
\sphinxcode{\sphinxupquote{Console.WriteLine}} with a format string and no \sphinxcode{\sphinxupquote{+}} operator.


\subsubsection{Madlib Exercise}
\label{\detokenize{data/writeline-substitution:madlib-exercise}}
\sphinxAtStartPar
Write a program, \sphinxcode{\sphinxupquote{my\_mad\_lib.cs}}, that prompts the user for
words that fit specified gramatical patterns ( a noun, a verb, a color,
a city….) and plug them into a multiline format string so they fit
grammatically, and
print the usually silly result.
If you are not used to mad libs, try running (not
looking at the source code) the example project mad\_lib, and then try it
again with different data.
If this exercise seems like too big of a challenge yet,
see our example source code,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/mad\_lib/mad\_lib.cs}{mad\_lib/mad\_lib.cs}, and then \sphinxstyleemphasis{start over} on your own.

\index{method@\spxentry{method}!overloading@\spxentry{overloading}}\index{overloading@\spxentry{overloading}!methods@\spxentry{methods}}\ignorespaces 

\subsection{Overloading}
\label{\detokenize{data/writeline-substitution:overloading}}\label{\detokenize{data/writeline-substitution:index-2}}\label{\detokenize{data/writeline-substitution:id1}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{WriteLine}} function can take parameters in different ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
It can take a single parameter of an type (and print its string representation).

\item {} 
\sphinxAtStartPar
It can take a string parameter followed by any number of parameters used to
substitute into the initial format string.

\item {} 
\sphinxAtStartPar
It can take no parameters, and just advance to the next line (not used yet in
this book).

\end{itemize}

\sphinxAtStartPar
Though each of these uses has the same name, \sphinxcode{\sphinxupquote{Console.WriteLine}},
they are technically all different functions:  A function is not just recognized
by its name, but by its \sphinxstyleemphasis{signature},
which includes the name \sphinxstylestrong{and} the number and types of parameters.
The technical term for using the same name with different signatures for different
functions is \sphinxstyleemphasis{overloading} the function (or method).

\sphinxAtStartPar
This only makes practical sense for a group of closely related functions, where the
use of the same name is more helpful than confusing.

\sphinxstepscope

\index{type@\spxentry{type}!value@\spxentry{value}}\index{value type@\spxentry{value type}}\ignorespaces 

\section{Value Types and Conversions}
\label{\detokenize{data/types-and-conversions:value-types-and-conversions}}\label{\detokenize{data/types-and-conversions:value-types}}\label{\detokenize{data/types-and-conversions:index-0}}\label{\detokenize{data/types-and-conversions::doc}}
\index{int@\spxentry{int}!value range@\spxentry{value range}}\index{type@\spxentry{type}!int@\spxentry{int}}\index{overflow@\spxentry{overflow}}\ignorespaces 

\subsection{Type int}
\label{\detokenize{data/types-and-conversions:type-int}}\label{\detokenize{data/types-and-conversions:index-1}}\label{\detokenize{data/types-and-conversions:id1}}
\sphinxAtStartPar
A variable is
associated with a space in memory.  This space has a fixed size associated with the type
of data.
The \sphinxcode{\sphinxupquote{int}} and \sphinxcode{\sphinxupquote{double}} types are examples of \sphinxstyleemphasis{value types},
which means that this memory space holds an encoding of the complete data for the
value of the variable.  The fixed space means that an \sphinxcode{\sphinxupquote{int}} cannot be a totally
arbitrary integer of an enormous size.  In fact an \sphinxcode{\sphinxupquote{int}} variable can only hold
an integer in a specific range.  See {\hyperref[\detokenize{context/computerscience:data-representation}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Representation}}}} for the
general format of the underlying encoding in bits.

\sphinxAtStartPar
An \sphinxcode{\sphinxupquote{int}} is held in a memory space of 32 bits, so it can have at
most \(2^{32}\) values, and the encoding is chosen so about half are positive and
half are negative: An \sphinxcode{\sphinxupquote{int}} has maximum value \(2^{31} - 1 = 2147483647\) and
a minimum value of \(-2^{31} = -2147483648\).  The extreme values are also
named constants in C\#, \sphinxcode{\sphinxupquote{int.MaxValue}} and \sphinxcode{\sphinxupquote{int.MinValue}}.

\sphinxAtStartPar
In particular this means \sphinxcode{\sphinxupquote{int}} arithmetic does not always work.  What is worse,
it fails \sphinxstyleemphasis{silently}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int i = int.MaxValue;
csharp\PYGZgt{} i;
2147483647
csharp\PYGZgt{} i + 5;
\PYGZhy{}2147483644
\end{sphinxVerbatim}

\sphinxAtStartPar
Add two positive numbers and get a negative number!  Getting such a wrong
answer is called \sphinxstyleemphasis{overflow}.
Be very careful if you are
going to be using big numbers!  Note: with addition,
overflow will give the wrong sign,
but the sign may not give such a clue
if another operation overflows, like multiplication.

\index{type@\spxentry{type}!long@\spxentry{long}}\index{long type@\spxentry{long type}}\index{short type@\spxentry{short type}}\index{byte type@\spxentry{byte type}}\ignorespaces 

\subsection{Type long}
\label{\detokenize{data/types-and-conversions:type-long}}\label{\detokenize{data/types-and-conversions:index-2}}\label{\detokenize{data/types-and-conversions:id2}}
\sphinxAtStartPar
Most everyday uses of integers fit in this range of an \sphinxcode{\sphinxupquote{int}},
and many modern computers are designed
to operate on an \sphinxcode{\sphinxupquote{int}} very efficiently, but sometimes you need a
larger range.  Type \sphinxtitleref{long} uses twice as much space.

\sphinxAtStartPar
The same kind of silent overflow errors happen with \sphinxcode{\sphinxupquote{long}} arithmetic, but only
with much larger numbers.

\sphinxAtStartPar
When we get to {\hyperref[\detokenize{arrays/arrays:array}]{\sphinxcrossref{\DUrole{std,std-ref}{Arrays}}}}, you will see that a program may store
an enormous number of integers, and then the total space may be an
issue.  If some numbers fit in a \sphinxcode{\sphinxupquote{long}}, but not an \sphinxcode{\sphinxupquote{int}},
\sphinxcode{\sphinxupquote{long}} must be used, taking us twice the space of an array of \sphinxcode{\sphinxupquote{int}}
elements.  If all the integers have even more limited ranges,
they might be stored in the smaller space of a \sphinxcode{\sphinxupquote{short}}
or a \sphinxcode{\sphinxupquote{byte}}.
We will not further discuss or use types \sphinxcode{\sphinxupquote{short}} or \sphinxcode{\sphinxupquote{byte}} in this book.
Here we will only use the integral types \sphinxcode{\sphinxupquote{int}} and \sphinxcode{\sphinxupquote{long}}.

\index{type@\spxentry{type}!double@\spxentry{double}}\index{double type@\spxentry{double type}}\index{precision@\spxentry{precision}}\index{float type@\spxentry{float type}}\index{type@\spxentry{type}!float@\spxentry{float}}\ignorespaces 

\subsection{Type double}
\label{\detokenize{data/types-and-conversions:type-double}}\label{\detokenize{data/types-and-conversions:index-3}}\label{\detokenize{data/types-and-conversions:id3}}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{double}} is also a value type, stored in a fixed sized space.  There are
even more issues with \sphinxcode{\sphinxupquote{double}} storage than with an \sphinxcode{\sphinxupquote{int}}:  Not only do you need
to worry about the total magnitude of the number, you also need to choose
a \sphinxstyleemphasis{precision}:  There are an infinite number of real values, just between 0 and 1.
Clearly we cannot encode for all of them!  As a result a \sphinxcode{\sphinxupquote{double}} has a limited
number of digits of accuracy.  There is also an older type \sphinxcode{\sphinxupquote{float}} that takes up
half of the space of a \sphinxcode{\sphinxupquote{double}}, and has a smaller range and less accuracy.  This at
least gives a reason for the name \sphinxcode{\sphinxupquote{double}}:  double the storage space of a \sphinxcode{\sphinxupquote{float}}.

\sphinxAtStartPar
To avoid a ridiculously large number of
trailing 0’s, a big double literal can be
expressed using a variant of scientific notation:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1.79769313486232E+308}} means \(1.7976931348623157(10^{308})\)
\end{quote}

\sphinxAtStartPar
C\# does not have the typography for raised exponents.  Instead
literal values can use the E to mean
“times 10 to the power”, and the E is followed by and exponent integer
that can be positive or negative.
The whole double literal may not contain any embedded blanks.  Internally
these numbers are stored with powers of 2, not 10:  See
{\hyperref[\detokenize{context/computerscience:data-representation}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Representation}}}}.

\sphinxAtStartPar
Arithmetic with the \sphinxcode{\sphinxupquote{double}} type does not overflow silently as with
the integral types.
We show behavior that could be important if you do scientific computing
with enormous numbers:  There are values for Infinity and Not a Number,
abbreviated NaN.  See them used in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} double x = double.MaxValue;
csharp\PYGZgt{} x;
1.79769313486232E+308
csharp\PYGZgt{} double y = 10 * x;
csharp\PYGZgt{} y;
Infinity
csharp\PYGZgt{} y  + 1000;
Infinity
csharp\PYGZgt{} y  \PYGZhy{} 1000;
Infinity
csharp\PYGZgt{} 1000/y;
0
csharp\PYGZgt{} double z = 10 \PYGZhy{} y;
csharp\PYGZgt{} z;
\PYGZhy{}Infinity
csharp\PYGZgt{} double sum = y + z;
csharp\PYGZgt{} sum;
NaN
csharp\PYGZgt{} sum/1000;
NaN
\end{sphinxVerbatim}

\sphinxAtStartPar
Once a result gets too big, it gets listed as infinity.
As you can see,
there is some arithmetic allowed with a finite number and infinity!
Still some operations are not legal.
Once a result turns into \sphinxcode{\sphinxupquote{NaN}}, no arithmetic operations change
further results away from \sphinxcode{\sphinxupquote{NaN}},
so there is a lasting record of a big error!

\sphinxAtStartPar
Note that Infinity, \sphinxhyphen{}Infinity and NaN are just representations when displayed
as strings.  The numerical constants are
\sphinxcode{\sphinxupquote{Double.PositiveInfinity}}, \sphinxcode{\sphinxupquote{Double.NegativeInfinity}}, and \sphinxcode{\sphinxupquote{Double.NaN}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
There is no such neat system for showing off small inaccuracies in \sphinxcode{\sphinxupquote{double}}
arithmetic accumulating
due to limited precision.  These inaccuracies \sphinxstyleemphasis{still} happen silently.
\end{sphinxadmonition}

\index{numeric type range@\spxentry{numeric type range}}\index{range of numeric types@\spxentry{range of numeric types}}\index{byte type@\spxentry{byte type}}\index{short type@\spxentry{short type}}\index{type@\spxentry{type}!byte and short@\spxentry{byte and short}}\ignorespaces 

\subsection{Numeric Types and  Limits}
\label{\detokenize{data/types-and-conversions:numeric-types-and-limits}}\label{\detokenize{data/types-and-conversions:numeric-type-limits}}\label{\detokenize{data/types-and-conversions:index-4}}
\sphinxAtStartPar
The listing below shows how the storage size in bits translates into the limits
for various numerical types.  We will not discuss or use \sphinxcode{\sphinxupquote{short}},
\sphinxcode{\sphinxupquote{byte}} or \sphinxcode{\sphinxupquote{float}} further.
\begin{description}
\sphinxlineitem{long}
\sphinxAtStartPar
64 bits; range \sphinxhyphen{}9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

\sphinxlineitem{int}
\sphinxAtStartPar
32 bits; range \sphinxhyphen{}2,147,483,648 to 2,147,483,647

\sphinxlineitem{short}
\sphinxAtStartPar
16 bits; range \sphinxhyphen{}32,768 to 32,767

\sphinxlineitem{byte}
\sphinxAtStartPar
8 bits; range 0 to 255 (no negative values)

\sphinxlineitem{double}
\sphinxAtStartPar
64 bits; maximum magnitude: \(1.7976931348623157(10^{308})\);
about 15 digits of accuracy

\sphinxlineitem{float}
\sphinxAtStartPar
32 bits; maximum magnitude: \(3.402823(10^{38})\); about 7 digits of accuracy

\sphinxlineitem{decimal}
\sphinxAtStartPar
128 bits; maximum value: 79228162514264337593543950335;
28 digits of accuracy;  can exactly represents decimal values
for financial operations; briefly discussed in \sphinxstyleemphasis{optional}
{\hyperref[\detokenize{classes/overload-op:decimal-type}]{\sphinxcrossref{\DUrole{std,std-ref}{Decimal Type}}}}.

\sphinxlineitem{char}
\sphinxAtStartPar
See {\hyperref[\detokenize{data/types-and-conversions:integer-char}]{\sphinxcrossref{\DUrole{std,std-ref}{char as integer}}}}.

\end{description}

\index{cast@\spxentry{cast}}\ignorespaces 

\subsection{Casting}
\label{\detokenize{data/types-and-conversions:casting}}\label{\detokenize{data/types-and-conversions:cast}}\label{\detokenize{data/types-and-conversions:index-5}}
\sphinxAtStartPar
While the mathematical ideas of 42 and 42.0 are the same, C\# has specific types.
There are various places where numerical types get converted automatically by C\#
or explicitly by the programmer.
A major issue is whether the new type can accurately represent the original value.

\sphinxAtStartPar
Going from \sphinxcode{\sphinxupquote{int}} to \sphinxcode{\sphinxupquote{double}} has no issue:  Any \sphinxcode{\sphinxupquote{int}} can be exactly
represented as a \sphinxcode{\sphinxupquote{double}}.  Code like the following is fine:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int i = 33;
csharp\PYGZgt{} double d = i;
csharp\PYGZgt{} double x;
csharp\PYGZgt{} x = 11;
csharp\PYGZgt{} double z = i + 2.5;
csharp\PYGZgt{} ShowVars();
int i = 33
double d = 33
double x = 11
double z = 35.5
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{double}} variable \sphinxcode{\sphinxupquote{d}} is initialized with the value of an \sphinxcode{\sphinxupquote{int}} variable.
The \sphinxcode{\sphinxupquote{double}} variable \sphinxcode{\sphinxupquote{x}} is assigned a value using an \sphinxcode{\sphinxupquote{int}} literal.
The \sphinxcode{\sphinxupquote{double}} variable \sphinxcode{\sphinxupquote{z}} is initialized with the value of a sum involving
both an \sphinxcode{\sphinxupquote{int}} variable and a \sphinxcode{\sphinxupquote{double}} literal.  As we have discussed before in
{\hyperref[\detokenize{data/arithmetic:arithmetic}]{\sphinxcrossref{\DUrole{std,std-ref}{Arithmetic}}}}, the \sphinxcode{\sphinxupquote{int}} is converted to a \sphinxcode{\sphinxupquote{double}} before the addition
operation is done.

\sphinxAtStartPar
The other direction for conversion is more problematic:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} double d= 2.7;
csharp\PYGZgt{} int i;
csharp\PYGZgt{} i = d;
\PYGZob{}interactive\PYGZcb{}(1,4): error CS0266: Cannot implicitly convert type
   \PYGZsq{}double\PYGZsq{} to \PYGZsq{}int\PYGZsq{}.
An explicit conversion exists (are you missing a cast?)
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{int}} \sphinxcode{\sphinxupquote{i}} cannot accurately hold the value 2.7.
Since the compiler does this checking, looking only at types, not values, this even
fails if the the \sphinxcode{\sphinxupquote{double}} happens to have an integer value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} double d = 2.0;
csharp\PYGZgt{} int i = d;
\PYGZob{}interactive\PYGZcb{}(1,4): error CS0266: Cannot implicitly convert type
   \PYGZsq{}double\PYGZsq{} to \PYGZsq{}int\PYGZsq{}.
An explicit conversion exists (are you missing a cast?)
\end{sphinxVerbatim}

\index{truncate in cast@\spxentry{truncate in cast}}\ignorespaces 
\sphinxAtStartPar
If you really want to possibly lose precision and convert a \sphinxcode{\sphinxupquote{double}} to
an \sphinxcode{\sphinxupquote{int}} result, you \sphinxstyleemphasis{can} do it, but you must be explicit, using a \sphinxstyleemphasis{cast}
as the csharp error messages suggest.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} double d= 2.7;
csharp\PYGZgt{} int i;
csharp\PYGZgt{} i = (int)d;
csharp\PYGZgt{} i;
2
\end{sphinxVerbatim}

\sphinxAtStartPar
The desired result type name in parentheses \sphinxcode{\sphinxupquote{(int)}} is a \sphinxstyleemphasis{cast}, telling the compiler
you really intend the conversion.  Look what is lost!  The cast does not
\sphinxstyleemphasis{round} to the nearest integer, it \sphinxstyleemphasis{truncates} toward 0, dropping the fractional
part, .7 here.

\index{Round function@\spxentry{Round function}}\ignorespaces 
\sphinxAtStartPar
Rounding is possible, but if you really want the \sphinxcode{\sphinxupquote{int}} type, it takes two steps,
because the function \sphinxcode{\sphinxupquote{Math.Round}} does round to a mathematical integer, but leaves
the type as \sphinxcode{\sphinxupquote{double}}!  To round \sphinxcode{\sphinxupquote{d}} to an \sphinxcode{\sphinxupquote{int}} result we could use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} i = (int)Math.Round(d);
csharp\PYGZgt{} i;
3
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also use an explicit cast from int to double.  This is generally not needed,
because of the automatic conversions, but there is one place where it is
important:  if you want \sphinxcode{\sphinxupquote{double}} division but have \sphinxcode{\sphinxupquote{int}} parts.  Here is a
quick artificial test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int sum = 14;
csharp\PYGZgt{} int n = 4;
csharp\PYGZgt{} double avg = sum/n;
csharp\PYGZgt{} avg;
3
\end{sphinxVerbatim}

\sphinxAtStartPar
Oops, integer division.  Instead, continue with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} avg = (double)sum/n;
csharp\PYGZgt{} avg;
3.5
\end{sphinxVerbatim}

\sphinxAtStartPar
We get the right decimal answer.

\sphinxAtStartPar
This is a bit more subtle than it may appear:
The cast to double, \sphinxcode{\sphinxupquote{(double)}}
is an operation in C\# and so it has a \sphinxstyleemphasis{precedence} like all operations.  Casting
happens to have precedence higher than any arithmetic operation, so the expression is
equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{avg}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sum}\PYG{p}{)}\PYG{o}{/}\PYG{n}{n}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
On the other hand, if we switch the order the other way with parentheses around the
division:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} avg = (double)(sum/n);
csharp\PYGZgt{} avg;
3
\end{sphinxVerbatim}

\sphinxAtStartPar
then working \sphinxstyleemphasis{one} step at a time, \sphinxcode{\sphinxupquote{(sum/n)}} is \sphinxstyleemphasis{integer} division,
with result 3.  It is the 3 that is then cast to a double (too late)!

\sphinxAtStartPar
See the appendix {\hyperref[\detokenize{appendix/precedence:precedence}]{\sphinxcrossref{\DUrole{std,std-ref}{Precedence of Operators}}}}, listing all C\# operations discussed in this book.

\index{type@\spxentry{type}!char@\spxentry{char}}\index{char@\spxentry{char}}\ignorespaces 

\subsection{Type char}
\label{\detokenize{data/types-and-conversions:type-char}}\label{\detokenize{data/types-and-conversions:index-8}}\label{\detokenize{data/types-and-conversions:id4}}
\sphinxAtStartPar
The type for an individual character is \sphinxcode{\sphinxupquote{char}}.  A \sphinxcode{\sphinxupquote{char}} literal value is
a \sphinxstyleemphasis{single} character enclosed in \sphinxstyleemphasis{single} quotes, like \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}} or \sphinxcode{\sphinxupquote{\textquotesingle{}\$\textquotesingle{}}}.
The literal for a
single quote character itself and the literal for a newline use
\sphinxstyleemphasis{escape codes}, like in {\hyperref[\detokenize{data/strings2:strings2}]{\sphinxcrossref{\DUrole{std,std-ref}{String Special Cases}}}}:
The literals are \sphinxcode{\sphinxupquote{\textquotesingle{}\textbackslash{}\textquotesingle{}\textquotesingle{}}} and \sphinxcode{\sphinxupquote{\textquotesingle{}\textbackslash{}n\textquotesingle{}}} respectively.

\sphinxAtStartPar
Be careful to distinguish a \sphinxcode{\sphinxupquote{char}} literal like \sphinxcode{\sphinxupquote{\textquotesingle{}A\textquotesingle{}}}
from a string literal \sphinxcode{\sphinxupquote{"A"}}.

\index{Unicode@\spxentry{Unicode}}\ignorespaces \phantomsection\label{\detokenize{data/types-and-conversions:integer-char}}
\sphinxAtStartPar
\sphinxstylestrong{Char as integer}:  Though the \sphinxcode{\sphinxupquote{char}} type has character literals
and prints as a character,
internally a \sphinxcode{\sphinxupquote{char}} is a \sphinxstyleemphasis{type of integer}, stored in 16 bits,
with the correspondence
between numeric codes and characters given by the \sphinxstyleemphasis{Unicode} standard.
Unicode allows special symbol characters and alphabets of many languages.
We will stick to the standard American keyboard for these characters.

\sphinxAtStartPar
Besides different alphabets, Unicode also has characters for all sorts of
symbols: emoticons, chess pieces, advanced math….  See
\sphinxurl{http://www.unicode.org/charts}.  All the symbols can be represented as escape
codes in C\#, starting with \sphinxcode{\sphinxupquote{\textbackslash{}u}} followed by 4 hexadecimal digits.  For example
\sphinxcode{\sphinxupquote{\textbackslash{}u262F}} produces a yin\sphinxhyphen{}yang symbol.

\sphinxAtStartPar
We mention the \sphinxcode{\sphinxupquote{char}} type being numeric mostly because of errors
that you can make that would otherwise be hard to figure out.  This code does
not concatenate the \sphinxcode{\sphinxupquote{char}} symbols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(\PYGZsq{}A\PYGZsq{} + \PYGZsq{}\PYGZhy{}\PYGZsq{});
110
\end{sphinxVerbatim}

\sphinxAtStartPar
What?
We mentioned that modern computers are set up to easily work with the \sphinxcode{\sphinxupquote{int}}
type.  In arithmetic with \sphinxstyleemphasis{smaller} integral types the operands are first
automatically converted to type \sphinxcode{\sphinxupquote{int}}.
An \sphinxcode{\sphinxupquote{int}} sum is an \sphinxcode{\sphinxupquote{int}}, and that is
what is printed.

\sphinxAtStartPar
You can look at the numeric values inside a \sphinxcode{\sphinxupquote{char}} with a cast!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} (int)\PYGZsq{}A\PYGZsq{};
65
csharp\PYGZgt{} (int)\PYGZsq{}\PYGZhy{}\PYGZsq{};
45
\end{sphinxVerbatim}

\sphinxAtStartPar
So the earlier 110 is correct:  65 + 45 = 110.

\sphinxAtStartPar
For completeness:
It is also possible to cast from small \sphinxcode{\sphinxupquote{int}} back to \sphinxcode{\sphinxupquote{char}}.
This may be useful for dealing with the alphabet
in sequence (or simple classical cryptographic codes):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} \PYGZsq{}A\PYGZsq{} + 1;
66
csharp\PYGZgt{} (char)(\PYGZsq{}A\PYGZsq{} + 1);
\PYGZsq{}B\PYGZsq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The capital letter one place after A is B.

\index{type@\spxentry{type}!Boolean or bool@\spxentry{Boolean or bool}}\index{Boolean or bool@\spxentry{Boolean or bool}}\ignorespaces 

\subsection{Type Boolean or bool}
\label{\detokenize{data/types-and-conversions:type-boolean-or-bool}}\label{\detokenize{data/types-and-conversions:type-boolean}}\label{\detokenize{data/types-and-conversions:index-10}}
\sphinxAtStartPar
There is one more very important value type, that we introduce here
for completeness, though we will not use it until
{\hyperref[\detokenize{decisions/decisions:if-statements}]{\sphinxcrossref{\DUrole{std,std-ref}{Decisions}}}}.
Logical conditions are either true or false.  The type with just these
two values is \sphinxstyleemphasis{Boolean}, or \sphinxstyleemphasis{bool} for short.  The
type is named after George Boole, who invented what we now call
\sphinxstyleemphasis{Boolean algebra}.  Though it seemed like a useless mathematical curiosity
when Boole invented it, a century later Boolean algebra turned out to be
at the heart of the implementation of computer hardware.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The Boolean literals are \sphinxcode{\sphinxupquote{true}} and \sphinxcode{\sphinxupquote{false}}, with \sphinxstyleemphasis{no} quotes
around them.
\end{sphinxadmonition}

\sphinxAtStartPar
With quotes they would be of type string, not Boolean!


\subsection{Overflow to Positive Exercise}
\label{\detokenize{data/types-and-conversions:overflow-to-positive-exercise}}
\sphinxAtStartPar
We gave an example above in {\hyperref[\detokenize{data/types-and-conversions:type-int}]{\sphinxcrossref{\DUrole{std,std-ref}{Type int}}}},
adding two positive \sphinxcode{\sphinxupquote{int}} values and
clearly having an error, since the result was negative.  Declare
and initialize two positive \sphinxcode{\sphinxupquote{int}} variables \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}.  Experiment
with the initializations so
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Their product is too big to fit in an \sphinxcode{\sphinxupquote{int}} AND

\item {} 
\sphinxAtStartPar
The wrong overflow result for \sphinxcode{\sphinxupquote{x*y}} is \sphinxstyleemphasis{positive}, not negative.

\end{enumerate}

\sphinxstepscope

\index{problem solving@\spxentry{problem solving}!strategy@\spxentry{strategy}}\ignorespaces 

\section{Learning to Solve Problems}
\label{\detokenize{data/learning-to-problem-solve:learning-to-solve-problems}}\label{\detokenize{data/learning-to-problem-solve:learn-solve}}\label{\detokenize{data/learning-to-problem-solve:index-0}}\label{\detokenize{data/learning-to-problem-solve::doc}}
\sphinxAtStartPar
This section might have been placed earlier,
but from reading all the way to here,
you should realize that you will have a \sphinxstyleemphasis{lot} of data and concepts to deal with.

\sphinxAtStartPar
The manner in which you deal with all the data and ideas is very important
for effective learning.
It might be rather different than what you needed if you were in a situation
where \sphinxstyleemphasis{rote} recall is the main important thing.

\sphinxAtStartPar
Different learning styles mean different things are useful to different people.
Consider what is mentioned here and try out some approaches.

\sphinxAtStartPar
The idea of this course is \sphinxstyleemphasis{not} to regurgitate the book, but to learn to solve problems
(generally involving producing a computer program).
In this highly connected and wired world
you have access to all sorts of data.  The data is not an end in itself, the question is
\sphinxstyleemphasis{doing} the right things with the tools out there to solve a new creative problem.

\sphinxAtStartPar
In this course there is a lot of data tied into syntax and library function names and ….
It can seem overwhelming.  It need not be. Take a breath.

\sphinxAtStartPar
First basic language syntax:  When learning any new language, there is a lot to take in.
We introduce C\# in chunks.  For a while there will always be the new current topic coming.
You do NOT need to memorize \sphinxstyleemphasis{everything} immediately!
\begin{itemize}
\item {} 
\sphinxAtStartPar
Some things that you use rarely, you may never memorize, like,
“What is the exact maximum magnitude of a \sphinxcode{\sphinxupquote{double}}?”
At \sphinxstyleemphasis{some} point that might be useful.
Can you find it?  It happens to be in {\hyperref[\detokenize{data/types-and-conversions:numeric-type-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{Numeric Types and  Limits}}}}.
It is also in online .Net documentation
that you can Google or bookmark.

\item {} 
\sphinxAtStartPar
Some things you will use all the time, but of course they start off as new and maybe strange.
Knowing where to go to check is still useful but not sufficient. For much\sphinxhyphen{}used material
that you do not find yourself absorbing immediately,
consider writing down a summary of the current topic.
Both thinking of a summary and writing help reinforce things and get you to remember faster.
Also, if you have the current things of interest summarized in one place, they are easy to look
up!

\item {} 
\sphinxAtStartPar
If you need some syntax to solve a simple early problem,
first try to remember the syntax, then check.  With frequently
used material and with this sort of repetition,
most everyone will remember most everything shortly.  If there are a few things
that just do not stick, keep them in your list.  Then go on to new material.  The list of
what you need to check on will keep changing as you get more experience and get to more topics.
If you keep some of the old lists, you will be amazed how much stuff that you sweated over,
is later ho\sphinxhyphen{}hum or automatic.

\item {} 
\sphinxAtStartPar
In the earliest exercises
the general steps that you need should be pretty apparent,
and you can just concentrate on
translating simple ideas into C\# syntax
(mostly from the material most recently introduced).
In this case the focus is mostly on syntax.

\end{itemize}

\sphinxAtStartPar
Memorizing syntax is not going to directly get you to solve real problems.  In any domain:
programming, construction, organizing political action, …, you need to analyze the problem
and figure out a sequence of steps, knowing what \sphinxstyleemphasis{powers and resources you have}.

\sphinxAtStartPar
For example with political action:
if you know demonstrations are possible in front of City Hall, you can make a high\sphinxhyphen{}level
plan to have one, but then you have to attend to details:  Do you need city permission?
Who do you call? … You do not have to have all that in your head when coming up with the
idea of the demonstration, but you better know how to find the information allowing you
to follow through to make it happen.

\sphinxAtStartPar
With programming, syntax details are like the details above: not the first thing to think of,
and maybe not things that you have memorized.  What \sphinxstyleemphasis{is} important to break down a problem
and plan a solution, is to know the basic \sphinxstyleemphasis{capacities} you have in programming.  As you get
into larger projects and have more experience, “basic capacities” will be bigger and bigger ideas.
For now, as beginners, based on the sections of the book so far,
it is important to know:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You can get information from a user and return information via keyboard and screen.

\item {} 
\sphinxAtStartPar
You can remember and recall and use information using variables.

\item {} 
\sphinxAtStartPar
You can deal directly with various kinds of data: numbers and strings at this point.

\item {} 
\sphinxAtStartPar
There are basic operations you can do with the data (arithmetic, concatenating string,
converting between data types).

\item {} 
\sphinxAtStartPar
At a slightly higher level, you might already have the idea of basic recurring patterns,
like solving a straightforward problem with \sphinxstylestrong{input\sphinxhyphen{}processing\sphinxhyphen{}output}.

\item {} 
\sphinxAtStartPar
You will see shortly that you have more tools:  decision, repetition, more built\sphinxhyphen{}in
ways to deal with data (like more string operations shortly), creating your own data types….

\end{itemize}

\sphinxAtStartPar
At slightly more detailed level, \sphinxstyleemphasis{after} thinking of overall plans:
\begin{itemize}
\item {} 
\sphinxAtStartPar
There are multiple kinds of number types.  What is appropriate for your use?

\item {} 
\sphinxAtStartPar
There are various ways of formatting and presenting data to output. What shall you use?

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Finally}, you actually need to translate specific instructions into C\# (or whatever language).
Of course if you remember the syntax, then this level of step is pretty automatic.
Even if you do \sphinxstyleemphasis{not} remember, you have something very specific to look up!  If you are
keeping track of your sources of detailed information, this is hopefully only one further
step.

\sphinxAtStartPar
Contrast this last\sphinxhyphen{}step translation with the earlier creative organizational process:
If you do not have \sphinxstyleemphasis{in your head} an idea of the basic tools available,
how are you going to plan?
How are you going to even know how to start looking something up?

\sphinxAtStartPar
So far basic ideas for planning a solution has been discussed, and you can see that you do not
need to think of everything at once or have everything equally prominent in your brain.

\sphinxAtStartPar
Also, when you are coding, you do not need to to have all the details of syntax in your head,
even for the \sphinxstyleemphasis{one} instruction that you are dealing with at the moment.  You want to have
the main idea, and you want to get it written down, but once it is written down, you can make
multiple passes, examining and modifying what you have.  For example, Dr. Harrington does a lot of
Python programming, where semicolons are not needed.  He can get the main ideas down
in C\# without the required
semicolons.  He \sphinxstyleemphasis{could} wait for the compiler to stop him on every one that is missed,
and maybe have the compiler misinterpret further parts, and give bogus error messages.
\sphinxstyleemphasis{More effective} is having
a list of things to concentrate on in later rounds of manual checking.
For example, checking for semicolons: Scan the statements;
look at the ends; add semicolons where missing.  You can go through a large program very
quickly and efficiently doing this and have one less thing to obsess about when first writing.

\sphinxAtStartPar
This list of things\sphinxhyphen{}to\sphinxhyphen{}check\sphinxhyphen{}separately should come from experience.
Keep track of the errors you make.  Some people even keep an error log.
What errors keep occurring?
Make entries in things\sphinxhyphen{}to\sphinxhyphen{}check\sphinxhyphen{}separately,
so you will make scans checking for the specific things that you frequently slip up on.

\sphinxAtStartPar
This things\sphinxhyphen{}to\sphinxhyphen{}check\sphinxhyphen{}separately list, too, will evolve.  Revise it occasionally.
If Dr. Harrington does enough
concentrated C\#, \sphinxstyleemphasis{maybe} he will find that entering semicolons becomes automatic,
and he can take the separate round of semicolon checking off his list….

\sphinxAtStartPar
What to do \sphinxstyleemphasis{after} you finish an exercise is important, too.  The natural thing psychologically,
particularly if you had a struggle, is to think, “Whew, outta here!!!!”

\sphinxAtStartPar
On something that came automatically or flowed smoothly, that is not a big deal \sphinxhyphen{}
you will probably get it just as fast the next time. If you had a hard time and only eventually
got to success, you may be doing yourself a disservice with “Whew, outta here!!!”

\sphinxAtStartPar
We have already mentioned how not everything is equally important, and some things are more
important to keep in your head than others.  The same idea applies to all the steps in solving
a possibly long problem.  Some parts were easy; some were hard; there may have been many steps.
If all of that goes into your brain in one continuous stream of stuff that you
remember at the same level, then you are going to leave important nuggets mixed in
with an awful lot of unimportant
and basically useless information, and have it all fade into oblivion, or be next to
impossible to cycle through looking for the nuggets.
Why do the problem anyway if you are just going to bury important information further
down in your brain?

\sphinxAtStartPar
What is important?  The most obvious thing you will need at a higher level of recall is what
\sphinxstyleemphasis{just messed you up}, what you missed until doing this problem:  After finishing the
actual problem, \sphinxstyleemphasis{actively} follow up and ask yourself:
\begin{itemize}
\item {} 
\sphinxAtStartPar
What did I get in the end that I was missing initially? What was the connection I made?

\item {} 
\sphinxAtStartPar
Does this example fit in to some larger idea/abstraction/generalization in a way that
I did not see before?

\item {} 
\sphinxAtStartPar
How am I going to look at this so I can make a similar connection
in a similar (or maybe only partly similar) problem?

\item {} 
\sphinxAtStartPar
Is there a kernel here that I can think of as a new tool in my bag of tricks?

\end{itemize}

\sphinxAtStartPar
Your answers to these questions are the most important things to take away from your
recent hard work.
The extra consideration puts them more in
the “priority” part of your brain, so you can really learn from your effort.  When you need
the important ideas
next, you do not need to play through all the details of
the stuff you did to solve the exact earlier problem.

\sphinxAtStartPar
Keep coming back to this section and check up on your process:  It is really important.

\sphinxstepscope

\index{labs@\spxentry{labs}!division sentences@\spxentry{division sentences}}\ignorespaces 

\section{Lab: Division Sentences}
\label{\detokenize{data/lab-division-sentences:lab-division-sentences}}\label{\detokenize{data/lab-division-sentences:lab-division}}\label{\detokenize{data/lab-division-sentences:index-0}}\label{\detokenize{data/lab-division-sentences::doc}}

\subsection{Overview}
\label{\detokenize{data/lab-division-sentences:overview}}
\sphinxAtStartPar
In this lab, we’re going to begin to look at what makes computers \sphinxstyleemphasis{do
their thing} so to speak.

\sphinxAtStartPar
It is rather insightful to look at how Wikipedia summarizes the
computer:
\begin{quote}

\sphinxAtStartPar
A computer is a programmable machine designed to sequentially and
automatically carry out a sequence of arithmetic or logical
operations. The particular sequence of operations can be changed
readily, allowing the computer to solve more than one kind of
problem.
\end{quote}

\sphinxAtStartPar
In other words, a computer is a calculator\textendash{}and much
more. Furthermore, the definition of a computer goes on to include
access to storage and peripherals, such as consoles (graphical displays),
printers, and the network. We already got a glimpse of this access
when we explored \sphinxcode{\sphinxupquote{Console.WriteLine}} in the first lab exercise.

\sphinxAtStartPar
We have discussed all the syntax and concepts needed in recent sections
on {\hyperref[\detokenize{data/arithmetic:arithmetic}]{\sphinxcrossref{\DUrole{std,std-ref}{Arithmetic}}}}, {\hyperref[\detokenize{data/variables:variables-and-assignment}]{\sphinxcrossref{\DUrole{std,std-ref}{Variables and Assignment}}}},
{\hyperref[\detokenize{data/io:io}]{\sphinxcrossref{\DUrole{std,std-ref}{Combining Input and Output}}}}, and {\hyperref[\detokenize{data/types-and-conversions:cast}]{\sphinxcrossref{\DUrole{std,std-ref}{Casting}}}}.  Also you can make things easier for yourself using
{\hyperref[\detokenize{data/writeline-substitution:substitution-in-writeline}]{\sphinxcrossref{\DUrole{std,std-ref}{Substitutions in Console.WriteLine}}}} to format output.

\sphinxAtStartPar
Before writing your final program, you might like to review some of
the parts, testing in the {\hyperref[\detokenize{data/arithmetic:csharp}]{\sphinxcrossref{\DUrole{std,std-ref}{Csharp}}}} program, so you get immediate feedback
for the calculations.


\subsection{Requirements}
\label{\detokenize{data/lab-division-sentences:requirements}}
\sphinxAtStartPar
We want to develop a program that can do the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Prompt the user for input of two integers, which we will call
\sphinxstyleemphasis{numerator} and \sphinxstyleemphasis{denominator}. For clarity, we are only looking at
integers, because this assignment is about rational numbers. A
rational number can always be expressed as a quotient of two integers.

\item {} 
\sphinxAtStartPar
Calculate the floating point division result (e.g. 10/4 = 2.5).

\item {} 
\sphinxAtStartPar
Calculate the quotient and the remainder (e.g. 10/4 = 2 with a
remainder of 2 = 2 2/4).

\end{itemize}

\sphinxAtStartPar
Your final program should work as in this sample run, and use the same
labeled format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Please enter the numerator? 14
Please enter the denominator? 4
Integer division result = 3 with a remainder 2
Floating point division result = 3.5
The result as a mixed fraction is 3 2/4.
\end{sphinxVerbatim}

\sphinxAtStartPar
For this lab the example format \sphinxcode{\sphinxupquote{3 2/4}} is sufficient.
It would look better as \sphinxcode{\sphinxupquote{3 1/2}}, but a general
efficient way to reduce fractions to
lowest terms is not covered until the section on the algorithm {\hyperref[\detokenize{while/gcdexamples:gcd}]{\sphinxcrossref{\DUrole{std,std-ref}{Greatest Common Divisor}}}}.

\sphinxAtStartPar
To do the part requiring a decimal quotient you are going to need to have a
\sphinxcode{\sphinxupquote{double}} value, though your original data was of type \sphinxcode{\sphinxupquote{int}}.
You could use the approach in {\hyperref[\detokenize{data/types-and-conversions:cast}]{\sphinxcrossref{\DUrole{std,std-ref}{Casting}}}}, with an explicit cast.
Another approach mentioned in that section was to do the cast implicitly
in a \sphinxcode{\sphinxupquote{double}} declaration with initialization from an \sphinxcode{\sphinxupquote{int}}.  If we
already had \sphinxcode{\sphinxupquote{int}} variables, \sphinxcode{\sphinxupquote{numerator}} and
\sphinxcode{\sphinxupquote{denominator}}, that were previously assigned their values,
we could use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{numeratorDouble}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{numerator}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// implicit cast}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{quotientDouble}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{numeratorDouble}\PYG{o}{/}\PYG{n}{denominator}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Remember: at least one operand in a quotient must be \sphinxcode{\sphinxupquote{double}}
to get a \sphinxcode{\sphinxupquote{double}} result.

\sphinxAtStartPar
To help you
get started with your program code,
we provided this simple \sphinxstyleemphasis{stub} in the example file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/do\_the\_math\_stub/do\_the\_math.cs}{do\_the\_math\_stub/do\_the\_math.cs}.
You are encouraged to copy this into your own project as reviewed
after the lab in {\hyperref[\detokenize{data/lab-division-sentences:xamarinstudio-reminders}]{\sphinxcrossref{\DUrole{std,std-ref}{Xamarin Studio Reminders and Fixes}}}}.

\index{comment@\spxentry{comment}}\index{/* ... */ comment@\spxentry{/* ... */ comment}}\index{*/ end /* comment@\spxentry{*/ end /* comment}}\index{// comment@\spxentry{// comment}}\ignorespaces 
\sphinxAtStartPar
The body of \sphinxcode{\sphinxupquote{Main}} presently contains only \sphinxstyleemphasis{comments}, skipped by the compiler.
We illustrate two forms (being inconsistent for your information only):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{//}} to the end of the \sphinxstyleemphasis{same} line

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/*}} to \sphinxcode{\sphinxupquote{*/}} through any number of lines.

\end{itemize}

\sphinxAtStartPar
Save the stub in a project of
your own and replace the comments with your code to complete it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{DoTheMath}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Lab stub}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+cm}{/* Prompt the user for the numerator using}
\PYG{c+cm}{         Console.Write().}

\PYG{c+cm}{         Convert this text into int numerator using}
\PYG{c+cm}{         int.Parse().}

\PYG{c+cm}{         Do the same for the denominator.}

\PYG{c+cm}{         Calculate quotient and remainder (as integers)}
\PYG{c+cm}{         Use Console.WriteLine() to display the labels}
\PYG{c+cm}{         as illustrated in the sample output in the lab.}

\PYG{c+cm}{         Do the same but using floating point division}
\PYG{c+cm}{         and not doing the remainder calculation.}

\PYG{c+cm}{         Create the sentence with the mixed fraction.}
\PYG{c+cm}{         Be careful of the places there are *not* spaces.}
\PYG{c+cm}{      */}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Be sure to run it and test it thoroughly. Show your output to a TA.

\index{Xamarin Studio@\spxentry{Xamarin Studio}!empty project \sphinxhyphen{} input not allowed error@\spxentry{empty project \sphinxhyphen{} input not allowed error}}\index{Xamarin Studio@\spxentry{Xamarin Studio}!file not in project error@\spxentry{file not in project error}}\index{Xamarin Studio@\spxentry{Xamarin Studio}!solution pad missing@\spxentry{solution pad missing}}\index{solution pad in Xamarin missing@\spxentry{solution pad in Xamarin missing}}\index{input not allowed in Xamarin@\spxentry{input not allowed in Xamarin}}\index{Main not found in Xamarin@\spxentry{Main not found in Xamarin}}\ignorespaces 

\subsection{Xamarin Studio Reminders and Fixes}
\label{\detokenize{data/lab-division-sentences:xamarin-studio-reminders-and-fixes}}\label{\detokenize{data/lab-division-sentences:xamarinstudio-reminders}}\label{\detokenize{data/lab-division-sentences:index-2}}
\sphinxAtStartPar
Be careful to open your Xamarin Studio solution and add a new \sphinxstylestrong{C\# Console project} to
it, and add your new file directly into the project (through the Solution pad).
There are two main places to
mess up here.  We emphasize them and mention fixes if you make the easy mistakes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
It is easy to select Empty Project instead of C\# and Console Project.  If you
do that, a correct program will compile successfully, but it will run
in limbo, with no console attached to it, and all \sphinxcode{\sphinxupquote{Console.ReadLine()}} calls
return \sphinxcode{\sphinxupquote{null}}, which is likely to make the program have a run\sphinxhyphen{}time error.
One way to fix it:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If you discovered this while running your program, there is no good access to
the running process.  (You lack a console!)
In this case you need to close your solution, ending the running process,
and open the solution again.

\item {} 
\sphinxAtStartPar
Double click on the project in the Solution Pad
(if that does anything, or right\sphinxhyphen{}click it and select Options).
An elaborate Project Options dialog window appears.

\item {} 
\sphinxAtStartPar
In the left pane under Run, select General.
In the right pane, two check boxes should appear.  Make sure you have the first
checked: Run on external console.  That should check the second one
automatically.  Close the window and you should be set.

\sphinxAtStartPar
Be careful, it is possible to uncomment the second checkbox,
which makes your execution console close instantly at the end
of your program, so you miss any last thing printed.  Recheck if
necessary.

\end{itemize}

\item {} 
\sphinxAtStartPar
Another common error is to proceed like with most text processors,
and go to the the top Xamarin Studio menu (not in the the Solution pad)
and open a file using the application’s File menu item,
and choose to open and edit a new file for your program.
This \sphinxstyleemphasis{does not put the file in your Xamarin project.} Hence
\sphinxstylestrong{you cannot} \sphinxstyleemphasis{run} \sphinxstylestrong{this program from Xamarin Studio.}

\sphinxAtStartPar
The file you edit must show in the \sphinxstyleemphasis{solution pad} in Xamarain Studio, as
a source file in your project.  If you have a separate project set up,
but without this file or any other showing in the Solutions pad, an attempt to
run the project will say no \sphinxcode{\sphinxupquote{Main}} method (in fact no program at all).
The fix:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You will shortly need to navigate in an operating system open file dialog to where
you put the file created from the File menu.  If you do not
remember where that was, a good trick is to click in the edit window of the file
and then go to the File menu and select Save As (not Save).  The dialog should
show where the file currently is.  Cancel the dialog.

\item {} 
\sphinxAtStartPar
Right click on the project in the Solution pad where you \sphinxstyleemphasis{do} wnat the program.
Choose Add and then
Add Files….  Browse to where the file is, and select it; click Open.
Unless you have some
reason to keep a copy in the original place, select Move, and Ok.
Now the orphaned file is moved into your project.  You should see it list
under the project in the Solution pad.
You can proceed to edit and run it.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Always use the Solution pad to add files to your project and open them to edit.}

\item {} 
\sphinxAtStartPar
If you lose the display of the Solution pad somehow, you can go to the View menu,
select Pads, and then select Solution.

\end{enumerate}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{data/reviewdataop:chapter-review-questions}}\label{\detokenize{data/reviewdataop::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Most of C\# arithmetic is just like normal math.  The exceptions are
most important:  What are they?

\item {} 
\sphinxAtStartPar
What are the consequences of numerical value types each being stored in
a fixed amount of memory space?

\item {} 
\sphinxAtStartPar
What is the order of operations if several of the same level,
are chained together like \sphinxcode{\sphinxupquote{x + y + z}}?
This can matter in C\# (including in a question below).

\item {} 
\sphinxAtStartPar
Which of these individual
two\sphinxhyphen{}line fragments could fit into a legal C\# program?
Explain:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{w}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{w}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}

\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{;}

\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}hello\PYGZdq{}}\PYG{p}{;}

\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3.5}
\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}

\PYG{n}{q}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{q}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
For the legal pairs above, what could the type of the variable have been
declared?  You can check them in csharp, giving the declaration first.

\item {} 
\sphinxAtStartPar
What are the final values of \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}  after this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Test in csharp after you have decided.

\item {} 
\sphinxAtStartPar
Which of these expressions are legal in C\#?
Think of the results.
Explain.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}b\PYGZdq{}}
\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}b\PYGZsq{}}
\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}
\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Think first; try in csharp; reconsider if necessary.

\item {} 
\sphinxAtStartPar
Write a single \sphinxcode{\sphinxupquote{WriteLine}} statement that would produce output
on two separate lines, not one.  Accomplish the same thing a second time
with fundamentally
different syntax.

\item {} 
\sphinxAtStartPar
What is printed?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}1\PYGZcb{} \PYGZob{}0\PYGZcb{} \PYGZob{}2\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}B\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}or not\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Which of these casts is necessary, and which could be left out
(and be legal and mean the same thing)? Before testing,
think what the values of the variables will be
for the first two or three:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{l+m}{5.8}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{l+m}{6}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope


\chapter{Defining Functions of your Own}
\label{\detokenize{functions/functions:defining-functions-of-your-own}}\label{\detokenize{functions/functions:defining-own-functions}}\label{\detokenize{functions/functions::doc}}
\sphinxstepscope

\index{function@\spxentry{function}!definition@\spxentry{definition}}\ignorespaces 

\section{A First Function Definition}
\label{\detokenize{functions/firstfunc:a-first-function-definition}}\label{\detokenize{functions/firstfunc:a-first-function}}\label{\detokenize{functions/firstfunc:index-0}}\label{\detokenize{functions/firstfunc::doc}}
\sphinxAtStartPar
If you know it is the birthday of a friend, Emily, you might tell
those gathered with you to sing “Happy Birthday to Emily”.

\sphinxAtStartPar
We can make C\# display the song. \sphinxstyleemphasis{Read}, and run if you like,
the example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday1/birthday1.cs}{birthday1/birthday1.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Birthday1}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear Emily.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the song is just a part of the \sphinxcode{\sphinxupquote{Main}} method that is in
every program.

\sphinxAtStartPar
Note that we are using a function already provided to us,
\sphinxcode{\sphinxupquote{Console.WriteLine}}.  We can use it over and over, wherever we like.
We can alter its behavior by including a different parameter.
Now we look further at writing and using your own functions.

\sphinxAtStartPar
If we
want this song to be just part of a larger program, and be able to refer
to it repeatedly and easily, we might like
to package it separately.
You would probably not repeat the whole song to let others know
what to sing. You would give a request to sing via a descriptive
name like “Happy Birthday to Emily”.

\sphinxAtStartPar
In C\# we can also give a name like \sphinxcode{\sphinxupquote{HappyBirthdayEmily}}, and
associate the name with whole song by using a new
\sphinxstyleemphasis{function definition}, also called a \sphinxstyleemphasis{method}. We will see many variations
on method definitions.  Later we will see definitions that are
attached to a particular object.
For now the simpler cases do not involve creating a type of object,
but there is an extra word, \sphinxcode{\sphinxupquote{static}},
needed to distinguish a function definition
\sphinxstyleemphasis{not} attached to  on object.
We will also shortly look at functions more like
the functions from math class, that produce or \sphinxstyleemphasis{return} a value.  In
this simple case we will not deal with returning a value.
This also requires a special word in the heading:  \sphinxcode{\sphinxupquote{void}}.  A \sphinxcode{\sphinxupquote{void}}
function will just be a shorthand name for something to do, a procedure
to follow, in this case
printing out the Happy Birthday song for Emily.  (Note that
the \sphinxcode{\sphinxupquote{Main}} method for a program is also \sphinxcode{\sphinxupquote{static void}}.
This \sphinxstyleemphasis{does} your whole program and is not attached to an object.)

\sphinxAtStartPar
\sphinxstyleemphasis{Read} for now:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Birthday2}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear Emily.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Hip hip hooray!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are several parts of the syntax for a function definition to
notice:

\sphinxAtStartPar
Line 5: The \sphinxstyleemphasis{heading} starts with \sphinxcode{\sphinxupquote{static void}}, the name of the function,
and then parentheses.

\sphinxAtStartPar
A more general syntax for functions that just \sphinxstyleemphasis{do}
something is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{static void}} \sphinxstylestrong{FunctionName}\sphinxcode{\sphinxupquote{()}}
\item[] \sphinxcode{\sphinxupquote{\{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statements in the function body…
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
Recall the conventions in {\hyperref[\detokenize{data/typography:syntax-template-typography}]{\sphinxcrossref{\DUrole{std,std-ref}{Syntax Template Typography}}}}.

\sphinxAtStartPar
Lines 6\sphinxhyphen{}11: The remaining lines form the function \sphinxstyleemphasis{body}.  They are enclosed
in braces.  By convention the lines inside the braces are indented by a
consistent amount. Three spaces is a common indentation.

\sphinxAtStartPar
The whole definition does just that: \sphinxstyleemphasis{defines} the meaning of the
name \sphinxcode{\sphinxupquote{HappyBirthdayEmily}}, but it does not do anything else yet \sphinxhyphen{}
for example, the definition itself does not yet make anything be
printed. This is our first example of altering the order of
execution of statements from the normal sequential order. This is
important: the statements in the function \sphinxstyleemphasis{definition} are \sphinxstyleemphasis{not}
executed as C\# first passes over the lines.
The only part of a program that is automatically executed is \sphinxcode{\sphinxupquote{Main}}.
Hence \sphinxcode{\sphinxupquote{Main}} better refer to the newly defined function….

\sphinxAtStartPar
Look at the first statement inside Main, line 15:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the \sphinxcode{\sphinxupquote{static void}} of the function definition is missing,
but we still have the function name and parentheses.
When \sphinxcode{\sphinxupquote{Main}} is running, C\# goes back and looks up
the definition, and only then, executes the code inside the
function definition. The term for this action is a \sphinxstyleemphasis{function call}
or function \sphinxstyleemphasis{invocation}.  In this simple situation the format is
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{FunctionName}\sphinxcode{\sphinxupquote{()}}
\end{quote}

\sphinxAtStartPar
While the convention for variable identifiers is to start with a lowercase
letter, the convention for function names is to start with a capital letter.
Hence \sphinxcode{\sphinxupquote{HappyBirthdayEmily}}, not \sphinxcode{\sphinxupquote{happyBirthdayEmily}}.

\sphinxAtStartPar
Can you predict what the program will do?  Note the two function calls
to \sphinxcode{\sphinxupquote{HappyBirthdayEmily}}.  To see, load and run \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday2/birthday2.cs}{birthday2/birthday2.cs}.

\index{function@\spxentry{function}!execution sequence@\spxentry{execution sequence}}\index{execution sequence@\spxentry{execution sequence}!function@\spxentry{function}}\ignorespaces 
\sphinxAtStartPar
The \sphinxstyleemphasis{execution} sequence for the program is different from the
\sphinxstyleemphasis{textual} sequence.  Execution always starts in Main:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Line 13: Main is where execution starts, and initially proceeds
sequentially.

\item {} 
\sphinxAtStartPar
Line 15: the function is called while this location is
remembered.

\item {} 
\sphinxAtStartPar
Lines 5\sphinxhyphen{}11: Jump!  The code of the function is executed for the first
time, printing out the song.

\item {} 
\sphinxAtStartPar
End of line 15: Back from the function call; continue on.

\item {} 
\sphinxAtStartPar
Line 16:  Just to mix things up, print out a “Hip, hip, hooray”.

\item {} 
\sphinxAtStartPar
Line 17: the function is called again while this location is
remembered.

\item {} 
\sphinxAtStartPar
Lines 5\sphinxhyphen{}11: The function is executed again, printing out the song
again.

\item {} 
\sphinxAtStartPar
End of line 17: Back from the function call, but at this point
there is nothing more in \sphinxcode{\sphinxupquote{Main}}, and execution stops.

\end{enumerate}

\sphinxAtStartPar
Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

\sphinxAtStartPar
Understanding the jumping around in the code with function calls is
crucial.  Be sure you follow the sequence detailed above.  In particular,
be sure to distinguish function \sphinxstylestrong{definition} from function \sphinxstylestrong{call}.

\sphinxAtStartPar
If it also happens to be Andre’s birthday, we might define a
function \sphinxcode{\sphinxupquote{HappyBirthdayAndre}}, too. Think how to do that before
going on ….

\sphinxstepscope


\section{Multiple Function Definitions}
\label{\detokenize{functions/multfunc:multiple-function-definitions}}\label{\detokenize{functions/multfunc:id1}}\label{\detokenize{functions/multfunc::doc}}
\sphinxAtStartPar
Here is example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday3/birthday3.cs}{birthday3/birthday3.cs} where we add a function
\sphinxcode{\sphinxupquote{HappyBirthdayAndre}}, and call them both. Guess what happens, and
then load and try it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Birthday3}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{HappyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{HappyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear Emily.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{HappyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear Andre.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again, definitions are remembered and execution starts in \sphinxcode{\sphinxupquote{Main}}.
The order in which the function definitions are given does not matter
to C\#.  It is a human choice.  For variety I show \sphinxcode{\sphinxupquote{Main}} first.  This
means a human reading in order gets an overview of what is happening
by looking at Main, but does not know the details until reading the
definitions of the birthday functions.

\sphinxAtStartPar
Detailed order of execution:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Line 5: Start on \sphinxcode{\sphinxupquote{Main}}

\item {} 
\sphinxAtStartPar
Line 7. This location is remembered as execution jumps to
\sphinxcode{\sphinxupquote{HappyBirthdayEmily}}

\item {} 
\sphinxAtStartPar
Lines 11\sphinxhyphen{}17 are executed and Emily is sung to.

\item {} 
\sphinxAtStartPar
Return to the end of Line 7: Back from \sphinxcode{\sphinxupquote{HappyBirthdayEmily}}
function call

\item {} 
\sphinxAtStartPar
Line 8: Now \sphinxcode{\sphinxupquote{HappyBirthdayAndre}} is called as this location is
remembered.

\item {} 
\sphinxAtStartPar
Lines 19\sphinxhyphen{}25: Sing to Andre

\item {} 
\sphinxAtStartPar
Return to the end of line 8: Back from \sphinxcode{\sphinxupquote{HappyBirthdayAndre}}
function call, done with \sphinxcode{\sphinxupquote{Main}};
at the end of the program

\end{enumerate}

\sphinxAtStartPar
The calls to the birthday functions
\sphinxstyleemphasis{happen} to be in the same order as their definitions, but that is
arbitrary. If the two lines of the body of \sphinxcode{\sphinxupquote{Main}} were swapped,
the order of
operations would change, but if the order of the whole function
definitions were changed,
it would make no difference in execution.

\sphinxAtStartPar
Functions that you write can also call other functions you write.
In this case Main calls each of the birthday functions.

\index{compiler error@\spxentry{compiler error}!bad place for heading syntax@\spxentry{bad place for heading syntax}}\index{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}!matching@\spxentry{matching}}\index{function@\spxentry{function}!compiler error with heading@\spxentry{compiler error with heading}}\ignorespaces 
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
A common compiler error is caused by failing to match the braces
that wrap a function body.  A new function heading can only
exist outside all other function declarations and inside a class.
If you have too few or extra \sphinxcode{\sphinxupquote{\textquotesingle{}\}\textquotesingle{}}} you are likely to find
a perfectly fine looking function heading with an error,
for instance, about not
allowing \sphinxcode{\sphinxupquote{static}} here….
Check your earlier lack or excess of braces!
\end{sphinxadmonition}

\index{( )@\spxentry{( )}!matching@\spxentry{matching}}\index{{[} {]}@\spxentry{{[} {]}}!matching@\spxentry{matching}}\index{Xamarin Studio@\spxentry{Xamarin Studio}!delimiter matching@\spxentry{delimiter matching}}\ignorespaces 
\sphinxAtStartPar
Xamarin Studio, like other modern code editors, can show you
matching delimiters.  If you place your cursor immediately after a delimiter
\{ \} ( ) {[} {]}, the matching one should become highlighted.


\subsection{Poem Function Exercise}
\label{\detokenize{functions/multfunc:poem-function-exercise}}
\sphinxAtStartPar
Write a program, \sphinxcode{\sphinxupquote{poem.cs}}, that defines a function that
prints a \sphinxstyleemphasis{short} poem or song verse. Give a meaningful name to the
function. Have the program call the function three times,
so the poem or verse is repeated three times.

\sphinxstepscope

\index{function@\spxentry{function}!parameter@\spxentry{parameter}}\index{parameter@\spxentry{parameter}}\ignorespaces 

\section{Function Parameters}
\label{\detokenize{functions/funcparam:function-parameters}}\label{\detokenize{functions/funcparam:index-0}}\label{\detokenize{functions/funcparam:id1}}\label{\detokenize{functions/funcparam::doc}}
\sphinxAtStartPar
As a young child, you probably heard Happy Birthday sung to a
couple of people, and then you could sing to a new person, say
Maria, without needing to hear the whole special version with
Maria’s name in it word for word. You had the power of
\sphinxstyleemphasis{abstraction}. With examples like the versions for Emily and Andre,
you could figure out what change to make it so the song could be
sung to Maria!

\sphinxAtStartPar
Unfortunately, C\# is not that smart. It needs explicit rules.
If you needed to explain \sphinxstyleemphasis{explicitly} to someone how Happy Birthday
worked in general, rather than just by example, you might say
something like this:

\sphinxAtStartPar
First you have to be \sphinxstyleemphasis{given} a person’s name. Then you sing the
song with the person’s name inserted at the end of the third line.

\sphinxAtStartPar
C\# works something like that, but with its own syntax. The term
“person’s name” serves as a stand\sphinxhyphen{}in for the actual data that
will be used, “Emily”, “Andre”, or “Maria”. This is just like
the association with a variable name in C\#. “person’s name”
is not a legal C\# identifier, so we will use just \sphinxcode{\sphinxupquote{person}} as
this stand\sphinxhyphen{}in.  It will be a variable in the program,
so it needs a type in C\#.  The names are strings,
so the type of \sphinxcode{\sphinxupquote{person}} is \sphinxcode{\sphinxupquote{string}}.

\sphinxAtStartPar
In between the parentheses of the function definition heading, we insert the variable
name \sphinxcode{\sphinxupquote{person}}, preceded  by its type, \sphinxcode{\sphinxupquote{string}}.
Then in the body of the definition
of the function, \sphinxcode{\sphinxupquote{person}} is used in place of the real data for any
specific person’s name. Read and then run example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday4/birthday4.cs}{birthday4/birthday4.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Birthday4}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{HappyBirthday}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{person}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{person}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{HappyBirthday}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Emily\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{HappyBirthday}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Andre\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the definition heading for \sphinxcode{\sphinxupquote{HappyBirthday}}, \sphinxcode{\sphinxupquote{person}} is
referred to as a \sphinxstyleemphasis{parameter}, or a \sphinxstyleemphasis{formal parameter}. This
variable name is a \sphinxstyleemphasis{placeholder} for the real name of the person
being sung to.  In the definition we give instructions for singing
Happy Birthday \sphinxstyleemphasis{without} knowing the exact name of the person who might be sung to.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Main}} now has two calls to the same function,
but between the parentheses, where there was the \sphinxstylestrong{placeholder} \sphinxcode{\sphinxupquote{person}}
in the definition, now we have the \sphinxstylestrong{actual people} being sung to.
The value between the parentheses here in the function call
is referred to as an \sphinxstyleemphasis{argument} or \sphinxstyleemphasis{actual parameter} of the
function call. The argument supplies the actual data to be used in
the function execution. When the call is made, C\# does this by
associating the \sphinxstylestrong{formal} parameter name \sphinxcode{\sphinxupquote{person}} with the \sphinxstylestrong{actual}
parameter data, as in an assignment statement. In the first call,
this actual data is \sphinxcode{\sphinxupquote{"Emily"}}. We say the actual parameter value
is \sphinxstyleemphasis{passed} to the function for execution.

\sphinxAtStartPar
The execution in greater detail:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Lines 13: Execution starts in Main.

\item {} 
\sphinxAtStartPar
Line 15: Call to \sphinxcode{\sphinxupquote{HappyBirthday}}, with actual parameter
\sphinxcode{\sphinxupquote{"Emily"}}.

\item {} 
\sphinxAtStartPar
Line 5: \sphinxcode{\sphinxupquote{"Emily"}} is passed to the function, so
\sphinxcode{\sphinxupquote{person = "Emily"}}.

\item {} 
\sphinxAtStartPar
Lines 7\sphinxhyphen{}10: The song is printed, with \sphinxcode{\sphinxupquote{"Emily"}} used as the
value of \sphinxcode{\sphinxupquote{person}} in line 9: printing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Happy}\PYG{+w}{ }\PYG{n}{Birthday}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{dear}\PYG{+w}{ }\PYG{n}{Emily}\PYG{p}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
End of line 15 after returning from the function call

\item {} 
\sphinxAtStartPar
Line 16: Call to \sphinxcode{\sphinxupquote{HappyBirthday}}, this time with actual
parameter \sphinxcode{\sphinxupquote{"Andre"}}

\item {} 
\sphinxAtStartPar
Line 5: \sphinxcode{\sphinxupquote{"Andre"}} is passed to the function, so
\sphinxcode{\sphinxupquote{person = "Andre"}}.

\item {} 
\sphinxAtStartPar
Lines 7\sphinxhyphen{}10: The song is printed, with \sphinxcode{\sphinxupquote{"Andre"}} used as the
value of \sphinxcode{\sphinxupquote{person}} in line 9: printing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Happy}\PYG{+w}{ }\PYG{n}{Birthday}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{dear}\PYG{+w}{ }\PYG{n}{Andre}\PYG{p}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
End of line 16 after returning from the function call,
and the program is over.

\end{enumerate}

\sphinxAtStartPar
The beauty of this system is that the same function definition can
be used for a call with a different actual parameter variable, and
then have a different effect. The value of the variable person is
used in the third line of \sphinxcode{\sphinxupquote{HappyBirthday}}, to put in whatever
actual parameter value was given.

\index{abstraction@\spxentry{abstraction}}\ignorespaces 
\sphinxAtStartPar
This is the power of \sphinxstyleemphasis{abstraction}. It is one application of the
most important principal in programming. Rather than have a number
of separately coded parts with only slight variations, see where it
is appropriate to combine them using a function whose parameters
refer to the parts that are different in different situations. Then
the code is written to be simultaneously appropriate for the
separate specific situations, with the substitutions of the right
parameter values.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Be sure you completely understand \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday4/birthday4.cs}{birthday4/birthday4.cs}
and the sequence of execution!  It illustrates extremely
important ideas that many people miss the first time!  It is
essential to understand the difference between
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Defining} a function (lines 5\sphinxhyphen{}11)
with the heading including \sphinxstyleemphasis{formal} parameter name and type,
where the code is merely instructions to be remembered,
not acted on immediately.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Calling} a function with an \sphinxstyleemphasis{actual} parameter value to be
substituted for the formal parameter,
(with \sphinxstyleemphasis{no} type included!) and have the function
code actually \sphinxstyleemphasis{run} when the instruction containing the call
is run.  Also note that the function can be
called multiple times with different expressions as the
actual parameter (line 15 and again in line 16).

\end{enumerate}
\end{sphinxadmonition}

\sphinxAtStartPar
We can combine function parameters with user input, and have the
program be able to print Happy Birthday for anyone. Check out the
\sphinxcode{\sphinxupquote{Main}} method and run \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday\_who/birthday\_who.cs}{birthday\_who/birthday\_who.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Birthday\PYGZus{}Who}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{HappyBirthday}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{person}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday, dear \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{person}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Happy Birthday to you!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{userName}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Who would you like to sing Happy Birthday to?\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{userName}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{HappyBirthday}\PYG{p}{(}\PYG{n}{userName}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This last version illustrates several important ideas:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
There are more than one way to get information into a function:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Have a value passed in through a parameter (from line 18 to line 5).

\item {} 
\sphinxAtStartPar
Prompt the user, and obtain data from the keyboard (lines 16\sphinxhyphen{}17).

\end{enumerate}

\item {} 
\sphinxAtStartPar
It is a good idea to separate the \sphinxstyleemphasis{internal} processing of data
from the \sphinxstyleemphasis{external} input from the user by the use of distinct
functions. Here the user interaction is in \sphinxcode{\sphinxupquote{Main}}, and the data
is manipulated in \sphinxcode{\sphinxupquote{HappyBirthday}}.

\item {} 
\sphinxAtStartPar
In the first examples of actual parameters, we used literal
values. In general an actual parameter can be an expression. The
expression is evaluated before it is passed in the function call.
One of the simplest expressions is a plain variable name, which is
evaluated by replacing it with its associated value.
Note this important situation in the example:
We have the
value of \sphinxcode{\sphinxupquote{userName}} in \sphinxcode{\sphinxupquote{Main}} becoming the value of \sphinxcode{\sphinxupquote{person}}
in \sphinxcode{\sphinxupquote{HappyBirthday}}.  We used different names to illustrate the
important fact:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Only the \sphinxstyleemphasis{value} of the actual parameter is passed, not any
variable name, so there is \sphinxstyleemphasis{no need} to have a match between a variable name
used in
an actual parameter and the formal parameter name.
\end{sphinxadmonition}

\end{enumerate}


\subsection{Birthday Function Exercise}
\label{\detokenize{functions/funcparam:birthday-function-exercise}}\label{\detokenize{functions/funcparam:birthdayfunctionex}}
\sphinxAtStartPar
Make your own further change to \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/birthday4/birthday4.cs}{birthday4/birthday4.cs} and save it in your
own project as
\sphinxcode{\sphinxupquote{birthday\_many.cs}}: Add a function call
(but \sphinxstyleemphasis{not} another function \sphinxstyleemphasis{definition}), so Maria gets a verse, in
addition to Emily and Andre. Also print a blank line between
verses. (There are two ways to handle the blank lines:
You may \sphinxstyleemphasis{either} do this by adding a print line to the
function definition, \sphinxstyleemphasis{or} by adding a print line between all calls to
the function.  Recall that if you give Console.WriteLine an empty
parameter list, it just goes to the next line.)

\sphinxstepscope

\index{function@\spxentry{function}!parameter@\spxentry{parameter}}\index{parameter@\spxentry{parameter}}\ignorespaces 

\section{Multiple Function Parameters}
\label{\detokenize{functions/funcparam2:multiple-function-parameters}}\label{\detokenize{functions/funcparam2:more-func-param}}\label{\detokenize{functions/funcparam2:index-0}}\label{\detokenize{functions/funcparam2::doc}}
\sphinxAtStartPar
A function can have more than one parameter in a parameter list.  The
list entries are
separated by commas. Each formal parameter name is preceded by its type.
The example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition1/addition1.cs}{addition1/addition1.cs}
uses
a function, \sphinxcode{\sphinxupquote{SumProblem}},  with two parameters
to make it easy to display many sum problems. Read and
follow the code, and then run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Addition2}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{SumProblemString}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sentence}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}The sum of \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} and \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sentence}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{12345}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{53579}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter an integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter another integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{parameter@\spxentry{parameter}!actual and formal@\spxentry{actual and formal}}\index{actual parameter@\spxentry{actual parameter}}\index{formal parameter@\spxentry{formal parameter}}\ignorespaces 
\sphinxAtStartPar
The actual parameters in the function call are evaluated left to
right, and then these values are associated with the formal
parameter names in the function definition, also left to right. For
example a function call with actual parameters,
\sphinxcode{\sphinxupquote{F(actual1, actual2, actual3)}}, calling a function \sphinxcode{\sphinxupquote{F}} with
definition heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{formal1}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{formal2}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{formal3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
acts approximately as if the first lines executed inside the called
function \sphinxcode{\sphinxupquote{F}} were

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{formal1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{actual1}\PYG{p}{;}
\PYG{n}{formal2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{actual2}\PYG{p}{;}
\PYG{n}{formal3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{actual3}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Functions provide extremely important functionality to programs,
allowing tasks to be defined once and performed repeatedly with
different data. It is essential to see the difference between the
\sphinxstylestrong{formal} parameters used to describe what is done inside the function
definition (like x and y in the definition of SumProblem) and the
\sphinxstylestrong{actual} parameters (like 2 and 3 or 12345 and 53579)
which \sphinxstyleemphasis{substitute} for the formal parameters when the function is
actually executed. \sphinxcode{\sphinxupquote{Main}} uses three different sets
of actual parameters in the three calls to SumProblem.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is easy to confuse the heading in a function \sphinxstyleemphasis{definition} and a \sphinxstyleemphasis{call}
to actually execute that function.  Be careful.  In particular,
do \sphinxstyleemphasis{not} list the types of parameters
in a call’s \sphinxstyleemphasis{actual} parameter list.  The actual parameters are expressions
involving terms that are \sphinxstyleemphasis{already defined}, not just being declared.
\end{sphinxadmonition}


\subsection{Quotient Function Exercise}
\label{\detokenize{functions/funcparam2:quotient-function-exercise}}\label{\detokenize{functions/funcparam2:quotientfunctionex}}
\sphinxAtStartPar
Modify \sphinxcode{\sphinxupquote{quotient\_format.cs}} from
{\hyperref[\detokenize{data/writeline-substitution:quotientformat}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercise for Format}}}} and save it
as \sphinxcode{\sphinxupquote{quotient\_prob.cs}}.
You should create a function \sphinxcode{\sphinxupquote{QuotientProblem}} with \sphinxcode{\sphinxupquote{int}}
parameters.  Like in the earlier versions, it should print a full
sentence with inputs, integer quotient, and remainder.
\sphinxcode{\sphinxupquote{Main}}
should test the \sphinxcode{\sphinxupquote{QuotientProblem}} function
on several sets of literal values, and also test the function with
input from the user.

\sphinxstepscope

\index{function@\spxentry{function}!return@\spxentry{return}}\index{return@\spxentry{return}}\index{execution sequence for function@\spxentry{execution sequence for function}}\ignorespaces 

\section{Returned Function Values}
\label{\detokenize{functions/funcreturn:returned-function-values}}\label{\detokenize{functions/funcreturn:index-0}}\label{\detokenize{functions/funcreturn:id1}}\label{\detokenize{functions/funcreturn::doc}}
\sphinxAtStartPar
You probably have used mathematical functions in algebra class, but
they all had calculated values associated with them. For instance
if you defined
\begin{quote}

\sphinxAtStartPar
F(x)=x$^{\text{2}}$
\end{quote}

\sphinxAtStartPar
then it follows that F(3) is 3$^{\text{2}}$ = 9, and F(3)+F(4) is
3$^{\text{2}}$ + 4$^{\text{2}}$ = 9 + 16 = 25.

\sphinxAtStartPar
Function calls in expressions get
replaced during evaluation by the value of the function.

\sphinxAtStartPar
The corresponding definition and examples in C\# would be the
following, taken from example program \sphinxcode{\sphinxupquote{return1.cs}}. \sphinxstyleemphasis{Read}
\sphinxstyleemphasis{and run}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Return1}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The new C\# syntax is the \sphinxstyleemphasis{return statement}, with the word
\sphinxcode{\sphinxupquote{return}} followed by an expression. Functions that return values
can be used in expressions, just like in math class. When an
expression with a function call is evaluated, the function call is
effectively replaced temporarily by its returned value. Inside the
C\# function, the value to be returned is given by the
expression in the \sphinxcode{\sphinxupquote{return}} statement.

\sphinxAtStartPar
Since the function returns data, and all data in C\# is typed,
there must be a type given for the value returned.  Note that the
function heading does not start with \sphinxcode{\sphinxupquote{static void}}.
In place of \sphinxcode{\sphinxupquote{void}} is \sphinxcode{\sphinxupquote{int}}.  The \sphinxcode{\sphinxupquote{void}} in earlier function headings
meant nothing was returned.  The \sphinxcode{\sphinxupquote{int}} here means that a value \sphinxstyleemphasis{is}
returned and its type is \sphinxcode{\sphinxupquote{int}}.

\sphinxAtStartPar
After the function \sphinxcode{\sphinxupquote{F}}
finishes executing from inside

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
it is as if the statement temporarily became

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and similarly when executing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
the interpreter first evaluates F(3) and effectively replaces the
call by the returned result, 9, as if the statement temporarily
became

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{F}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and then the interpreter evaluates F(4) and effectively replaces
the call by the returned result, 16, as if the statement
temporarily became

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{16}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
resulting finally in 25 being calculated and printed.

\sphinxAtStartPar
C\# functions can return any type of data, not just numbers, and
there can be any number of statements executed before the return
statement. Read, follow, and run the example program
\sphinxcode{\sphinxupquote{return2.cs}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Return2}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{LastFirst}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{firstName}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{lastName}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{separator}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}, \PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{lastName}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{separator}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{firstName}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{LastFirst}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Benjamin\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Franklin\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{LastFirst}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Andrew\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Harrington\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Many have a hard time following the flow of execution with functions.
Even more is involved when there are return values.
Make sure you completely follow the details of the execution:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Lines 12: Start at Main

\item {} 
\sphinxAtStartPar
Line 14: call the function, remembering where to return

\item {} 
\sphinxAtStartPar
Line 5: pass the parameters: \sphinxcode{\sphinxupquote{firstName = "Benjamin"}};
\sphinxcode{\sphinxupquote{lastName = "Franklin"}}

\item {} 
\sphinxAtStartPar
Line 7: Assign the variable \sphinxcode{\sphinxupquote{separator}} the value \sphinxcode{\sphinxupquote{", "}}

\item {} 
\sphinxAtStartPar
Line 8: Assign the variable \sphinxcode{\sphinxupquote{result}} the value of
\sphinxcode{\sphinxupquote{lastName + separator + firstName}} which is
\sphinxcode{\sphinxupquote{"Franklin" + ", " + "Benjamin"}}, which evaluates to
\sphinxcode{\sphinxupquote{"Franklin, Benjamin"}}

\item {} 
\sphinxAtStartPar
Line 9: Return \sphinxcode{\sphinxupquote{"Franklin, Benjamin"}}

\item {} 
\sphinxAtStartPar
Line 14: Use the value returned from the function call so the line
effectively becomes  \sphinxcode{\sphinxupquote{Console.WriteLine("Franklin, Benjamin");}},
so print it.

\item {} 
\sphinxAtStartPar
Line 15: call the function with the new actual parameters,
remembering where to return

\item {} 
\sphinxAtStartPar
Line 5: pass the parameters: \sphinxcode{\sphinxupquote{firstName = "Andrew"}};
\sphinxcode{\sphinxupquote{lastName = "Harrington"}}

\item {} 
\sphinxAtStartPar
Lines 7\sphinxhyphen{}9: … calculate and return \sphinxcode{\sphinxupquote{"Harrington, Andrew"}}

\item {} 
\sphinxAtStartPar
Line 15: Use the value returned by the function and print
\sphinxcode{\sphinxupquote{"Harrington, Andrew"}}

\end{enumerate}

\sphinxAtStartPar
Compare \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/return2/return2.cs}{return2/return2.cs} and \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition1/addition1.cs}{addition1/addition1.cs},
from the previous
section. Both use functions. Both print, but where the printing \sphinxstyleemphasis{is
done} differs. The function \sphinxcode{\sphinxupquote{SumProblem}} prints directly inside
the function and returns nothing. On the other hand
\sphinxcode{\sphinxupquote{LastFirst}} does not print anything but returns a string. The
caller gets to decide what to do with the returned string, and above it is
printed in \sphinxcode{\sphinxupquote{Main}}.

\index{example@\spxentry{example}!addition2.cs@\spxentry{addition2.cs}}\index{addition2.cs example@\spxentry{addition2.cs example}}\ignorespaces 
\sphinxAtStartPar
In general functions should do a single thing.
You can easily combine a sequence of functions, and you have more
flexibility in the combinations
if each does just one unified thing.  The function
SumProblem in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition1/addition1.cs}{addition1/addition1.cs} does two thing:
It creates a sentence,
and prints it.  If that is all you have, you are out of luck if you want
to do something different with the sentence string.  A better approach is
to have a function that just creates the sentence, and returns it for
whatever further use you want.  After returning that value,
printing is one possibility, done in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition2/addition2.cs}{addition2/addition2.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Addition2}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{SumProblemString}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sentence}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}The sum of \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} and \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sentence}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{12345}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{53579}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter an integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter another integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This example constructs the sentence using the string \sphinxcode{\sphinxupquote{+}} operator.
Generating a string with substitutions using a format string
in \sphinxcode{\sphinxupquote{Console.Write}} is neater, but
we are forced to directly print the string,
and not remember it for later arbitrary use.

\index{string@\spxentry{string}!Format@\spxentry{Format}}\index{Format method for string@\spxentry{Format method for string}}\ignorespaces \phantomsection\label{\detokenize{functions/funcreturn:string-format}}
\sphinxAtStartPar
It is common to want to construct and immediately print a string,
so having \sphinxcode{\sphinxupquote{Console.Write}} is definitely handy when we want it.,
However it is an example of combining two separate steps!  Sometimes
(like here) we just want to have the resulting string, and do something else
with it.  We introduce
the C\# library function  \sphinxcode{\sphinxupquote{string.Format}}, which does just what we want:
The parameters
have the same form as for \sphinxcode{\sphinxupquote{Console.Write}}, but the formatted string is
\sphinxstyleemphasis{returned}.

\sphinxAtStartPar
Here is a revised version of the function \sphinxcode{\sphinxupquote{SumProblemString}},
from example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition2a/addition2a.cs}{addition2a/addition2a.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{SumProblemString}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{// with string.Format}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The sum of \PYGZob{}0\PYGZcb{} and \PYGZob{}1\PYGZcb{} is \PYGZob{}2\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The only caveat with \sphinxcode{\sphinxupquote{string.Format}} is that
there is \sphinxstyleemphasis{no} special function corresponding to \sphinxcode{\sphinxupquote{Console.WriteLine}},
with an automatic terminating newline.
You can generate a newline with string.Format:  Remember the
escape code \sphinxcode{\sphinxupquote{"\textbackslash{}n"}}.  Put it at the end to go on to a new line.

\sphinxAtStartPar
\sphinxstylestrong{In class recommendation}:  Improve example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/painting/painting.cs}{painting/painting.cs}
with a function used for repeated similar operations.
Copy it to a file \sphinxcode{\sphinxupquote{painting\_input.cs}} in your
own project and modify it.


\subsection{Interview String Return Exercise/Example}
\label{\detokenize{functions/funcreturn:interview-string-return-exercise-example}}\label{\detokenize{functions/funcreturn:interviewstringex}}
\sphinxAtStartPar
Write a program by that accomplishes the same thing as
{\hyperref[\detokenize{data/io:interviewproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Interview Exercise/Example}}}}, but introduce a function
\sphinxcode{\sphinxupquote{InterviewSentence}} that takes name
and time strings as parameters and returns the interview sentence string.
For practice use \sphinxcode{\sphinxupquote{string.Format}} in the function.
With this setup you can manage input from the user and output to the
screen entirely in \sphinxcode{\sphinxupquote{Main}}, while using \sphinxcode{\sphinxupquote{InterviewSentence}} to generate
the sentence that you want to \sphinxstyleemphasis{later} print.

\sphinxAtStartPar
(Here we are having you work on getting used to
function syntax while keeping the
body of your new function very simple.  Combining that with longer, more
realistic function bodies is coming!)

\sphinxAtStartPar
If you want a further example on this idea of returning
something first and then using the result,
or if you want to compare your work to ours,
see our solution, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interview2/interview2.cs}{interview2/interview2.cs}.


\subsection{Quotient String Return Exercise}
\label{\detokenize{functions/funcreturn:quotient-string-return-exercise}}\label{\detokenize{functions/funcreturn:quotientstringex}}
\sphinxAtStartPar
Create \sphinxcode{\sphinxupquote{quotient\_return.cs}} by modifying \sphinxcode{\sphinxupquote{quotient\_prob.cs}} in
{\hyperref[\detokenize{functions/funcparam2:quotientfunctionex}]{\sphinxcrossref{\DUrole{std,std-ref}{Quotient Function Exercise}}}} so that the program accomplishes the same
thing, but everywhere:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Change the QuotientProblem function into one
called \sphinxcode{\sphinxupquote{QuotientString}} that merely \sphinxstyleemphasis{returns} the string rather
than printing the string directly.

\item {} 
\sphinxAtStartPar
Have \sphinxcode{\sphinxupquote{Main}} print
the result of each call to the \sphinxcode{\sphinxupquote{QuotientString}} function.

\end{itemize}

\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{string.Format}} to create the sentence that you return.

\sphinxstepscope

\index{function@\spxentry{function}!consumer and writer@\spxentry{consumer and writer}}\index{consumer of functions@\spxentry{consumer of functions}}\index{writer of functions@\spxentry{writer of functions}}\ignorespaces 

\section{Two Roles: Writer and Consumer of Functions}
\label{\detokenize{functions/writerconsumer:two-roles-writer-and-consumer-of-functions}}\label{\detokenize{functions/writerconsumer:two-roles}}\label{\detokenize{functions/writerconsumer:index-0}}\label{\detokenize{functions/writerconsumer::doc}}
\sphinxAtStartPar
The remainder of this section covers finer
points about functions that you might skip on a first reading.

\sphinxAtStartPar
We are only doing tiny examples so far to get the basic idea of
functions. In much larger programs, functions are useful to manage
complexity, splitting things up into logically related, modest
sized pieces. Programmers are both writers of functions and
consumers of the other functions called inside their functions. It
is useful to keep those two roles separate:

\sphinxAtStartPar
The user of an already written function needs to know:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the name of the function

\item {} 
\sphinxAtStartPar
the order and meaning of parameters

\item {} 
\sphinxAtStartPar
what is returned or produced by the function

\end{enumerate}

\sphinxAtStartPar
\sphinxstyleemphasis{How} this is accomplished is not relevant at this point. For
instance, you use the work of the C\# development team, calling
functions that are built into the language. You need know the three
facts about the functions you call. You do not need to know exactly
\sphinxstyleemphasis{how} the function accomplishes its purpose.

\sphinxAtStartPar
On the other hand when you \sphinxstyleemphasis{write} a function you need to figure
out exactly how to accomplish your goal, name relevant variables,
and write your code, which brings us to the next section.

\sphinxAtStartPar
The jargon for these parts are the \sphinxstyleemphasis{interface} (for the consumer)
and the \sphinxstyleemphasis{implementation} (for the programmer, who must be sure
to satisfy the public interface).

\sphinxstepscope

\index{local variables\textquotesingle{} scope@\spxentry{local variables\textquotesingle{} scope}}\index{scope@\spxentry{scope}!local@\spxentry{local}}\ignorespaces 

\section{Local Scope}
\label{\detokenize{functions/localscope:local-scope}}\label{\detokenize{functions/localscope:index-0}}\label{\detokenize{functions/localscope:id1}}\label{\detokenize{functions/localscope::doc}}
\sphinxAtStartPar
For the logic of writing functions, it is important that the writer
of a function knows the names of variables inside the function. On
the other hand, if you are only using a function, maybe written by
someone unknown to you, you should not care what names are given to
values used internally in the implementation of the function you
are calling. C\# enforces this idea with \sphinxstyleemphasis{local scope} rules:
Variable names initialized and used inside one function are
\sphinxstyleemphasis{invisible} to other functions. Such variables are called \sphinxstyleemphasis{local}
variables. For example, an elaboration of the earlier program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/return2/return2.cs}{return2/return2.cs} might have its \sphinxcode{\sphinxupquote{lastFirst}} function with its local
variable \sphinxcode{\sphinxupquote{separator}}, but it might also have another function
that defines a \sphinxcode{\sphinxupquote{separator}} variable, maybe with a different value
like \sphinxcode{\sphinxupquote{"\textbackslash{}n"}}. They would not conflict. They would be
independent. This avoids lots of errors!

\sphinxAtStartPar
For example, the following code in the example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/bad\_scope/bad\_scope.cs}{bad\_scope/bad\_scope.cs} causes a compilation error
if the last line is uncommented.
Read it, uncomment the line, and try to run it, and see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{F}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{F}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// F doesn\PYGZsq{}t know about the x defined in Main}
\PYG{+w}{      }\PYG{c+c1}{//Console.WriteLine(x); //ERROR if uncommented}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The compilation error that Mono gives is pretty clear:
\begin{quote}

\sphinxAtStartPar
The name ‘x’ does not exist in the current context.
\end{quote}

\sphinxAtStartPar
The the error occurs in the function \sphinxcode{\sphinxupquote{F}}.  The \sphinxstyleemphasis{context} there just includes
the local variables already declared in \sphinxcode{\sphinxupquote{F}}.  And \sphinxcode{\sphinxupquote{x}} is declared in
\sphinxcode{\sphinxupquote{Main}}, not in \sphinxcode{\sphinxupquote{F}}, so it \sphinxstyleemphasis{does not exist} inside \sphinxcode{\sphinxupquote{F}}.
We will fix this error below.

\sphinxAtStartPar
If you do want local data from one function to go to another,
define the called function so it includes parameters! Read and
compare and try the program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/good\_scope/good\_scope.cs}{good\_scope/good\_scope.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{GoodScope}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{F}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
With parameter passing, the parameter name \sphinxcode{\sphinxupquote{x}} in the function
\sphinxcode{\sphinxupquote{F}} does not need to match the name of the actual parameter in
the calling function \sphinxcode{\sphinxupquote{Main}}. (Just the \sphinxcode{\sphinxupquote{int}} value is passed.)
The definition of \sphinxcode{\sphinxupquote{F}} could just as well have been:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{whatever}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{whatever}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is a very common error to declare a variable in one function
and try to use it by name in a different function.  If you get
an error about a variable not existing, look to see where it was
declared (or if you remembered to declare it at all)!
\end{sphinxadmonition}

\sphinxAtStartPar
In general the \sphinxstyleemphasis{scope} of a variable is
the places in the program where its value can be referenced and used.
The scope of a local variable is just inside
the function where it is declared.

\sphinxstepscope

\index{constant@\spxentry{constant}}\index{global constant@\spxentry{global constant}}\index{scope@\spxentry{scope}!class@\spxentry{class}}\index{class@\spxentry{class}!scope@\spxentry{scope}}\ignorespaces 

\section{Static Variables}
\label{\detokenize{functions/staticvariables:static-variables}}\label{\detokenize{functions/staticvariables:index-0}}\label{\detokenize{functions/staticvariables:id1}}\label{\detokenize{functions/staticvariables::doc}}
\sphinxAtStartPar
You may define \sphinxstyleemphasis{static variables} (variables defined
with the word \sphinxcode{\sphinxupquote{static}} inside the class,
but \sphinxstyleemphasis{outside} of any function definition).
These variables are visible inside all of your functions in the class.
Instead of local scope, static variables have \sphinxstyleemphasis{class scope}.
It is good programming practice generally to avoid defining static variables and
instead to put your variables inside functions and explicitly pass
them as parameters where needed. There are exceptions.  For now a
good reason for using static variables is constants:
A \sphinxstyleemphasis{constant} is a name that you give a fixed data value to.
If you have a static definition of a constant,
then you can then use the name of the fixed data value in
expressions in any function in the class.
A simple example program is \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/constant/constant.cs}{constant/constant.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UseConstant}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{PI}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3.14159265358979}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// constant, value not reset}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{CircleArea}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{radius}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{PI}\PYG{o}{*}\PYG{n}{radius}\PYG{o}{*}\PYG{n}{radius}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{Circumference}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{radius}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m}{2}\PYG{o}{*}\PYG{n}{PI}\PYG{o}{*}\PYG{n}{radius}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}circle area with radius 5: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{CircleArea}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}circumference with radius 5:\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{Circumference}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See that \sphinxcode{\sphinxupquote{PI}} is used in two functions without being declared locally.

\sphinxAtStartPar
By convention, names for constants are all capital letters
(and underscores joining multiple words).

\sphinxstepscope

\index{function@\spxentry{function}!not use return value@\spxentry{not use return value}}\index{return@\spxentry{return}!value not used@\spxentry{value not used}}\ignorespaces 

\section{Not using Return Values}
\label{\detokenize{functions/notusereturn:not-using-return-values}}\label{\detokenize{functions/notusereturn:not-using-ret-val}}\label{\detokenize{functions/notusereturn:index-0}}\label{\detokenize{functions/notusereturn::doc}}
\sphinxAtStartPar
Some functions return a value, and get used as an expression
in a larger calling statement.
The calling statement uses the value returned.
Usually the only effect of such a value\sphinxhyphen{}returning function is from the
value returned.

\sphinxAtStartPar
Some functions are \sphinxcode{\sphinxupquote{void}}, and get used as a whole instruction in your code:
Without returning a value, the only way to be useful is to do something that
leaves some lasting \sphinxstyleemphasis{side effect}:
make some change to the system that persists after
the termination of the function and its local variables disappear.
The only such effect that we have seen so
far is to print something that remains on the console screen.
Later we will talk about other persistent changes
to values in objects, locations in files, ….

\sphinxAtStartPar
Usually there is this division in the behavior of functions,
returning a value or not:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void}}: do something as a whole instruction,
with a side effect in the larger system.

\item {} 
\sphinxAtStartPar
Return a value to use in a larger calling statement

\end{enumerate}

\sphinxAtStartPar
It is legal to do \sphinxstyleemphasis{both}: accomplish something with a side effect
in the system, \sphinxstyleemphasis{and}
return a value.  Sometimes you care about both,
and sometimes you use the function only for its side effect.
We will see examples of that later, like in {\hyperref[\detokenize{dictionaries/dictionaryexamples:sets}]{\sphinxcrossref{\DUrole{std,std-ref}{Sets}}}}.

\sphinxAtStartPar
This later advanced use will mean that the compiler needs to
\sphinxstyleemphasis{permit} the programmer to ignore a
returned value, and use a function returning a value as a whole statement.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This means that the compiler cannot catch a common logical error:
forgetting to immediately use a returned value that your program logic
really needs.
\end{sphinxadmonition}

\sphinxAtStartPar
For example with this definition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CalcResult}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{param}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// ....}
\PYG{+w}{   }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
you might try to use \sphinxcode{\sphinxupquote{CalcResult}} in this bad code, intending to use the \sphinxcode{\sphinxupquote{result}}
from CalcResult:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{BadUseResult}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{CalcResult}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In fact you would always print 0, ignoring the \sphinxcode{\sphinxupquote{result}}
calculated in \sphinxcode{\sphinxupquote{CalcResult}}.
The reason is the {\hyperref[\detokenize{functions/localscope:local-scope}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Scope}}}} rules:  The local variable name \sphinxcode{\sphinxupquote{result}}
disappears when the \sphinxcode{\sphinxupquote{CalcResult}} function returns.
It is not used in the calling function, \sphinxcode{\sphinxupquote{BadUseResult}}, and the
separately declared \sphinxcode{\sphinxupquote{result}} of \sphinxcode{\sphinxupquote{BadUseResult}}
retains its original 0 value.

\sphinxAtStartPar
Here we set up the worst situation: where there is a logical error,
but not an error shown by the compiler.  More commonly a student leaves out
the \sphinxcode{\sphinxupquote{int result = 0;}} line, incorrectly relying on the declaration of \sphinxcode{\sphinxupquote{result}}
in \sphinxcode{\sphinxupquote{CalcResult}}.  At least in that situation a compiler error brings attention
to the problem:
The last line would try to use the variable \sphinxcode{\sphinxupquote{result}}
without it being declared.

\sphinxAtStartPar
You can use the result from \sphinxcode{\sphinxupquote{CalcResult}}, like with any other
value\sphinxhyphen{}returning function, with either

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{k}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CalcResult}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//store the returned value in an assignment!}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{k}{value}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//  and then use the remembered value}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{CalcResult}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// immediately use the returned value}
\end{sphinxVerbatim}

\sphinxAtStartPar
This second version works as long as you do \sphinxstyleemphasis{not} need the
returned value later, in another place, since you do not remember it past that
one statement!

\sphinxstepscope

\index{library class@\spxentry{library class}}\index{multiple source files using library class@\spxentry{multiple source files using library class}}\ignorespaces 

\section{Library Classes}
\label{\detokenize{functions/libraryclass:library-classes}}\label{\detokenize{functions/libraryclass:index-0}}\label{\detokenize{functions/libraryclass:id1}}\label{\detokenize{functions/libraryclass::doc}}
\index{library@\spxentry{library}!UIF@\spxentry{UIF}}\ignorespaces 
\sphinxAtStartPar
In {\hyperref[\detokenize{functions/funcreturn:returned-function-values}]{\sphinxcrossref{\DUrole{std,std-ref}{Returned Function Values}}}}, the suggestion was made to look at
the Painter class and split out repeated ideas into functions, leading to
a function to prompt the user and return a double value.
The same section included
the example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition2/addition2.cs}{addition2/addition2.cs}.
In that case there were repeated prompts for
integers.  Clearly another common situation is to prompt for a string.
We can create
functions to do all these things and more, and embed them into a class
specially written for a new
interactive program.

\sphinxAtStartPar
A neater thing is to put them as a class in a separate library
that can be used directly for multiple programs.  We can create functions
\sphinxcode{\sphinxupquote{PromptLine}},
\sphinxcode{\sphinxupquote{PromptInt}}, and  \sphinxcode{\sphinxupquote{PromptDouble}}, and put them in their own class, \sphinxcode{\sphinxupquote{UIF}}
(for User Input First version)
in project ui’s file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ui/uif.cs}{uif.cs}.
We explain the namespace line after the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// User Input First version (bombs in Parse with mistyping)}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UIF}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{/// After displaying the prompt, return a line from the keyboard.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{PromptLine}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// After displaying the prompt,}
\PYG{+w}{      }\PYG{c+c1}{/// return an integer entered from the keyboard.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{PromptInt}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// After displaying the prompt,}
\PYG{+w}{      }\PYG{c+c1}{/// return a double entered from the keyboard.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{PromptDouble}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// After displaying the prompt,}
\PYG{+w}{      }\PYG{c+c1}{/// return  true if \PYGZsq{}y\PYGZsq{} is entered from the keyboard}
\PYG{+w}{      }\PYG{c+c1}{/// and false otherwise.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{Agree}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}y\PYGZdq{}}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{namespace@\spxentry{namespace}}\index{IntroCS namespace@\spxentry{IntroCS namespace}}\ignorespaces 
\sphinxAtStartPar
We have been \sphinxcode{\sphinxupquote{using System}} in every program.  \sphinxcode{\sphinxupquote{System}} is a \sphinxstyleemphasis{namespace} that
collects a particular group of class names, making them available to the program,
and distinguishes them form any classes in a different namespace that might have the
same class names.

\sphinxAtStartPar
Once we start writing and using multiple classes at once, it is a good idea for us to
specify our own namespace.  We will consistently use \sphinxcode{\sphinxupquote{IntroCS}} in our multi\sphinxhyphen{}file
examples in this book.

\index{public@\spxentry{public}}\ignorespaces 
\sphinxAtStartPar
Specifying a namespace makes it possible for all other classes in the
same namespace to reference \sphinxstyleemphasis{public} parts of the current class, and vice\sphinxhyphen{}versa.

\sphinxAtStartPar
Public classes and functions start their heading with \sphinxcode{\sphinxupquote{public}}.

\sphinxAtStartPar
The code included in a namespace is enclosed in braces, so the general syntax is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{namespace}} \sphinxstyleemphasis{name}
\item[] \sphinxcode{\sphinxupquote{\{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] class definition(s)…
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
We will keep user input library classes like this one, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ui/uif.cs}{uif.cs},
in a project ui.

\sphinxAtStartPar
Notice that the functions we want accessible in \sphinxcode{\sphinxupquote{UIF}}
are all marked \sphinxcode{\sphinxupquote{public}}, so that any class can use them.

\sphinxAtStartPar
We can write a modified example addition program, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition3/addition3.cs}{addition3/addition3.cs},
as an example of using \sphinxcode{\sphinxupquote{UIF}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Addition3}\PYG{+w}{ }\PYG{c+c1}{// using UIF}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{/// Return a sentence stating the sum of x and y.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{SumProblemString}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sentence}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}The sum of \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} and \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}
\PYG{+w}{                           }\PYG{l+s}{\PYGZdq{} is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sentence}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{l+m}{12345}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{53579}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter an integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter another integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{SumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To allow access to UIF, we have added the IntroCS namespace for the class.
To reference the static functions in the different class \sphinxcode{\sphinxupquote{UIF}}, we put \sphinxcode{\sphinxupquote{UIF.}}
(with the dot) at the start of each reference to a static function in
the class \sphinxcode{\sphinxupquote{UIF}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In Xamarin Studio, if you use a file from a library project (without
just copying the present version of that file into the current project),
be sure that the current project includes
a \sphinxstyleemphasis{reference} to the library project.
If you expand the references in the Xamarin Studio
project addition3, by clicking on the References line in the solution pad,
you should see the project ui.
\end{sphinxadmonition}

\sphinxAtStartPar
Shortly you will see the optional section for making your own
{\hyperref[\detokenize{functions/libraryclass:library-projects-in-xamarinstudio}]{\sphinxcrossref{\DUrole{std,std-ref}{Library Projects in Xamarin Studio (Optional)}}}}.

\sphinxAtStartPar
Though we have not discussed all the C\# syntax needed yet, there is also an
improved class \sphinxcode{\sphinxupquote{UI}} in the ui project that we discuss later.
It includes all the function
names in \sphinxcode{\sphinxupquote{UIF}}, and keeps your program from bombing out
if the user enters an illegal format for a number.

\index{documentation of functions@\spxentry{documentation of functions}}\index{function@\spxentry{function}!documentation ///@\spxentry{documentation ///}}\index{/// documentation@\spxentry{/// documentation}}\ignorespaces 

\subsection{Function Documentation}
\label{\detokenize{functions/libraryclass:function-documentation}}\label{\detokenize{functions/libraryclass:index-4}}\label{\detokenize{functions/libraryclass:id2}}
\sphinxAtStartPar
In keeping with {\hyperref[\detokenize{functions/writerconsumer:two-roles}]{\sphinxcrossref{\DUrole{std,std-ref}{Two Roles: Writer and Consumer of Functions}}}}, in future you will be a \sphinxstyleemphasis{consumer} of the library
classes.  It is particularly important to document library classes with the
interface information users will need.
Documentation could be written in a separate document, but much developer history has
shown that such documentation does not tend to either get written in the first place,
or not updated well to stay consistent with updates in the code.
Inconsistent documentation is useless.  Documentation is much more
likely to be seen and maintained by the implementers if it sits right with the
code, like our comments before the class and function headings.

\sphinxAtStartPar
You will note that instead of the usual line comment syntax \sphinxcode{\sphinxupquote{//}}, we have added
an extra \sphinxcode{\sphinxupquote{/}}, making \sphinxcode{\sphinxupquote{///}}.  That will also start a comment.  (The third \sphinxcode{\sphinxupquote{/}}
is technically just a part of the comment.)  There is a special reason for the
notation:  Though it is convenient for the \sphinxstyleemphasis{implementer} of code to have the documentation
right with the code, a \sphinxstyleemphasis{user} of the functions only needs the interface information
found in good documentation.  The \sphinxcode{\sphinxupquote{///}} lines before heading are specially recognized
by \sphinxstyleemphasis{separate} automatic documentation generating programs.

\sphinxAtStartPar
There are many documentation
generating programs and conventions.
For now we will just use plain text in the \sphinxcode{\sphinxupquote{///}} lines.
This is recognized by the Xamarin Studio system. If you open our \sphinxcode{\sphinxupquote{examples}} solution,
in Xamarin Studio, and edit window for
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition3/addition3.cs}{addition3/addition3.cs},
you can place your mouse over \sphinxcode{\sphinxupquote{UIF}} and a popup window shows the \sphinxcode{\sphinxupquote{UIF}} class heading
documentation.

\sphinxAtStartPar
If you move the mouse over \sphinxcode{\sphinxupquote{PromptInt}}, you should see the popup label showing
the function signature and the function documentation.
If you change the two \sphinxcode{\sphinxupquote{///}} lines
in \sphinxcode{\sphinxupquote{uif.cs}} above the \sphinxcode{\sphinxupquote{PromptInt}} heading to start with just \sphinxcode{\sphinxupquote{//}}.
you should no longer be able to see the documentation part of the popup for
\sphinxcode{\sphinxupquote{PromptInt}} in the \sphinxcode{\sphinxupquote{addition3.cs}} edit window. (Be sure to change back to \sphinxcode{\sphinxupquote{///}}.)

\sphinxAtStartPar
There are more elaborate documentation conventions that can be used for
Xamarin Studio and other documentation generation programs, not discussed here.

\sphinxAtStartPar
This documentation also works inside a single program file.  If you have a long
program with lots of functions defined, this can also be helpful when calling
one of your own functions.  You can avoid jumping
around to be reminded of the signature and use of your functions.


\subsection{Library Projects in Xamarin Studio (Optional)}
\label{\detokenize{functions/libraryclass:library-projects-in-xamarin-studio-optional}}\label{\detokenize{functions/libraryclass:library-projects-in-xamarinstudio}}
\sphinxAtStartPar
Xamarin Studio has a multi\sphinxhyphen{}step process for
creating a library project and for separately
referencing it in other projects.  The \sphinxstyleemphasis{advantage} of this approach is when you
want to change the implementation but not the interface to library functions,
you just do it once, in the library project.
Other projects reference that project.

\sphinxAtStartPar
Some students find the Xamarin Studio overhead of setting up and referencing
library projects onerous.
As a  practical matter with files that you want to reuse but are not likely to change,
you can just copy the source file into the new project, and avoid the
Xamarin Studio library setup overhead.
Many of our already created example projects use a library version
of UIF and several other utility files.  You can do the same with your solutions,
following the instructions below, or you can just copy in the needed utility
files for each project.

\sphinxAtStartPar
Hence the rest of the section here is \sphinxstyleemphasis{optional}:

\sphinxAtStartPar
Try adding a reference yourself.  Follow these instructions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In your own Xamarin Studio solution, start to add a project,
but \sphinxstyleemphasis{instead} of leaving
Console Project selected in the dialog window, select \sphinxstylestrong{Library Project}.

\item {} 
\sphinxAtStartPar
Then add the project name ui, and continue like when starting
previous projects.

\item {} 
\sphinxAtStartPar
Copy in the \sphinxcode{\sphinxupquote{.cs}} files from
our ui project, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ui/uif.cs}{uif.cs} and \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ui/ui.cs}{ui.cs}.
Now you have your library project.

\item {} 
\sphinxAtStartPar
Create another regular Console project, addition3, in your \sphinxstyleemphasis{same} solution,
and copy in our \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/addition3/addition3.cs}{addition3/addition3.cs}, so that is the only file.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Xamarin Studio remembers the last kind of project you created.
That is fine when you are creating a sequence of Console projects.
However, if you have just explicitly chosen to create a library
project, the default for your next project will also be library,
and really mess up your next Console project.  You can fix such an error
after the fact as described next.
\end{sphinxadmonition}

\sphinxAtStartPar
If you created a Library project by mistake, you can either
start over from scratch using the wizard again, but concentrating on
making a \sphinxstyleemphasis{Console} project this time, or you can change the current
project settings options manually:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Double click on the project in the Solution Pad
(if that does anything, or right\sphinxhyphen{}click it and select Options).
An elaborate Project Options dialog window appears.

\item {} 
\sphinxAtStartPar
In the left pane under Build, select General.
In the right pane, you problably see Compile Target: Library.
Change Library to \sphinxstyleemphasis{Executable}.

\item {} 
\sphinxAtStartPar
Finally finish as in the first error fix discussed in
{\hyperref[\detokenize{data/lab-division-sentences:xamarinstudio-reminders}]{\sphinxcrossref{\DUrole{std,std-ref}{Xamarin Studio Reminders and Fixes}}}}, so the Console is used for
input and output.  (You should already have the Project options
displayed from the steps above.)

\end{itemize}

\item {} 
\sphinxAtStartPar
In the Solutions pad, in your addition3 project,
click on the References entry just inside the project.
You should see that the project is automatically set up to reference System.

\item {} 
\sphinxAtStartPar
Open the local menu for the References, and select Edit References.

\item {} 
\sphinxAtStartPar
Click the Projects tab in the window that pops up.  This limits the length
of the list that you search.

\item {} 
\sphinxAtStartPar
Possibly after scrolling down, find the recently made ui project and
check the box beside it.

\item {} 
\sphinxAtStartPar
Click OK in the bottom right corner of the window.
Now look at the References again.  You should see ui listed!

\item {} 
\sphinxAtStartPar
Run your addition3 project.

\end{enumerate}

\sphinxAtStartPar
You only need to add a library project once,
but every further project that needs it,
must have a \sphinxstyleemphasis{reference} to the library project added.
You might try another for yourself
with the next exercise!

\sphinxAtStartPar
Again this approach allows you to change the implementation of
your library class in just one copy in one project,
which can be referenced from many places.
If you copy the file into different projects, and then decide the code
needs to be updated, you are stuck \sphinxstyleemphasis{finding} and editing \sphinxstyleemphasis{all} the copies!
Not good.  Our library files uif.cs, ui.cs, and later fio.cs,
should not be moving targets, so copying should not cause a problem.  This
may simplify your life, but the tradeoff is not getting used to using
library references, which are useful in the larger scheme of things.


\subsection{Quotient UI Exercise}
\label{\detokenize{functions/libraryclass:quotient-ui-exercise}}\label{\detokenize{functions/libraryclass:quotientuiex}}
\sphinxAtStartPar
Create \sphinxcode{\sphinxupquote{quotient\_u\_i.cs}} by modifying \sphinxcode{\sphinxupquote{quotient\_return.cs}} in
{\hyperref[\detokenize{functions/funcreturn:quotientstringex}]{\sphinxcrossref{\DUrole{std,std-ref}{Quotient String Return Exercise}}}} so that the program accomplishes the same
thing, but use the UIF class for all user input.

\sphinxstepscope

\index{tracebacks@\spxentry{tracebacks}}\index{debugging@\spxentry{debugging}!tracebacks@\spxentry{tracebacks}}\ignorespaces 

\section{Tracebacks}
\label{\detokenize{functions/traceback:tracebacks}}\label{\detokenize{functions/traceback:index-0}}\label{\detokenize{functions/traceback:id1}}\label{\detokenize{functions/traceback::doc}}
\sphinxAtStartPar
Various things cause an \sphinxstyleemphasis{Exception} and make a program bomb out in the middle.
For debugging purposes it is very useful top know exactly where this happens.
Xamarin Studio gives feedback, but it takes some understanding to extract
the useful information.

\sphinxAtStartPar
This program below, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/traceback/traceback.cs}{traceback/traceback.cs} takes user input and is designed to bomb out with
bad input in both an obvious and in a subtle way.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Traceback}\PYG{+w}{  }\PYG{c+c1}{// allows several kinds of run\PYGZhy{}time error traceback}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{DoRemainder}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{DoRemainder}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{DoSTwice}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{DoSTwice}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{DoRemainder}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{divisor}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter divisor: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Remainder}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{divisor}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Remainder is \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Remainder}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}About to calc remainder...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Get data, print remainder results}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{DoSTwice}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter string: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{ShowTwice}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ShowTwice}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}About to print string...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}string: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZbs{}nTwice: \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{s}\PYG{o}{+}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The remainder part works fine if the user enters integers other than 0,
but it will blow up if the user enters 0 for the divisor.

\sphinxAtStartPar
The program was also consciously designed so that there are nested function calls:
For example \sphinxcode{\sphinxupquote{Main}} calls \sphinxcode{\sphinxupquote{DoRemainder}} (in two places) which calls \sphinxcode{\sphinxupquote{Remainder}}.

\sphinxAtStartPar
You can run it, first entering reasonable numbers like 13 and 5.  Then at the
request for two more numbers try
entering 3 and 0.  You get an error \sphinxstyleemphasis{traceback} something like the following.
There are several very long lines.  I have added numbers to reference different ones:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Unhandled Exception:

\item {} 
\sphinxAtStartPar
System.DivideByZeroException: Attempted to divide by zero.

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.Remainder (Int32 n, Int32 m) {[}0x0000b{]} in
\sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:26

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.DoRemainder () {[}0x00019{]} in
\sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:19

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.Main () {[}0x00006{]} in
\sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:10

\item {} 
\sphinxAtStartPar
{[}ERROR{]} …

\end{enumerate}

\sphinxAtStartPar
Unhelpfully it repeats about the same data twice, so I chopped off the part after “{[}ERROR{]}”.

\sphinxAtStartPar
Let us look at this a line at a time:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
It says the Exception is “unhandled”:
There are ways to handle exceptions from \sphinxstyleemphasis{within} a program,
but that is beyond the scope of this course.

\item {} 
\sphinxAtStartPar
Exception types are classes, so it gives the full
name of the class, including the namespace.  Also there is a short English description:
pretty clear here.

\item {} 
\sphinxAtStartPar
So where did the error occur?  The first line starting with “at …” shows the full
name (including namespace and class) of the function
in which the error occured.
There can be multiple source files coming from multiple places,
so it also includes the full path name to the sourcefile \sphinxhyphen{} quite a mouthful on my
computer, so I left out the full path to my Xamarin solution, calling it
\sphinxstyleemphasis{pathToSolution}. Do not let
your eyes glaze over yet, because at the
very end comes the most important information: “:26”.  The error
was triggered in line \sphinxstylestrong{26}.  No surprise here:
the line where the division for the remainder takes place.
The divide by zero exception is directly triggered by the hardware, and this did happen in
the last line of the \sphinxcode{\sphinxupquote{Remainder}} function.

\item {} 
\sphinxAtStartPar
Just saying the line where an error occured is not as much information as you would like generally:
The function could be called from many places.  The remaining “at …” lines give the whole
\sphinxstyleemphasis{chain} of function calls in reverse time order, all the way up to the outer call, in \sphinxcode{\sphinxupquote{Main}}.
See the “:19” at the end of this long line:
Check that the call to \sphinxcode{\sphinxupquote{Remainder}} did come from line 19 in \sphinxcode{\sphinxupquote{DoRemainder}}.

\item {} 
\sphinxAtStartPar
There could be more intermediate function calls in general.  In this case, however,
we have come to the last “at …” line shows the call from \sphinxcode{\sphinxupquote{Main}}.  We made the first call to
\sphinxcode{\sphinxupquote{DoRemainder}} so it had non\sphinxhyphen{}zero parameters and worked fine, and the problem came in the
second call, from what line? 10.

\end{enumerate}

\sphinxAtStartPar
In summary, look at the general description of the error in the second line, and then follow the
chain of functions in which the error appeared by look at the line numbers after the colons at the \sphinxstyleemphasis{ends}
of the long “at …” lines.

\sphinxAtStartPar
In this case, we passed bad data to a function in the program source.
Now let us look at what happens if we pass bad data to a C\# library function:

\sphinxAtStartPar
Run the program again giving non\sphinxhyphen{}zero integers twice, to successfully pass the DoRemainder calls.

\sphinxAtStartPar
The next prompt is for a string.  Enter a short word like “hi”.  You should see output with
hi” and then “hihi”.  This looks like a silly but simple sequence showing any string twice.

\sphinxAtStartPar
Not so fast.  The DoSTwice function gets called again, asking for another string.
Try the \sphinxstyleemphasis{exact} string “set \{5\}”.  What a torrent!  The traceback output is way longer.
We will cut out some again, number lines, and explain:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Unhandled Exception:

\item {} 
\sphinxAtStartPar
System.FormatException: Index (zero based) must be greater than or equal to zero
and less than the size of the argument list.

\item {} 
\sphinxAtStartPar
at System.Text.StringBuilder.AppendFormat …

\item {} 
\sphinxAtStartPar
at System.String.Format …

\item {} 
\sphinxAtStartPar
at System.IO.TextWriter.WriteLine …

\item {} 
\sphinxAtStartPar
at System.IO.TextWriter+SyncTextWriter.WriteLine …

\item {} 
\sphinxAtStartPar
at (wrapper synchronized) System.IO.TextWriter …

\item {} 
\sphinxAtStartPar
at System.Console.WriteLine …

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.ShowTwice (System.String s) {[}0x00001{]} in
\sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:38

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.DoSTwice () {[}0x0000d{]} in
\sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:33

\item {} 
\sphinxAtStartPar
at IntroCS.Traceback.Main () {[}0x00006{]} in \sphinxstyleemphasis{pathToSolution}/examples/traceback/traceback.cs:10

\end{enumerate}

\sphinxAtStartPar
Discussion:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In traceback line \#2, we see it is a formating exception,
and the part afterward indicates a problem with the indexing.

\item {} 
\sphinxAtStartPar
In lines \#3\sphinxhyphen{}8, notice that all the classes start with System….
They are library classes:  I would strongly doubt the error was in the C\# library system code.  Presumably
the program passed some bad data to the System functions, which then went through a long chain before
actually triggering the Exception!

\item {} 
\sphinxAtStartPar
The System call closest to the class inside the program is at \#8:  \sphinxcode{\sphinxupquote{WriteLine}} \sphinxhyphen{} certainly used,
and does involve formatting.

\item {} 
\sphinxAtStartPar
The functions actually in the program are in \#9\sphinxhyphen{}11.  The innermost call is in \#9 \sphinxcode{\sphinxupquote{ShowTwice}}.
Now it makes sense to look at the program line numbers:
38 \sphinxhyphen{} that is the more complcated call to \sphinxcode{\sphinxupquote{WriteLine}}.

\item {} 
\sphinxAtStartPar
You can follow the calls up:  \sphinxcode{\sphinxupquote{ShowTwice}} called from program line 33 in \sphinxcode{\sphinxupquote{DoSTwice}}.

\item {} 
\sphinxAtStartPar
The outermost call is from \sphinxcode{\sphinxupquote{Main}}.  We cannot explain the line number here (10) for sure.
It is either from a bug in Xamarin
or it may be that the compiler does some optimization that messes up line numbers slightly \sphinxhyphen{} be warned, this does happen.

\end{itemize}

\sphinxAtStartPar
So to understand, we need to look at the data actually passed to \sphinxcode{\sphinxupquote{Console.WriteLine}} in program line 38.
If you used the data that I gave, \sphinxcode{\sphinxupquote{s}} is \sphinxcode{\sphinxupquote{"set \{5\}"}}
and the expressions in the two string parameters evaluate
so the statement is in effect
\sphinxcode{\sphinxupquote{Console.WriteLine("string: set \{5\} \textbackslash{}nTwice: \{0\}", "set \{5\}set\{5\}")}}.  If you now look back at the description of the error, it talks about a bad index, and you see that the \sphinxcode{\sphinxupquote{"\{5\}"}} embedded in the
\sphinxstyleemphasis{format string}, so it is interpreted to be looking for a parameter with index 5, and there is none.

\sphinxAtStartPar
This particular example is a cautionary tale about
embedding an arbitrary string in a format string.  Format strings actually form an embedded language
inside of C\#, which is interpreted at runtime, not compile time.

\sphinxAtStartPar
It turns out that there are major security issues with such embeddings in other circumstances.  For example
embedding unfiltered user text in SQL queries is a major source of network intrusion.  This is still true after many years, though the exploit,
\sphinxstyleemphasis{SQL injection}, is well known!

\sphinxAtStartPar
Line numbers are not tremendous helpful if the error line has a very involved calculation, and you do
not know what part is messed up.  If you find that there is an error on such a line, it pays to split
the statement up and have a number of separate assignment statements (on different lines), and then see what part triggers the error.

\index{debugging@\spxentry{debugging}!print statements@\spxentry{print statements}}\ignorespaces 

\subsection{Other Debugging}
\label{\detokenize{functions/traceback:other-debugging}}\label{\detokenize{functions/traceback:index-1}}
\sphinxAtStartPar
Though we did use the error traceback for finding errors in \sphinxcode{\sphinxupquote{traceback.cs}}, we also threw in
the most basic way of tracing errors:  we have several print statements that just indicate where the execution is.  Can you find them?  Print statements are particularly useful to put in key places
when the program does \sphinxstyleemphasis{not} bomb out, but just produces the wrong answer.
They can indicate location and current, possibly wrong values.
You do want to remove the print statements before the final version!  Still they can be very handy during development.

\sphinxAtStartPar
They are also useful with involved statements.  You can split up a complicated statement,
making multiple assignments
for important pieces, and print out the intermediate results.


\subsubsection{Interpret the traceback for another error}
\label{\detokenize{functions/traceback:interpret-the-traceback-for-another-error}}
\sphinxAtStartPar
What other kind of runtime error could be forced in the \sphinxcode{\sphinxupquote{traceback.cs}} program?  The program uses
\sphinxcode{\sphinxupquote{UIF}} which in not bulletproof if you enter a response that is not planned for (unlike the UI class
coming later).

\sphinxAtStartPar
Cause a runtime exception running \sphinxcode{\sphinxupquote{traceback.cs}}, triggered in a call to a UIF function.
Look carefully at the error traceback, and make sure you thoroughly understand it.

\sphinxstepscope

\index{function@\spxentry{function}!summary of syntax@\spxentry{summary of syntax}}\ignorespaces 

\section{Static Function Summary}
\label{\detokenize{functions/funcsummary:static-function-summary}}\label{\detokenize{functions/funcsummary:index-0}}\label{\detokenize{functions/funcsummary:id1}}\label{\detokenize{functions/funcsummary::doc}}
\sphinxAtStartPar
This chapter has introduced static functions:  those used in procedural programming
as opposed to {\hyperref[\detokenize{classes/a-first-class:instance-methods}]{\sphinxcrossref{\DUrole{std,std-ref}{Instance Methods}}}} used to
implement object\sphinxhyphen{}oriented programming.

\sphinxAtStartPar
References in square brackets link to fully discussions of summary items below.

\index{( )@\spxentry{( )}!function definition@\spxentry{function definition}}\ignorespaces 

\subsection{Function definition}
\label{\detokenize{functions/funcsummary:function-definition}}\label{\detokenize{functions/funcsummary:index-1}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The general syntax for defining a static function is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{static}} \sphinxstylestrong{returnTypeOrVoid} \sphinxstylestrong{FunctionName} \sphinxcode{\sphinxupquote{(}}  formal parameter list \sphinxcode{\sphinxupquote{)}}
\item[] \sphinxcode{\sphinxupquote{\{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statements in the function body…
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{formal parameter list} can be empty or contain one or more comma separated
\sphinxstyleemphasis{formal parameter} entries.  {[}{\hyperref[\detokenize{functions/funcparam:function-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Function Parameters}}}}{]}
Each formal parameter entry has the form
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type} \sphinxstylestrong{parameterName}
\end{quote}

\item {} 
\sphinxAtStartPar
If the function is going to be called from outside its class, the heading needs
to start with \sphinxcode{\sphinxupquote{public}} before the \sphinxcode{\sphinxupquote{static}}. {[}{\hyperref[\detokenize{functions/libraryclass:library-classes}]{\sphinxcrossref{\DUrole{std,std-ref}{Library Classes}}}}{]}

\item {} 
\sphinxAtStartPar
If \sphinxstylestrong{returnTypeOrVoid} in the heading is not \sphinxcode{\sphinxupquote{void}}, there must be a
\sphinxstyleemphasis{return statement} in the function body.  A return statement has the form
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{return}} \sphinxstyleemphasis{expression} \sphinxcode{\sphinxupquote{;}}
\end{quote}

\sphinxAtStartPar
where the expression should be of the same type as in \sphinxstylestrong{returnTypeOrVoid}.
Execution of the function terminates immediately when a return statement
is reached. {[}{\hyperref[\detokenize{functions/funcreturn:returned-function-values}]{\sphinxcrossref{\DUrole{std,std-ref}{Returned Function Values}}}}{]}

\item {} 
\sphinxAtStartPar
Execution of a program starts at a function with a heading including
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{static void Main}}
\end{quote}

\sphinxAtStartPar
Thus far we have only discussed having an empty parameter list in the heading
of the definition
of \sphinxcode{\sphinxupquote{Main}}, and we defer discussion of {\hyperref[\detokenize{arrays/onedim:command-line-param}]{\sphinxcrossref{\DUrole{std,std-ref}{Parameters to Main}}}} until
we have introduced {\hyperref[\detokenize{arrays/onedim:one-dim-arrays}]{\sphinxcrossref{\DUrole{std,std-ref}{One Dimensional Arrays}}}}.

\item {} 
\sphinxAtStartPar
There are various conventions for putting documentation just above the headings
of function definitions.  The official format, specified by C\# and recognized by
Xamarin Studio, involves putting the function interface description on
consecutive lines
starting with \sphinxcode{\sphinxupquote{///}}.  {[}{\hyperref[\detokenize{functions/libraryclass:function-documentation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function Documentation}}}}{]}

\end{enumerate}

\index{( )@\spxentry{( )}!function call@\spxentry{function call}}\ignorespaces 

\subsection{Function Calls}
\label{\detokenize{functions/funcsummary:function-calls}}\label{\detokenize{functions/funcsummary:index-2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A function call takes the form

\sphinxAtStartPar
\sphinxstylestrong{FunctionName} \sphinxcode{\sphinxupquote{(}}  actual parameter list \sphinxcode{\sphinxupquote{)}}

\sphinxAtStartPar
A function call makes the function definition be \sphinxstyleemphasis{executed}.

\item {} 
\sphinxAtStartPar
The actual parameter list is a comma separated list of the \sphinxstyleemphasis{same}
length as the formal parameter list.  Each entry is an expression.
The entries in an actual parameter list do \sphinxstyleemphasis{not} include type declarations.

\sphinxAtStartPar
Effectively, the function execution starts by assigning to each
formal parameter variable the corresponding value from
evaluating the actual parameter expression.
In particular, that means the actual parameter values must be allowed
in an assignment statement for a variable of the formal parameter’s type!
{[}{\hyperref[\detokenize{functions/funcparam2:more-func-param}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiple Function Parameters}}}}{]}

\item {} 
\sphinxAtStartPar
If the function has return type \sphinxcode{\sphinxupquote{void}}, it can only be used syntactically
as an entire statement (with a semicolon added). After the function
call completes, execution continues with the next statement.

\item {} 
\sphinxAtStartPar
If there is a non\sphinxhyphen{}void return type, then the function call is syntactically
an expression in the statement where is appears.
The execution of such a function must reach a return statement.  The value
of the function\sphinxhyphen{}call expression is the value of the expression in this
return statement.
{[}{\hyperref[\detokenize{functions/funcreturn:returned-function-values}]{\sphinxcrossref{\DUrole{std,std-ref}{Returned Function Values}}}}{]}

\item {} 
\sphinxAtStartPar
A function with a return value can also legally be used as a whole statement.
In this case the return value is lost.  Though legal, this is often an error!
{[}{\hyperref[\detokenize{functions/notusereturn:not-using-ret-val}]{\sphinxcrossref{\DUrole{std,std-ref}{Not using Return Values}}}}{]}

\end{enumerate}


\subsection{Scope}
\label{\detokenize{functions/funcsummary:scope}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A variable declared inside a function definition is called a \sphinxstyleemphasis{local variable}.
This declaration may be in either the formal parameter
list or in the body of the function.  {[}{\hyperref[\detokenize{functions/localscope:local-scope}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Scope}}}}{]}

\item {} 
\sphinxAtStartPar
A local variable comes into existence after the function is called, and ceases
to exist after that function call terminates.  A local variable is invisible
to the rest of the program.  Its \sphinxstyleemphasis{scope} is just within that function.  Its
lifetime is just through a single
function call.  Its \sphinxstyleemphasis{value} may be transferred outside of the function scope
by standard means, principally:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If it is the expression in a return statement, its value is
sent back to the caller.

\item {} 
\sphinxAtStartPar
It can be passed as an
actual parameter to a further function called within its scope.

\end{itemize}

\sphinxAtStartPar
{[}{\hyperref[\detokenize{functions/localscope:local-scope}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Scope}}}}{]}

\end{enumerate}


\subsection{Static Variables}
\label{\detokenize{functions/funcsummary:static-variables}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
There may be a declaration prefaced by the word \sphinxcode{\sphinxupquote{static}} that appears
\sphinxstyleemphasis{inside} a class and \sphinxstyleemphasis{outside} of any function definition in the class.
Static variables are visible within each function of the class, and may
be used by the functions.  {[}{\hyperref[\detokenize{functions/staticvariables:static-variables}]{\sphinxcrossref{\DUrole{std,std-ref}{Static Variables}}}}{]}

\item {} 
\sphinxAtStartPar
A common use of a static variable is to give a name to a constant
value used in multiple functions in the class.
{[}{\hyperref[\detokenize{functions/staticvariables:static-variables}]{\sphinxcrossref{\DUrole{std,std-ref}{Static Variables}}}}{]}

\end{enumerate}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{functions/reviewfunc:chapter-review-questions}}\label{\detokenize{functions/reviewfunc::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Write the function definition heading for a static function called
\sphinxcode{\sphinxupquote{Q1}} which
has two \sphinxcode{\sphinxupquote{int}} parameters, \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}, and returns a \sphinxcode{\sphinxupquote{double}}.

\item {} 
\sphinxAtStartPar
The function above must have what kind of a statement in its body?

\item {} 
\sphinxAtStartPar
Each of these lines has a call to the function above, \sphinxcode{\sphinxupquote{Q1}}.  Which
are legal?  Explain:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Q1}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Q1}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Q1}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{5.5}\PYG{p}{;}

\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}2\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}5\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{(}\PYG{l+m}{2.5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Q1}\PYG{p}{(}\PYG{l+m}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{20}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Suppose \sphinxcode{\sphinxupquote{Q1}} does nothing except produce the value to return, like
most functions returning a \sphinxcode{\sphinxupquote{double}}.  Which
line in the previous problem is legal, but has \sphinxstyleemphasis{no} effect?

\item {} 
\sphinxAtStartPar
Write the function definition heading for a static function called
\sphinxcode{\sphinxupquote{Q4}} which
has one \sphinxcode{\sphinxupquote{string}} parameter, \sphinxcode{\sphinxupquote{s}}, and returns nothing.

\item {} 
\sphinxAtStartPar
Which of these lines with a call to the function above, \sphinxcode{\sphinxupquote{Q4}},
is legal?  Explain:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Q4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Q4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{Q4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Q4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}ho\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Q4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}ho\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Q4}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Can you have more than one function/method in the same
class definition with the same name?

\item {} 
\sphinxAtStartPar
What is a function/method signature?
Can you have more than one function/method declared in the same
class definition with the same signature?

\item {} 
\sphinxAtStartPar
In each part,
is this a legal program?  If so, what is printed?  If not, why not?

\sphinxAtStartPar
Each version uses the same code, except for different versions of
\sphinxcode{\sphinxupquote{Main}}.  Here is the common code with the body of \sphinxcode{\sphinxupquote{Main}} omitted:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Local1}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Q}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{// 1}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{                    }\PYG{c+c1}{// 2}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}\PYG{+w}{        }\PYG{c+c1}{// 3}
\PYG{+w}{      }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}\PYG{+w}{        }\PYG{c+c1}{// 4}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{// 5}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}\PYG{+w}{                    }\PYG{c+c1}{// 6}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{// see each version}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Insert:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Q}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Insert instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Q}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Insert instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{                   }\PYG{c+c1}{// 7}
\PYG{p}{\PYGZob{}}\PYG{+w}{                                    }\PYG{c+c1}{// 8}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{                 }\PYG{c+c1}{// 9}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Q}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                         }\PYG{c+c1}{// 10}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// 11}
\PYG{p}{\PYGZcb{}}\PYG{+w}{                                    }\PYG{c+c1}{// 12}
\end{sphinxVerbatim}

\end{enumerate}

\item {} 
\sphinxAtStartPar
In the previous problem consider the common code with part c.
Note the line numbers as comments.
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
In what line(s) is \sphinxcode{\sphinxupquote{Q}} being defined?

\item {} 
\sphinxAtStartPar
In what line(s) is \sphinxcode{\sphinxupquote{Q}} called?

\item {} 
\sphinxAtStartPar
What is the return type of \sphinxcode{\sphinxupquote{Q}}?

\item {} 
\sphinxAtStartPar
What is a formal parameter to \sphinxcode{\sphinxupquote{Q}}?

\item {} 
\sphinxAtStartPar
What is used as an actual parameter to \sphinxcode{\sphinxupquote{Q}}?

\item {} 
\sphinxAtStartPar
What is the scope of the \sphinxcode{\sphinxupquote{x}} in line 3?

\item {} 
\sphinxAtStartPar
What is the scope of the \sphinxcode{\sphinxupquote{x}} in line 9?

\end{enumerate}

\end{enumerate}

\sphinxstepscope


\chapter{Basic String Operations}
\label{\detokenize{basicstringops/basicstringops:basic-string-operations}}\label{\detokenize{basicstringops/basicstringops:basic-string-ops}}\label{\detokenize{basicstringops/basicstringops::doc}}
\sphinxstepscope
\phantomsection\label{\detokenize{basicstringops/stringindexing:string-indexing}}
\index{string@\spxentry{string}!index {[} {]}@\spxentry{index {[} {]}}}\index{{[} {]}@\spxentry{{[} {]}}!string index@\spxentry{string index}}\ignorespaces 

\section{String Indexing}
\label{\detokenize{basicstringops/stringindexing:index-0}}\label{\detokenize{basicstringops/stringindexing:id1}}\label{\detokenize{basicstringops/stringindexing::doc}}
\sphinxAtStartPar
Strings are composed of characters.  In literals be careful of the different
kinds of quotes: single for individual characters for type \sphinxcode{\sphinxupquote{char}} and double for strings
of 0 or more characters.  For example,
\sphinxcode{\sphinxupquote{\textquotesingle{}u\textquotesingle{}}} (single quotes) is a char type literal, while \sphinxcode{\sphinxupquote{"u"}} is a string
literal, referencing a string object. While \sphinxcode{\sphinxupquote{"you"}} is a legal string
literal, \sphinxcode{\sphinxupquote{\textquotesingle{}you\textquotesingle{}}} generates a compiler error
(too many characters for a char literal).

\sphinxAtStartPar
Many of the operations on strings depend upon referring to the
positions of characters in the string.
A position is given by a numerical \sphinxstyleemphasis{index} number.
In C\#, positions are counted \sphinxstyleemphasis{starting at 0}, not 1.
The indices of the characters in the string “coding” are labeled:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline

\sphinxAtStartPar
Index
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
5
\\
\hline
\sphinxAtStartPar
Character
&
\sphinxAtStartPar
c
&
\sphinxAtStartPar
o
&
\sphinxAtStartPar
d
&
\sphinxAtStartPar
i
&
\sphinxAtStartPar
n
&
\sphinxAtStartPar
g
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
There are 6 characters in \sphinxcode{\sphinxupquote{"coding"}}, while the last index is 5.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Because the indices start at 0, not 1,
the index of the last character is one less that the length of the
string. This is a common source of errors!
\end{sphinxadmonition}

\sphinxAtStartPar
You can easily create an expression that refers
to an individual character inside a string.  Use
square braces around the index of the character:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}coding\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{\PYGZsq{}d\PYGZsq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{\PYGZsq{}c\PYGZsq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{\PYGZsq{}g\PYGZsq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{greeting}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Bonjour\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{greeting}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{\PYGZsq{}o\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note from the single quotes that the result is a \sphinxcode{\sphinxupquote{char}} in each case.

\index{subscript@\spxentry{subscript}}\ignorespaces 
\sphinxAtStartPar
C\# does not allow the typography for normal mathematical subscripts,
like \(s_2\).
There is a correspondence with index notation, so \sphinxcode{\sphinxupquote{s{[}2{]}}} is
sometimes spoken as “s sub 2”.  The indices are sometimes referred to as
\sphinxstyleemphasis{subscripts}.

\sphinxAtStartPar
In this introduction, we have used literal integers for the subscripts.
The most common situation in practice is to have a variable or a more
complicated expression as the
subscript.  An expression inside square braces is always
evaluated to find the resulting index:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}coding\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{\PYGZsq{}d\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When we get to loops, we will find this is useful.


\subsection{Indexing Exercise}
\label{\detokenize{basicstringops/stringindexing:indexing-exercise}}
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}fragment\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{str}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{str}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{str}\PYG{p}{[}\PYG{l+m}{2}\PYG{o}{*}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Write an expression that would give you the n in \sphinxcode{\sphinxupquote{str}}, above.

\sphinxAtStartPar
Play with csharp:  declare other strings and \sphinxcode{\sphinxupquote{int}} variables, and make up
string indexing expressions for which you predict the value and then test.

\sphinxstepscope

\index{string@\spxentry{string}!method@\spxentry{method}}\index{.@\spxentry{.}!object field reference@\spxentry{object field reference}}\ignorespaces 

\section{Some Instance Methods and the Length Property}
\label{\detokenize{basicstringops/stringmethods:some-instance-methods-and-the-length-property}}\label{\detokenize{basicstringops/stringmethods:index-0}}\label{\detokenize{basicstringops/stringmethods::doc}}
\sphinxAtStartPar
Strings are a special type in C\#. We have
used string literals as parameters to functions and we have used the
special concatenation operator \sphinxcode{\sphinxupquote{+}}.
Thus far we have not emphasized the use of objects, or even noted
what is an object.  In fact strings are objects.  Like other objects,
strings have a general notation for functions that are specially tied to the
particular type of object.  These functions are called \sphinxstyleemphasis{instance methods}.
They always act on an object of the particular class, but a reference to the
object is not placed inside the parameter list, but \sphinxstyleemphasis{before} the method name and
a dot as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}hello\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}HELLO\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ToUpper}} (the method converting to upper case)
does a particular action that makes sense
with strings.  It takes \sphinxcode{\sphinxupquote{s}}
(the string object reference before the dot in this example)
and returns a \sphinxstyleemphasis{new} string in upper case, based on \sphinxcode{\sphinxupquote{s}}.  Since this action
depends only on the string itself, no further parameters are necessary,
and the parentheses after the method name are empty.  The general method syntax is
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{object\sphinxhyphen{}reference}\sphinxcode{\sphinxupquote{.}}\sphinxstylestrong{methodName} \sphinxcode{\sphinxupquote{(}}\sphinxstyleemphasis{further\sphinxhyphen{}parameters} \sphinxcode{\sphinxupquote{)}}
\end{quote}

\sphinxAtStartPar
More string methods are listed below, some with further parameters.

\index{property@\spxentry{property}}\index{class@\spxentry{class}!property@\spxentry{property}}\ignorespaces 
\sphinxAtStartPar
Data can also be associated with object \sphinxstyleemphasis{properties}.
A property of a string is its \sphinxcode{\sphinxupquote{Length}} (an \sphinxcode{\sphinxupquote{int}}).  References to property values
use dot notation but do not have a parameter list in parentheses at the end:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Hello\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Be careful: Though 5 is the length of \sphinxcode{\sphinxupquote{s}} in the example above,
the last character in \sphinxcode{\sphinxupquote{s}} is \sphinxcode{\sphinxupquote{s{[}4{]}}}.  Using \sphinxcode{\sphinxupquote{s{[}5{]}}} would generate
an \sphinxcode{\sphinxupquote{IndexOutOfRangeException}}.

\sphinxAtStartPar
String objects have associated string methods which can be used to
manipulate string values.
There are an enormous number of string methods, but here are just a few
of the most common ones to get you started. The
string object to which the method is being applied is referred to as
\sphinxstylestrong{this} string in the descriptions.  After the methods,
the length property is also listed.
In the heading \sphinxstyleemphasis{this} object is not shown explicitly, so be careful
when applying these methods and the length property: In actual use
in your programs they must be
preceded by a reference to a string, followed by a dot, as shown in
all the  examples.  The reference to \sphinxstyleemphasis{this} string can be
a variable name, a literal, or any expression evaluating to a string.


\subsection{Summary of String Length and Some Instance Methods}
\label{\detokenize{basicstringops/stringmethods:summary-of-string-length-and-some-instance-methods}}\label{\detokenize{basicstringops/stringmethods:string-methods-length}}\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{int IndexOf(string target)}}}
\sphinxAtStartPar
Returns the index of the beginning of the first occurrence of the
string \sphinxcode{\sphinxupquote{target}}
in \sphinxstylestrong{this} string object. Returns \sphinxhyphen{}1 if \sphinxcode{\sphinxupquote{target}} not found. Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{greeting}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Bonjour\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{part}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}jo\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{n}{part}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}jot\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}
\end{sphinxVerbatim}

\sphinxlineitem{\sphinxcode{\sphinxupquote{string Substring(int start)}}}
\sphinxAtStartPar
Returns the substring of \sphinxstylestrong{this} string object starting from index \sphinxcode{\sphinxupquote{start}}
through to the end of the string object.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Sheryl Crow\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}Crow\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxlineitem{\sphinxcode{\sphinxupquote{string Substring(int start, int len)}}}
\sphinxAtStartPar
Returns the substring of \sphinxstylestrong{this} string object starting from index \sphinxcode{\sphinxupquote{start}},
including a total of \sphinxcode{\sphinxupquote{len}} characters.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Sheryl Crow\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}ryl C\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Java programmers:  Note the second parameter is \sphinxstyleemphasis{not} the same as in Java.

\sphinxlineitem{\sphinxcode{\sphinxupquote{string ToUpper()}}}
\sphinxAtStartPar
Return a string like \sphinxstylestrong{this} string, except all in upper case.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Hi Jane!\PYGZdq{}}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}HI JANE!\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxlineitem{\sphinxcode{\sphinxupquote{string ToLower()}}}
\sphinxAtStartPar
Return a string like \sphinxstylestrong{this} string, except all in lower case.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Hi Jane!\PYGZdq{}}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}hi jane!\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxlineitem{\sphinxcode{\sphinxupquote{int Length}}}
\sphinxAtStartPar
Property referring to the length of \sphinxstylestrong{this} string object. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{greeting}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Bonjour\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{greeting}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//no parentheses}
\PYG{l+m}{7}
\end{sphinxVerbatim}

\end{description}

\index{immutable@\spxentry{immutable}}\ignorespaces 
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
All of these methods that return a string return a \sphinxstyleemphasis{new} string.  No string method
alters the original string.  Strings are \sphinxstyleemphasis{immutable}:
They are objects that cannot be changed
after they are first produced.  This is a common source of errors.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Hello\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}
\PYG{l+s}{\PYGZdq{}HELLO\PYGZdq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}
\PYG{l+s}{\PYGZdq{}Hello\PYGZdq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}
\PYG{l+s}{\PYGZdq{}HELLO\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See that you need an explicit assignment if you \sphinxstyleemphasis{want} the variable associated
with the original string to change.

\sphinxAtStartPar
Further string methods are introduced in {\hyperref[\detokenize{while/stringmethods2:more-string-methods}]{\sphinxcrossref{\DUrole{std,std-ref}{More String Methods}}}}.

\sphinxAtStartPar
Time to reflect, thinking back to {\hyperref[\detokenize{data/learning-to-problem-solve:learn-solve}]{\sphinxcrossref{\DUrole{std,std-ref}{Learning to Solve Problems}}}}.
Without forcing all the code details on yourself,
how can you concisely say what powers you have with strings so far?
Remember that kernel.

\sphinxAtStartPar
With strings you can:
Index characters, find a part; extract a part; convert case; determine length.
These may not be evocative phrases for you.  Find your own.

\sphinxAtStartPar
When we get to loops, we will find this is useful.

\sphinxAtStartPar
Here is a brief example of a function using several of these methods,

\sphinxAtStartPar
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/parenthesized/parenthesized.cs}{parenthesized/parenthesized.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Parenthesized}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}What (really) happened?\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Original: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}In parentheses: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{InsideParen}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{c+c1}{/// Assume s contains parentheses.}
\PYG{+w}{   }\PYG{c+c1}{/// Return the substring between the first parentheses.}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{InsideParen}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{first}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}(\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{past}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{})\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{len}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{past}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{first}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is a silly assumption, but until we get to {\hyperref[\detokenize{decisions/decisions:if-statements}]{\sphinxcrossref{\DUrole{std,std-ref}{Decisions}}}},
we will have to assume there \sphinxstyleemphasis{is}
a parenthesized expression in the parameter string.


\subsubsection{String Methods Exercise}
\label{\detokenize{basicstringops/stringmethods:string-methods-exercise}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}quickly\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{n}{w}\PYG{p}{.}\PYG{n}{Length}\PYG{o}{\PYGZhy{}}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}ti\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{w}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}ick\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}c\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{} \PYGZob{}3\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{   }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{[}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m}{3}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}HELLO!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{o}{+}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
Play with csharp:  Declare other strings and make up
string expressions with these methods
for which you predict the value and then test.

\sphinxstepscope

\index{string@\spxentry{string}!problem solving@\spxentry{problem solving}}\index{problem solving@\spxentry{problem solving}}\ignorespaces 

\section{A Creative Problem Solution}
\label{\detokenize{basicstringops/problem-solving-replace:a-creative-problem-solution}}\label{\detokenize{basicstringops/problem-solving-replace:solve-string-replace}}\label{\detokenize{basicstringops/problem-solving-replace:index-0}}\label{\detokenize{basicstringops/problem-solving-replace::doc}}
\sphinxAtStartPar
Thus far the exercises and examples suggested have been of
a very simple form, where the idea of the steps should
have been pretty clear, and the main issue was just
translating syntax into C\#, one instruction at a time.

\sphinxAtStartPar
We still have a lot of syntax to concentrate on,
but still, early on, we wanted to get in some real thought
of problem solving.  To get very interesting you
need a number of options that might be combined in
a variety of ways.  The short list of
string methods just introduced
is likely give us enough to think about….

\sphinxAtStartPar
Here is a basic string manipulation problem:
given a string, like,
\sphinxcode{\sphinxupquote{"It was the best of times."}},
find and replace a specified part of it by another string.
For instance replace \sphinxcode{\sphinxupquote{"best"}} by \sphinxcode{\sphinxupquote{"worst"}}.
In this example we would get the result:
\sphinxcode{\sphinxupquote{"It was the worst of times."}}.

\sphinxAtStartPar
It is very important to give concrete examples to
illustrate the idea desired.  Our human brains may be
very quick to see a solution like this in a very
concrete case, but what about making it general?

\sphinxAtStartPar
First this seems like a basic logical operation worthy
of a function or method, so we need a heading.
(Confession:  there are methods in the class
string for replacement, but this is a good learning exercise,
so we are starting over on our own.)  Since
we cannot change the string class, we will write a
static function to generate the new string.

\sphinxAtStartPar
For simplicity at the moment we will only change
the first occurrence, and for now we will assume the
replacement makes sense.  The following heading
(with documentation) should work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return s with the first occurence of target}
\PYG{c+c1}{/// replaced by replacement.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{replaceFirst}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{,}
\PYG{+w}{                           }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{replacement}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As soon as we have the calling interface, it is good to be thinking
of the tests it should pass.  Here is a Main program written
to test the function in different ways and display the results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}It was the best of times.\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Of times it was the best.\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}str1=\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{str1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}str2=\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{str2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// to embed a quote inside a string constant, precede it by backslash(\PYGZbs{}).}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Let us do some \PYGZbs{}\PYGZdq{}cutting and pasting\PYGZbs{}\PYGZdq{} of strings!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}best\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}worst\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}str3 = str1 with best =\PYGZgt{} worst: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{str3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str4}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}best\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}worst\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}str2 with best =\PYGZgt{} worst: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{str4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{str5}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}worst\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}best\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}str3 with worst =\PYGZgt{} best: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{str5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Writing tests \sphinxstyleemphasis{first} is a good idea to focus you on what really
needs to be accomplished, and then running tests later is a snap!

\sphinxAtStartPar
The human brain and eyes are fabulous in the way they process
many things in parallel and use tools you have accumulated over
a lifetime.  In particular this substitution idea should
seem pretty reasonable, and given any \sphinxstyleemphasis{specific concrete} example,
you are likely to be able to solve it instantly, with very little
conscious effort.  Once it becomes a programming problem, with
parameters stated in general, with just placeholder names
like \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{target}}, and given the limited set of approaches
you have in a programming language, then the complexion of this
problem changes completely.  Many students guess the general problem will
be nearly as simple as the concrete examples they do in their heads,
and then get very discouraged when the answer does not flow out of
them.  In fact it takes practice and experience, and it is easier
to handle if you acknowledge that up front!

\sphinxAtStartPar
So let’s start in with the practice, and gain some experience.
With \sphinxcode{\sphinxupquote{s}}, \sphinxcode{\sphinxupquote{target}}, and \sphinxcode{\sphinxupquote{replacement}} all being general, this
problem could easily be too much to contemplate at once,
so let us replace \sphinxstyleemphasis{concrete} examples by generality gradually.
The idea is to get to the end.  Rather than trying to jump a chasm,
we can take small steps and go around.

\sphinxAtStartPar
A basic idea is to make small incremental
changes, test at each stage, and gradually see more of the tests
(that you have already written) be satisfied.  Also, if you make a
mistake and screw up something that worked before, you can generally
focus on the small addition to see where the mistakes were.
%
\begin{footnote}[1]\sphinxAtStartFootnote
We will not go far into the history of software engineering
practice here, but these incremental problem solving methods
were first widely
introduced as a part of \sphinxstyleemphasis{extreme programming}.
That name gives you an idea of the newness at the time.
%
\end{footnote}

\sphinxAtStartPar
This also avoids you needing to keep too much in your head at once.

\sphinxAtStartPar
We do have code written already:  The test code.  Start by writing
something that will trivially satisfy the first concrete test.
The body of the function can be just:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}It was the worst of times\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a tiny, easy, silly looking step, but it does accomplish
two things:  It makes sure we can produce output
in the proper string form, and the test code runs, passing the
first test.

\sphinxAtStartPar
Now we gradually get more complicated.  We will continue to assume
\sphinxcode{\sphinxupquote{target}} and \sphinxcode{\sphinxupquote{replacement}} are as in the original example,
and \sphinxcode{\sphinxupquote{target}} is in the same place in \sphinxcode{\sphinxupquote{s}},
but suppose we imagine each
of the other characters in \sphinxcode{\sphinxupquote{s}} may be something different:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}???????????best??????????\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we have to start thinking about what we have to work with.
We have a string, and we have string methods.
Have a look at the ideas of each method (exact syntax
not important at the moment).  Clearly we are going to have to
deal with parts of strings, and the methods to deal with parts
involve indices, so let us add to our visual model:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Index}\PYG{p}{:}\PYG{+w}{ }\PYG{l+m}{0123456789012345678901234}
\PYG{+w}{    }\PYG{n}{s}\PYG{p}{:}\PYG{+w}{ }\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}\PYG{o}{?}\PYG{n}{best}\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}\PYG{o}{??}
\end{sphinxVerbatim}

\sphinxAtStartPar
Continue in class….  The example program stub is
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/string\_manip\_stub/string\_manip.cs}{string\_manip\_stub/string\_manip.cs}.

\sphinxAtStartPar
In general, when given a
project with “stub” in it, you should copy the files into a project
of your own and make modifications.  Though the original version
should compile and run, it does not do much without your additions.
In stubs where you need to
complete a function with a return value, you will often see
a dummy choice for the return statement, just so the stub compiles.
Where the return type is string \sphinxcode{\sphinxupquote{"Not implemented"}} is a handy
temporary choice.

\sphinxAtStartPar
When you have that function version, test it.
You will need to rename
our incremental variations so the current version has the name
used in Main.

\sphinxAtStartPar
What might further advances toward full generality be,
in small steps?  We pinned \sphinxcode{\sphinxupquote{best}} at a specific location.
We could remove that assumption.  The location will still be
important, but we do not know it ahead of time….

\sphinxAtStartPar
A further advance would be a version that is complete
in all ways, except we still assume \sphinxcode{\sphinxupquote{target}} is in \sphinxcode{\sphinxupquote{s}},
but beyond that, do not assume what the three parameters are.

\sphinxAtStartPar
Finally we should allow \sphinxcode{\sphinxupquote{s}} to not contain \sphinxcode{\sphinxupquote{target}}
(though this requires the central idea of the next chapter).

\sphinxAtStartPar
The testing regime in \sphinxcode{\sphinxupquote{Main}} is clear to understand and write,
but pretty primitive.  You have to look at a lot of output
every time you test.  We will come up with better testing schemes
later.

\sphinxstepscope
\phantomsection\label{\detokenize{basicstringops/lab-string-ops:lab-string-ops}}
\index{labs@\spxentry{labs}!string manipulations@\spxentry{string manipulations}}\ignorespaces 

\section{Lab: String Operations}
\label{\detokenize{basicstringops/lab-string-ops:lab-string-operations}}\label{\detokenize{basicstringops/lab-string-ops:index-0}}\label{\detokenize{basicstringops/lab-string-ops::doc}}

\subsection{Goals for this lab:}
\label{\detokenize{basicstringops/lab-string-ops:goals-for-this-lab}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Explore some of the properties of the pre\sphinxhyphen{}defined String class.

\item {} 
\sphinxAtStartPar
Write conditional statements.

\item {} 
\sphinxAtStartPar
Think about problem solving.

\end{enumerate}

\sphinxAtStartPar
This lab depends on the introductory material earlier in this
chapter, particularly keep handy {\hyperref[\detokenize{basicstringops/stringmethods:string-methods-length}]{\sphinxcrossref{\DUrole{std,std-ref}{Summary of String Length and Some Instance Methods}}}}.
Be mindful of the processes developed in class filling in
{\hyperref[\detokenize{basicstringops/problem-solving-replace:solve-string-replace}]{\sphinxcrossref{\DUrole{std,std-ref}{A Creative Problem Solution}}}}.

\sphinxAtStartPar
Parts 2 and 4 also depend on {\hyperref[\detokenize{decisions/decisions:if-statements}]{\sphinxcrossref{\DUrole{std,std-ref}{Decisions}}}}
through {\hyperref[\detokenize{decisions/comparisonops:more-conditional-expressions}]{\sphinxcrossref{\DUrole{std,std-ref}{More Conditional Expressions}}}}.

\sphinxAtStartPar
Design, compile and run a single C\# program to accomplish all of
the following tasks. Add one part at a time and test before trying the
next one. The program can just include a Main method, or it is neater to
split things into separate methods (all static void, with names like
ShowLength, SentenceType, LastFirst1, LastFirst),
and have Main call all the ones
you have written so far (or for testing purposes, just the one you
are working on, with the other function calls commented out).
\sphinxstylestrong{Use the UIF class for user input.}  You can copy the file into your project.

\sphinxAtStartPar
Alternately practice using an Xamarin Studio library reference:
Create a new project in a solution
in which you already have added the ui library project.  Make the ui project
be a reference for the lab project.

\sphinxAtStartPar
Make sure your program has \sphinxcode{\sphinxupquote{namespace IntroCS;}} to match the ui project.
Beware of modifying the sample Program.cs generated by Xamarin Studio \sphinxhyphen{} it will use
the project name for a namespace.  We are never going to use that.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Read a string from the keyboard
and print the length of the string, with a label.

\item {} 
\sphinxAtStartPar
Read a sentence (string) from a line of input, and print whether
it represents a \sphinxstyleemphasis{declarative} sentence (i.e. ending in a period),
\sphinxstyleemphasis{interrogatory} sentence (ending in a question mark), or an
\sphinxstyleemphasis{exclamation} (ending in exclamation point) or is not a sentence
(anything else).

\sphinxAtStartPar
This may be the first time you write a conditional
statement. (This needs the next chapter.)
It makes sense to only make small changes at once and build
up to final code. First you might just code it to check if a sentence is
declarative or not. Then remember you can test further cases with
\sphinxcode{\sphinxupquote{else if (...)}}.

\item {} 
\sphinxAtStartPar
Read a \sphinxstyleemphasis{whole} name from a \sphinxstyleemphasis{single} line of user input. Do not ask for
first and last names to be entered on separate lines!
Assume first and last names
are separated by a space (no middle name).
Print last name first followed by a comma
and a space, followed by the first name.
For example, if the input is
\sphinxcode{\sphinxupquote{"Marcel Proust"}}, the output is \sphinxcode{\sphinxupquote{"Proust, Marcel"}}.

\item {} 
\sphinxAtStartPar
Improve the previous part,
so it also allows a single name without spaces,
like “Socrates”, and prints the original without change. If there are
two parts of the name, it should work as in the original version.
(This needs syntax from the next chapter.)

\end{enumerate}

\sphinxAtStartPar
Run the program (with parts 1, 2 and 4 active)
from a terminal window and show your TA when you are
done.  You should run it twice to show off both paths through
part 4.  Alternately have the main program just call part 4 twice!

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{basicstringops/reviewstring:chapter-review-questions}}\label{\detokenize{basicstringops/reviewstring::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}question\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}ti\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}to\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}u\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}o\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Word\PYGZdq{}}\PYG{p}{;}
\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed by this fragment?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Are strings mutable or immutable: which?

\item {} 
\sphinxAtStartPar
What is the distinction syntactically between the use of a
method and a property?

\item {} 
\sphinxAtStartPar
Suppose we have a string \sphinxcode{\sphinxupquote{s}}.
Is this expression legal, or what should it be?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{statement@\spxentry{statement}!if@\spxentry{if}}\index{if@\spxentry{if}}\ignorespaces 

\chapter{Decisions}
\label{\detokenize{decisions/decisions:decisions}}\label{\detokenize{decisions/decisions:if-statements}}\label{\detokenize{decisions/decisions:index-0}}\label{\detokenize{decisions/decisions::doc}}
\sphinxstepscope


\section{Conditions I}
\label{\detokenize{decisions/conditions:conditions-i}}\label{\detokenize{decisions/conditions:simple-conditions}}\label{\detokenize{decisions/conditions::doc}}
\sphinxAtStartPar
Thus far, within a given function, instructions have been executed
sequentially, in the same order as written.  Of course that is often
appropriate!  On the other hands if you are planning your instruction
sequence,
you can get to a place where you say, “Hm, that depends….”, and
a choice must be made.  The simplest choices are two\sphinxhyphen{}way: do one
thing if a condition is true, and another (possibly nothing) if the
condition is not true.

\sphinxAtStartPar
More syntax for conditions will be introduced later,
but for now consider simple arithmetic comparisons that directly
translate from math into C\#. First start csharp an enter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{11}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now think of which of these expressions below are true and which false,
and then enter each one into your csharp session to test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{5}
\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{10}
\PYG{l+m}{2}\PYG{o}{*}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{x}
\end{sphinxVerbatim}

\sphinxAtStartPar
You see the C\# values, either \sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}} (with no
quotes!). These are the only possible \sphinxstyleemphasis{Boolean} values (named after
19th century mathematician George Boole). You can also use the
abbreviation for the type \sphinxcode{\sphinxupquote{bool}}.  It is the type of the
results of true\sphinxhyphen{}false conditions or tests.

\sphinxAtStartPar
The simplest place to use conditions is in a decision made with an
\sphinxcode{\sphinxupquote{if}} statement.

\sphinxAtStartPar
We will consider {\hyperref[\detokenize{decisions/comparisonops:more-conditional-expressions}]{\sphinxcrossref{\DUrole{std,std-ref}{More Conditional Expressions}}}} later, but this is a
quick start with the easiest ones.

\sphinxstepscope


\section{Simple \sphinxstyleliteralintitle{\sphinxupquote{if}} Statements}
\label{\detokenize{decisions/ifstatements:simple-if-statements}}\label{\detokenize{decisions/ifstatements:id1}}\label{\detokenize{decisions/ifstatements::doc}}
\sphinxAtStartPar
Run the example program, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/suitcase/suitcase.cs}{suitcase/suitcase.cs}.
Try it at least twice, with
inputs: 30 and then 55. As you can see, you get an extra result,
depending on the input. The main code is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{weight}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{   }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptDouble}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}How many pounds does your suitcase weigh? \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{weight}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}There is a \PYGZdl{}25 charge for luggage that heavy.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Thank you for your business.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The lines labeled 3\sphinxhyphen{}5 are an \sphinxcode{\sphinxupquote{if}} statement. It reads pretty much
like English. If it is true that the weight is greater than 50,
then print the statement about an extra charge. If it is not true
that the weight is greater than 50, then skip the part
right after the condition about
printing the extra luggage charge.
In any event, when
you have finished with the \sphinxcode{\sphinxupquote{if}} statement (whether it actually does
anything or not), go on to the next statement.
In this case that is the statement
printing “Thank you”.
An \sphinxcode{\sphinxupquote{if}} statement only breaks the  normal sequential order
\sphinxstyleemphasis{inside} the \sphinxcode{\sphinxupquote{if}} statement itself.

\sphinxAtStartPar
The general C\# syntax for a simple \sphinxcode{\sphinxupquote{if}} statement is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{if (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{)}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement
\end{DUlineblock}
\end{DUlineblock}

\sphinxAtStartPar
The condition is an expression that is true or false, of {\hyperref[\detokenize{data/types-and-conversions:type-boolean}]{\sphinxcrossref{\DUrole{std,std-ref}{Type Boolean or bool}}}}.

\index{compound statement@\spxentry{compound statement}!\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}}\index{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}!compound statement@\spxentry{compound statement}}\index{statement@\spxentry{statement}!compound@\spxentry{compound}}\ignorespaces 
\sphinxAtStartPar
Often you want multiple statements executed when the condition
is true.  We have used braces before.  We have not said
what they do technically, syntactically:  braces around
a group of statements technically makes a single
\sphinxstyleemphasis{compound statement}.  So the pattern commonly written is:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{if (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] one or more statements
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
If the condition is true, then do the statement(s) in braces. If the
condition is not true, then skip the statements in braces.  The
indentation pattern is also illustrated.  Recall the compiler
does not care about the amount of whitespace, but humans do.
In general indent the statements inside a compound statement.
Later in:ref:\sphinxtitleref{missing\sphinxhyphen{}braces} we will see
that there is good reason to use this format
with braces \sphinxstyleemphasis{even} if there is just one statement inside the braces.

\sphinxAtStartPar
Another fragment as an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{balance}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{transfer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{balance}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// transfer enough from the backup account:}
\PYG{+w}{    }\PYG{n}{backupAccount}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{backupAccount}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{transfer}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{balance}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{balance}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{transfer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The assumption
in the example above is that if an account goes negative, it is
brought back to 0 by transferring money from a backup account in
\sphinxstyleemphasis{several} steps.

\sphinxAtStartPar
In the examples above the choice is between doing something (if the
condition is \sphinxcode{\sphinxupquote{true}}) or nothing (if the condition is \sphinxcode{\sphinxupquote{false}}).
Often there is a choice of two possibilities, only one of which
will be done, depending on the truth of a condition….


\subsection{Simple If Exercise}
\label{\detokenize{decisions/ifstatements:simple-if-exercise}}
\sphinxAtStartPar
Think of two different inputs you could give that would make the
execution of the code fragment proceed differently.  What would happen in
each case?  (Assume we have access to the class UIF.)
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Consider:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a word: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Now we have \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Consider:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The magnitude of \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} is \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{if\sphinxhyphen{}else@\spxentry{if\sphinxhyphen{}else}}\ignorespaces 

\section{\sphinxstyleliteralintitle{\sphinxupquote{if}}\sphinxhyphen{}\sphinxstyleliteralintitle{\sphinxupquote{else}} Statements}
\label{\detokenize{decisions/ifelse:if-else-statements}}\label{\detokenize{decisions/ifelse:index-0}}\label{\detokenize{decisions/ifelse:id1}}\label{\detokenize{decisions/ifelse::doc}}
\sphinxAtStartPar
Run the example program, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clothes/clothes.cs}{clothes/clothes.cs}. Try it at least twice, with
inputs 50 and then 80. As you can see, you get different results,
depending on the input. The main code of \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clothes/clothes.cs}{clothes/clothes.cs} is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptDouble}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}What is the temperature? \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{70}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Wear shorts.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Wear long pants.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Get some exercise outside.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The lines labeled 2\sphinxhyphen{}7 are an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement. Again it is
close to English, though you might say “otherwise” instead of
“else” (but else is shorter!). There are two indented statements
in braces:
One, like in the simple \sphinxcode{\sphinxupquote{if}} statement, comes right after the
\sphinxcode{\sphinxupquote{if}} condition and is executed when the condition  is true.
In the \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} form this is followed by an
\sphinxcode{\sphinxupquote{else}} (lined up under the \sphinxcode{\sphinxupquote{if}} by convention),
followed by another indented statement enclosed in braces that is only
executed when the original condition is \sphinxstyleemphasis{false}. In an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}}
statement exactly one of two possible parts in braces is executed.

\sphinxAtStartPar
A final line is also shown that is not indented, about getting exercise.
The \sphinxcode{\sphinxupquote{if}} and \sphinxcode{\sphinxupquote{else}} clauses each
only embed a \sphinxstyleemphasis{single} (possibly compound) statement
as option, so the last statement is not part of the \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}}
statement.  It is beyond the \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement; it is
just a part of the normal sequential
flow of statements.  We repeat:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Inside an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} there is a
choice made of which clause to execute and which clause to skip,
but the whole \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} construction is a \sphinxstyleemphasis{single}
larger statement, which exists in the normal \sphinxstyleemphasis{sequential} flow
of execution.
\end{sphinxadmonition}

\sphinxAtStartPar
The compiler does not require the indentation of the if\sphinxhyphen{}true\sphinxhyphen{}statement
and the if\sphinxhyphen{}false\sphinxhyphen{}statement, but it is a standard style convention.

\sphinxAtStartPar
The general C\# \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} syntax is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{if (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) for if\sphinxhyphen{}true
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\item[] \sphinxcode{\sphinxupquote{else \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) for if\sphinxhyphen{}false
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
The statements chosen based on the condition
can be any kind of statement.  This is the suggested form, but
as with the plain \sphinxcode{\sphinxupquote{if}} statement, the if\sphinxhyphen{}true compound statement or
the if\sphinxhyphen{}false compound statement can be replace by a single statement
without braces, except in one otherwise ambiguous situation later,
{\hyperref[\detokenize{decisions/ifpitfalls:match-wrong-if}]{\sphinxcrossref{\DUrole{std,std-ref}{Match Wrong if With else}}}}.

\phantomsection\label{\detokenize{decisions/ifelse:compound-statement-scope}}
\index{scope@\spxentry{scope}!compound statement@\spxentry{compound statement}}\index{compound statement@\spxentry{compound statement}!scope@\spxentry{scope}}\index{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}!scope@\spxentry{scope}}\ignorespaces 

\subsection{Scope With Compound Statements}
\label{\detokenize{decisions/ifelse:scope-with-compound-statements}}\label{\detokenize{decisions/ifelse:index-1}}
\sphinxAtStartPar
The section {\hyperref[\detokenize{functions/localscope:local-scope}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Scope}}}} referred to function  bodies,
which happen to be enclosed in braces, making the function body a \sphinxstyleemphasis{compound statement}.
In fact variables declared inside \sphinxstyleemphasis{any} compound statement have their scope restricted
to \sphinxstyleemphasis{inside} that compound statement.

\sphinxAtStartPar
As a result the following code makes no sense:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{BadBlockScope}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{:}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement is legal, but useless,
because whichever compound statement gets executed,
\sphinxcode{\sphinxupquote{val}} ceases being defined after the
closing brace of its compound statement,
so the \sphinxcode{\sphinxupquote{val}} in the return statement has
not been declared or given a value.  The code
would generate a compiler error.

\sphinxAtStartPar
If we want \sphinxcode{\sphinxupquote{val}} be used inside the braces and
to make sense past the end of the compound statement,
it cannot be declared inside the braces. Instead it must be
declared before the compound statements that are parts of the
\sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement.   A local variable in a function declared before a nested compound
statement is still visible (in scope) \sphinxstyleemphasis{inside}  that compound statement.
The following would work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{OkScope}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is even more subtlety here than meets the eye:
An \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement can generally be rewritten as two simple
if statements (though it is less efficient and less clear).
The two \sphinxcode{\sphinxupquote{if}} statements would use opposite conditions, as in this variation:

\index{compiler error@\spxentry{compiler error}!uninitialized local variable@\spxentry{uninitialized local variable}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{decisions/ifelse:index-2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{OkScope2}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{c+c1}{// without the = 0: Unassigned local variable error}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that in this variation we added an
initialization for \sphinxcode{\sphinxupquote{val}} to be 0, though the
value of the initialization is never used:  \sphinxcode{\sphinxupquote{val}} is
guaranteed to be assigned a value in one of the \sphinxcode{\sphinxupquote{if}} statements
before its value is used in the return statement.

\sphinxAtStartPar
Open Xamarin Studio with the examples solution, and open
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ok\_if\_scope/ok\_if\_scope.cs}{ok\_if\_scope/ok\_if\_scope.cs} in the edit window.
The last function, \sphinxcode{\sphinxupquote{OkScope2}},
is the one shown above.  Now \sphinxstyleemphasis{remove} the logically
unnecessary \sphinxcode{\sphinxupquote{= 0}} initialization for \sphinxcode{\sphinxupquote{val}} so the line is just \sphinxcode{\sphinxupquote{int val;}}.
As the comment says, an error should
appear (at least after you try to compile the program).
The error will say that there is an uninitialized local variable!  Why?

\sphinxAtStartPar
For safety
the C\# compiler has some basic analysis to check that every local
variable gets given a value before its value is used.  In the \sphinxcode{\sphinxupquote{OkScope}} function
there is no \sphinxstyleemphasis{one}
place where \sphinxcode{\sphinxupquote{val}} gets an initial value, but the compiler is smart enough to see
that one of the branches of any if\sphinxhyphen{}else statement is always taken,
and \sphinxcode{\sphinxupquote{val}} gets a value in each, so there is
no problem.

\sphinxAtStartPar
The compiler analysis is not complete:  It does not actually evaluate any
expressions.  This is good enough to catch many initialization errors that coders make,
but it
is not sufficient in general: We can see this from the altered \sphinxcode{\sphinxupquote{OkScope2}}.

\sphinxAtStartPar
The original code shows the fix:  Give a dummy initialization that is never used
in execution, but keeps the compiler happy.

\sphinxAtStartPar
Although this extra initialization is annoying, the extra step is rarely needed.
Meanwhile it is very easy to forget to give a value to a local variable before use!
Having
the error caught quickly by the compiler is very handy, offsetting the extra work
when the compiler gives this error unnecessarily.


\subsection{If\sphinxhyphen{}else Exercise}
\label{\detokenize{decisions/ifelse:if-else-exercise}}
\sphinxAtStartPar
Think of two different inputs you could give that would make the
execution of the code fragment proceed differently.  What would happen in
each case?  (Assume we have access to the class UIF.)
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Consider:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a word: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Now we have \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}We still have \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Consider:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a integer: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The magnitude of \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} is \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{boolean expression@\spxentry{boolean expression}}\index{comparison \textless{} \textgreater{} \textless{}= \textgreater{}= == "!=@\spxentry{comparison \textless{} \textgreater{} \textless{}= \textgreater{}= == "!=}}\index{\textless{} less than@\spxentry{\textless{} less than}}\index{\textless{}= less than or equal@\spxentry{\textless{}= less than or equal}}\index{\textgreater{} greater than@\spxentry{\textgreater{} greater than}}\index{\textgreater{}= greater than or equal@\spxentry{\textgreater{}= greater than or equal}}\index{== equality test@\spxentry{== equality test}}\index{"!= inequality test@\spxentry{"!= inequality test}}\ignorespaces 

\section{More Conditional Expressions}
\label{\detokenize{decisions/comparisonops:more-conditional-expressions}}\label{\detokenize{decisions/comparisonops:index-0}}\label{\detokenize{decisions/comparisonops:id1}}\label{\detokenize{decisions/comparisonops::doc}}
\sphinxAtStartPar
All the usual arithmetic comparisons may be made in C\#, but many do not
use standard mathematical symbolism, mostly for lack of proper keys
on a standard keyboard.
(If you are looking at the following table in the html version,
you need to be online and may need an up\sphinxhyphen{}to\sphinxhyphen{}date browser
to see these mathematical symbols be displayed correctly,
as well as the mathematical expressions later in the text.  The pdf version
of the book automatically shows all the right math symbolism online or offline.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Math Symbol
&\sphinxstyletheadfamily 
\sphinxAtStartPar
C\# Symbols
\\
\hline
\sphinxAtStartPar
Less than
&
\sphinxAtStartPar
\(<\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textless{}}}
\\
\hline
\sphinxAtStartPar
Greater than
&
\sphinxAtStartPar
\(>\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textgreater{}}}
\\
\hline
\sphinxAtStartPar
Less than or equal
&
\sphinxAtStartPar
\(\leq\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textless{}=}}
\\
\hline
\sphinxAtStartPar
Greater than or equal
&
\sphinxAtStartPar
\(\geq\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textgreater{}=}}
\\
\hline
\sphinxAtStartPar
Equals
&
\sphinxAtStartPar
\(=\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{==}}
\\
\hline
\sphinxAtStartPar
Not equal
&
\sphinxAtStartPar
\(\neq\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{!=}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
There should not be space between the two\sphinxhyphen{}symbol C\#
substitutes.

\sphinxAtStartPar
Notice that the obvious choice for \sphinxstyleemphasis{equals}, a single equal sign,
is \sphinxstyleemphasis{not} used to check for equality. An annoying second equal sign
is required. This is because the single equal sign is already used
for \sphinxstyleemphasis{assignment} in C\#, so it is not available for tests.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is a common error to use only one equal sign when you mean to \sphinxstyleemphasis{test}
for equality, and not make an assignment!
\end{sphinxadmonition}

\sphinxAtStartPar
Tests for equality do not make an assignment. Tests for equality can have an
arbitrary expression on the left, not just a variable.

\sphinxAtStartPar
All these tests work for numbers,
and characters.  Strings can also be compared, most often for
equality (==) or inequality (!=), though they also have a defined order,
so you can use \sphinxcode{\sphinxupquote{\textless{}}}, for instance.

\sphinxAtStartPar
Predict the results and try each line in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{x}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}
\PYG{n}{x}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}h\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}i\PYGZdq{}}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}HI\PYGZdq{}}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}hi\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Hello\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}HELLO\PYGZdq{}}\PYG{p}{;}
\PYG{n}{s}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
An equality check does not make an assignment. Strings equality tests are case
sensitive.

\sphinxAtStartPar
\sphinxstylestrong{Try this}: Following up on the discussion of the \sphinxstyleemphasis{inexactness} of float
arithmetic, confirm that C\#
does not consider .1 + .2 to be equal to .3: Write a simple
condition into csharp to test.
\subsubsection*{Pay with Overtime Example}

\sphinxAtStartPar
Given a person’s work
hours for the week and regular hourly wage, calculate the total pay
for the week, taking into account overtime. Hours worked over 40
are overtime, paid at 1.5 times the normal rate. This is a natural
place for a function enclosing the calculation.

\sphinxAtStartPar
\sphinxstyleemphasis{Read} the setup for the function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the total weekly wages for a worker working}
\PYG{c+c1}{/// totalHours with a given regular hourlyWage.}
\PYG{c+c1}{/// Include overtime for hours over 40.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{CalcWeeklyWages}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem clearly indicates two cases: when no more than 40
hours are worked or when more than 40 hours are worked. In case
more than 40 hours are worked, it is convenient to introduce a
variable overtimeHours. You are encouraged to think about a
solution before going on and examining mine.

\sphinxAtStartPar
You can try running the complete example program, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages1/wages1.cs}{wages1/wages1.cs},
also shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Wages}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//heading chunk}
\PYG{+w}{      }\PYG{c+c1}{/// Return the total weekly wages for a worker working}
\PYG{+w}{      }\PYG{c+c1}{/// totalHours with a given regular hourlyWage.}
\PYG{+w}{      }\PYG{c+c1}{/// Include overtime for hours over 40.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{CalcWeeklyWages}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{totalWages}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{totalHours}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{40}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{totalWages}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{o}{*}\PYG{n}{totalHours}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{overtime}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{40}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{totalWages}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{o}{*}\PYG{l+m}{40}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{1.5}\PYG{o}{*}\PYG{n}{hourlyWage}\PYG{p}{)}\PYG{o}{*}\PYG{n}{overtime}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{totalWages}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{hours}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptDouble}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter hours worked: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{wage}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptDouble}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter dollars paid per hour: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{total}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CalcWeeklyWages}\PYG{p}{(}\PYG{n}{hours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wage}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//before chunk2}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}
\PYG{+w}{            }\PYG{l+s}{\PYGZdq{}Wages for \PYGZob{}0\PYGZcb{} hours at \PYGZdl{}\PYGZob{}1:F2\PYGZcb{} per hour are \PYGZdl{}\PYGZob{}2:F2\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{hours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wage}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}\PYG{+w}{                                                }\PYG{c+c1}{//after chunk2}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{format@\spxentry{format}!digits shown in string@\spxentry{digits shown in string}}\index{precision@\spxentry{precision}!format with \sphinxleftcurlybrace{}:F\#\sphinxrightcurlybrace{}@\spxentry{format with \sphinxleftcurlybrace{}:F\#\sphinxrightcurlybrace{}}}\index{digits formatted in string@\spxentry{digits formatted in string}}\index{:@\spxentry{:}!string precision formatting@\spxentry{string precision formatting}}\ignorespaces 
\sphinxAtStartPar
This program also introduces new notation for
displaying decimal numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}
\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}Wages for \PYGZob{}0\PYGZcb{} hours at \PYGZdl{}\PYGZob{}1:F2\PYGZcb{} per hour are \PYGZdl{}\PYGZob{}2:F2\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{   }\PYG{n}{hours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wage}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the format string are \sphinxcode{\sphinxupquote{\{1:F2\}}} and \sphinxcode{\sphinxupquote{\{2:F2\}}}:  Inside
the braces, after the parameter index, you see a new part,
\sphinxcode{\sphinxupquote{:F2}}.
The part after the colon gives additional formatting information.
In this case: Display with the decimal point
fixed (hence the \sphinxstylestrong{F}) so  \sphinxstylestrong{2} places beyond the decimal
point are shown.  Also the result is \sphinxstyleemphasis{rounded}.
This is appropriate for money with dollars and cents.
You can replace the 2 to display
a different number of digits after the decimal point.
More formatting syntax is introduced in {\hyperref[\detokenize{for/forexamples:tables}]{\sphinxcrossref{\DUrole{std,std-ref}{Tables}}}}.

\sphinxAtStartPar
Because \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements alter the flow or execution, and altering this flow
causes lots of problems for many students, this is a good place to
play computer to illustrate clearly what is happening.  We will just
concentrate on a call to \sphinxcode{\sphinxupquote{CalcWeeklyWages}}, where the \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}}
statement is.

\sphinxAtStartPar
Recall that to play computer,
we keep track of the state of variables while following execution carefully,
statement by statement.
The big point here is that this order of execution is \sphinxstyleemphasis{not} textual order!
If we are just following a call to \sphinxcode{\sphinxupquote{CalcWeeklyWages}}, we start at
line 9, and we will assume for example that it is called with
\sphinxcode{\sphinxupquote{totalHour}} as 50 and \sphinxcode{\sphinxupquote{hourlyWage}} as 14.00:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
totalWages
&\sphinxstyletheadfamily 
\sphinxAtStartPar
overtime
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Assume passed totalHours=50; hourlyWage=14
\\
\hline
\sphinxAtStartPar
12
&&&
\sphinxAtStartPar
50 \textless{}= 40: false; SKIP if clause
\\
\hline
\sphinxAtStartPar
16
&&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
50\sphinxhyphen{}40=10 at start of else clause
\\
\hline
\sphinxAtStartPar
17
&
\sphinxAtStartPar
770
&&
\sphinxAtStartPar
14*40 + (1.5*14)*10 = 770
\\
\hline
\sphinxAtStartPar
19
&&&
\sphinxAtStartPar
return 770 to caller
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We \sphinxstyleemphasis{skipped} the executable line 13 in the if\sphinxhyphen{}true clause.

\sphinxAtStartPar
Instead suppose the function is called with
\sphinxcode{\sphinxupquote{totalHour}} as 30 and \sphinxcode{\sphinxupquote{hourlyWage}} as 14.00:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
totalWages
&\sphinxstyletheadfamily 
\sphinxAtStartPar
overtime
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Assume passed totalHours=30; hourlyWage=14
\\
\hline
\sphinxAtStartPar
12
&&&
\sphinxAtStartPar
30 \textless{}= 40: true; continue straight
\\
\hline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
420
&&
\sphinxAtStartPar
14*30 = 420; SKIP else clause
\\
\hline
\sphinxAtStartPar
19
&&&
\sphinxAtStartPar
return 420 to caller
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We skipped the executable lines 16\sphinxhyphen{}17
in the if\sphinxhyphen{}false clause after \sphinxcode{\sphinxupquote{else}}.

\sphinxAtStartPar
Below is an equivalent alternative version of
\sphinxcode{\sphinxupquote{CalcWeeklyWages}}, used in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages2/wages2.cs}{wages2/wages2.cs}. It uses just one
general calculation formula and sets the parameters for the formula
in the \sphinxcode{\sphinxupquote{if}} statement. There are generally a number of ways you might
solve the same problem!

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{CalcWeeklyWages}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{regularHours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{overtime}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{totalHours}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{40}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{regularHours}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{overtime}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{regularHours}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{40}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{overtime}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{totalHours}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{40}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{hourlyWage}\PYG{o}{*}\PYG{n}{regularHours}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{1.5}\PYG{o}{*}\PYG{n}{hourlyWage}\PYG{p}{)}\PYG{o}{*}\PYG{n}{overtime}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Wages Play Computer Exercise}
\label{\detokenize{decisions/comparisonops:wages-play-computer-exercise}}
\sphinxAtStartPar
We played computer on the original version of \sphinxcode{\sphinxupquote{CalcWeeklyWages}}.  Now
follow the second version above, from \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages2/wages2.cs}{wages2/wages2.cs}.  Try it
with the same two sets of formal parameter values.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
regularHours
&\sphinxstyletheadfamily 
\sphinxAtStartPar
overtime
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Assume passed totalHours=50; hourlyWage=14
\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
regularHours
&\sphinxstyletheadfamily 
\sphinxAtStartPar
overtime
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Assume passed totalHours=30; hourlyWage=14
\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\sphinxAtStartPar

&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Graduate Exercise}
\label{\detokenize{decisions/comparisonops:graduate-exercise}}\label{\detokenize{decisions/comparisonops:graduateex}}
\sphinxAtStartPar
Write a program, \sphinxcode{\sphinxupquote{graduate.cs}}, that prompts students for how
many credits they have. Print whether of not they have enough
credits for graduation. (At Loyola University Chicago 120 credits
are needed for graduation.)


\subsection{Roundoff Exercise}
\label{\detokenize{decisions/comparisonops:roundoff-exercise}}
\sphinxAtStartPar
In csharp declare and initialize  non\sphinxhyphen{}zero \sphinxcode{\sphinxupquote{double}} variables
\sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}.  Experiment so, according to C\# (and csharp):  \sphinxcode{\sphinxupquote{x+y == x}}.
In other words, while \sphinxcode{\sphinxupquote{y}} is not 0, adding it to  \sphinxcode{\sphinxupquote{x}} does not
change \sphinxcode{\sphinxupquote{x}}.  (Hints:  Note the approximate number of digits of accuracy
of a \sphinxcode{\sphinxupquote{double}}, and remember the power of 10 notation with \sphinxcode{\sphinxupquote{E}}
for \sphinxcode{\sphinxupquote{double}} literals. See {\hyperref[\detokenize{data/types-and-conversions:type-double}]{\sphinxcrossref{\DUrole{std,std-ref}{Type double}}}} and the section on limits
after it.)

\sphinxstepscope

\index{if\sphinxhyphen{}else\sphinxhyphen{}if@\spxentry{if\sphinxhyphen{}else\sphinxhyphen{}if}}\ignorespaces 

\section{Multiple Tests and \sphinxstyleliteralintitle{\sphinxupquote{if}}\sphinxhyphen{}\sphinxstyleliteralintitle{\sphinxupquote{else}} Statements}
\label{\detokenize{decisions/ifelsechained:multiple-tests-and-if-else-statements}}\label{\detokenize{decisions/ifelsechained:multiple-tests}}\label{\detokenize{decisions/ifelsechained:index-0}}\label{\detokenize{decisions/ifelsechained::doc}}
\sphinxAtStartPar
Often you want to distinguish between more than two distinct cases,
but conditions only have two possible results, \sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}},
so the only direct choice is between two options. As anyone who has
played “20 Questions” knows, you can distinguish more cases with
further questions. If there are more than two choices, a single
test may only reduce the possibilities, but further tests can
reduce the possibilities further and further. Since most any kind
of statement can be placed in the sub\sphinxhyphen{}statements in
an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement, one
choice is a further \sphinxcode{\sphinxupquote{if}} or \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement.
For instance consider a
function to convert a numerical grade to a letter grade, ‘A’, ‘B’,
‘C’, ‘D’ or ‘F’, where the cutoffs for ‘A’, ‘B’, ‘C’, and ‘D’ are
90, 80, 70, and 60 respectively. One way to write the function
would be to test for one grade at a time, and resolve all the
remaining possibilities inside the next \sphinxcode{\sphinxupquote{else}} clause.
If we do this consistent with our indentation conventions so far:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n+nf}{letterGrade}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{score}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{letter}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{90}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}A\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// grade must be B, C, D or F}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{80}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}B\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// grade must be C, D or F}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{70}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}C\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// grade must D or F}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{60}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}D\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}F\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}\PYG{+w}{   }\PYG{c+c1}{//end else D or F}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}\PYG{+w}{      }\PYG{c+c1}{// end of else C, D, or F}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}\PYG{+w}{         }\PYG{c+c1}{// end of else B, C, D or F}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{letter}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This repeatedly increasing indentation with an \sphinxcode{\sphinxupquote{if}} statement in
the \sphinxcode{\sphinxupquote{else}} clause can be annoying and distracting. Here is a preferred
alternative in this situation, that avoids all this further
indentation:
Combine each \sphinxcode{\sphinxupquote{else}} and following \sphinxcode{\sphinxupquote{if}} onto the same line,
and note that the \sphinxcode{\sphinxupquote{if}} part after each else is just a \sphinxstyleemphasis{single}
(possibly very complicated) statement.  This allows the elimination of
some of the braces:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return letter grade for score.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n+nf}{letterGrade}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{score}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{letter}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{90}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}A\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{80}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// grade must be B, C, D or F}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}B\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{70}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// grade must be C, D or F}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}C\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{60}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// grade must D or F}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}D\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{letter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}F\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{letter}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A program testing the letterGrade function is in
example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade1/grade1.cs}{grade1/grade1.cs}.

\sphinxAtStartPar
See {\hyperref[\detokenize{decisions/ifelsechained:gradeex}]{\sphinxcrossref{\DUrole{std,std-ref}{Grade Exercise}}}}.

\sphinxAtStartPar
As in a basic \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement, in the general format,

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{if (}} \sphinxstyleemphasis{condition1} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement\sphinxhyphen{}block\sphinxhyphen{}run\sphinxhyphen{}if\sphinxhyphen{}condition1\sphinxhyphen{}is\sphinxhyphen{}true;
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\item[] \sphinxcode{\sphinxupquote{else if (}} \sphinxstyleemphasis{condition2} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement\sphinxhyphen{}block\sphinxhyphen{}run\sphinxhyphen{}if\sphinxhyphen{}condition2\sphinxhyphen{}is\sphinxhyphen{}the\sphinxhyphen{}first\sphinxhyphen{}true;
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\item[] \sphinxcode{\sphinxupquote{else if (}} \sphinxstyleemphasis{condition3} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement\sphinxhyphen{}block\sphinxhyphen{}run\sphinxhyphen{}if\sphinxhyphen{}condition3\sphinxhyphen{}is\sphinxhyphen{}the\sphinxhyphen{}first\sphinxhyphen{}true;
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\item[] // …
\item[] \sphinxcode{\sphinxupquote{else \{    //}} \sphinxstyleemphasis{no condition!}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement\sphinxhyphen{}block\sphinxhyphen{}run\sphinxhyphen{}if\sphinxhyphen{}no condition\sphinxhyphen{}is\sphinxhyphen{}true;
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxstyleemphasis{exactly one} of the statement blocks gets executed:
If some condition is true,
the first block following a true condition is executed.
If no condition is true,
the \sphinxcode{\sphinxupquote{else}} block is executed.

\sphinxAtStartPar
Here is a variation. Consider this
fragment \sphinxstyleemphasis{without} a final \sphinxcode{\sphinxupquote{else}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{weight}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{120}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Sorry, we can not take a suitcase that heavy.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{weight}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}There is a \PYGZdl{}25 charge for luggage that heavy.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This statement only prints one of two lines if there is a
problem with the weight of the suitcase.  Nothing is printed if
there is not a problem.

\sphinxAtStartPar
If the final \sphinxcode{\sphinxupquote{else}} clause is omitted from the general \sphinxcode{\sphinxupquote{if}} … \sphinxcode{\sphinxupquote{else if}} …
pattern above, at most one block after a condition
is executed:  That is the block after the first true condition.
If all the conditions are false, none of the statement blocks
will be executed.

\sphinxAtStartPar
It is also possible to embed \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements inside other \sphinxcode{\sphinxupquote{if}} or
\sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements in more complicated patterns.


\subsection{Sign Exercise}
\label{\detokenize{decisions/ifelsechained:sign-exercise}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{sign.cs}} to ask the user for a number. Print out
which category the number is in: \sphinxcode{\sphinxupquote{"positive"}}, \sphinxcode{\sphinxupquote{"negative"}}, or
\sphinxcode{\sphinxupquote{"zero"}}.


\subsection{Grade Exercise}
\label{\detokenize{decisions/ifelsechained:grade-exercise}}\label{\detokenize{decisions/ifelsechained:gradeex}}
\sphinxAtStartPar
Copy \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade1/grade1.cs}{grade1/grade1.cs} to \sphinxcode{\sphinxupquote{grade2.cs}} in your own project.
Modify
\sphinxcode{\sphinxupquote{grade2.cs}} so it has an equivalent version of the letterGrade
function that tests in the opposite order, first for F, then D, C,
…. Hint: How many tests do you need to do? %
\begin{footnote}[1]\sphinxAtStartFootnote
4 tests to distinguish the 5 cases, as in the previous version
%
\end{footnote}

\sphinxAtStartPar
Be sure to run your new version and test with different
inputs that test all the different paths through the program.

\sphinxAtStartPar
Be careful for edge cases:  Test the grades on the “edge” of a
change in the result.


\subsection{Wages Exercise}
\label{\detokenize{decisions/ifelsechained:wages-exercise}}
\sphinxAtStartPar
Modify the \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages1/wages1.cs}{wages1/wages1.cs} or the \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages2/wages2.cs}{wages2/wages2.cs}
example to create a
program \sphinxcode{\sphinxupquote{wages3.cs}} that assumes people are paid double time for
hours over 60. Hence they get paid for at most 20 hours overtime at
1.5 times the normal rate. For example, a person working 65 hours
with a regular wage of \$10 per hour would work at \$10 per hour for
40 hours, at 1.5 * \$10 for 20 hours of overtime, and 2 * \$10 for
5 hours of double time, for a total of
\begin{quote}

\sphinxAtStartPar
10*40 + 1.5*10*20 + 2*10*5 = \$800.
\end{quote}

\sphinxAtStartPar
You may find \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages2/wages2.cs}{wages2/wages2.cs} easier to adapt than
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/wages1/wages1.cs}{wages1/wages1.cs}.

\sphinxAtStartPar
Caution:  Be sure to thoroughly test your \sphinxstyleemphasis{final} program version.  It is
easy to add new features that work by themselves, but break a part
that worked before! In particular in a program with decisions, make sure you
test with enough different data to check all lines of your program.

\sphinxstepscope


\section{If\sphinxhyphen{}statement Pitfalls}
\label{\detokenize{decisions/ifpitfalls:if-statement-pitfalls}}\label{\detokenize{decisions/ifpitfalls::doc}}
\index{semicolon after condition pitfall@\spxentry{semicolon after condition pitfall}}\index{pitfall@\spxentry{pitfall}!if@\spxentry{if}}\index{if@\spxentry{if}!pitfall@\spxentry{pitfall}}\ignorespaces 

\subsection{Dangerous Semicolon}
\label{\detokenize{decisions/ifpitfalls:dangerous-semicolon}}\label{\detokenize{decisions/ifpitfalls:index-0}}\label{\detokenize{decisions/ifpitfalls:id1}}
\sphinxAtStartPar
Regular statements must end with a semicolon.
It turns out that the semicolon is all you need to have a legal statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will see places that it is useful, but
meanwhile it can cause errors: You may be hard pressed to
remember to put semicolons at the end of all your statements, and in response you may
get compulsive about adding them at the end of statement
lines.  Be careful NOT to put one at the end of a method heading or
an \sphinxcode{\sphinxupquote{if}} condition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// WRONG PROBABLY!}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code is deadly, since it compiles and is almost surely
\sphinxstyleemphasis{not} what you mean.

\sphinxAtStartPar
Remember indentation and newlines are only significant for humans. The
two lines above are equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// Do nothing as statement when the condition is true}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// past if statement \PYGZhy{} do it always}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Whenever you do need an empty statement, you are encouraged to put the
semicolon all by itself on a line, as above.)

\sphinxAtStartPar
If you always put an open brace \sphinxstyleemphasis{directly} after the condition in an \sphinxcode{\sphinxupquote{if}} statement,
you will not make this error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then even if you were to add a semicolon:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
it would be a waste of a keystroke, but it would just be the first (empty) statement
inside the block, and the writing would still follow:
The extra semicolon would have no effect.

\sphinxAtStartPar
The corresponding error at the end of a method heading will at least
generate a compiler error, though it may appear cryptic:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{badSemicolon}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// ...}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is another easy one to make and \sphinxstyleemphasis{miss} \sphinxhyphen{} just one innocent semicolon.

\index{pitfall@\spxentry{pitfall}!dangling else;@\spxentry{dangling else;}}\index{dangling else pitfall@\spxentry{dangling else pitfall}}\index{if\sphinxhyphen{}else@\spxentry{if\sphinxhyphen{}else}!pitfall@\spxentry{pitfall}}\ignorespaces 

\subsection{Match Wrong \sphinxstyleliteralintitle{\sphinxupquote{if}} With \sphinxstyleliteralintitle{\sphinxupquote{else}}}
\label{\detokenize{decisions/ifpitfalls:match-wrong-if-with-else}}\label{\detokenize{decisions/ifpitfalls:match-wrong-if}}\label{\detokenize{decisions/ifpitfalls:index-1}}
\sphinxAtStartPar
If you do not consistently put the substatements for the true
and false choices inside braces, you can run into problems from
the fact that the else part of an if statement is \sphinxstyleemphasis{optional}.
Even if you use braces consistently,
you may well need to read code that does not place
braces around single statements. If C\# understood indentation as
in the recommended formatting style (or as required in Python),
the following would be OK:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}positive x and y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x not positive, untested y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Unfortunately placing the \sphinxcode{\sphinxupquote{else}} under the first \sphinxcode{\sphinxupquote{if}} is not enough to make
them go together (remember the C\# compiler ignores extra whitespace). The
following is equivalent to the compiler, with the else apparently going
with the second if:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}positive x and y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{else}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x not positive, untested y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The compiler is consistent with the latter visual pattern: an \sphinxcode{\sphinxupquote{else}} goes
with the most \sphinxstyleemphasis{recent} \sphinxcode{\sphinxupquote{if}} that could still take an \sphinxcode{\sphinxupquote{else}}.
Hence if \sphinxcode{\sphinxupquote{x}} is 3
and \sphinxcode{\sphinxupquote{y}} is \sphinxhyphen{}2, the \sphinxcode{\sphinxupquote{else}} part is executed and the statement printed is
incorrect: in this code
the else clause is only executed when \sphinxcode{\sphinxupquote{x}} is positive and
\sphinxcode{\sphinxupquote{y}} (\sphinxstyleemphasis{is}
tested and) is not positive.

\sphinxAtStartPar
If you put braces everywhere to reinforce
your indentation, as we suggest, or if you only add the following
one set of braces around the inner if statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}positive x and y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x not positive, untested y\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then the braces enclosing the inner \sphinxcode{\sphinxupquote{if}} statement make it impossible for
the inner  \sphinxcode{\sphinxupquote{if}} to continue on to an optional \sphinxcode{\sphinxupquote{else}} part.
The \sphinxcode{\sphinxupquote{else}} must go
with the first \sphinxcode{\sphinxupquote{if}}. Now when the \sphinxcode{\sphinxupquote{else}} part is reached, the statement
printed will be true: \sphinxcode{\sphinxupquote{x}} is not positive, and the test of \sphinxcode{\sphinxupquote{y}} was skipped.

\index{pitfall@\spxentry{pitfall}!need braces for if@\spxentry{need braces for if}}\index{if@\spxentry{if}!need braces@\spxentry{need braces}}\index{braces needed with if@\spxentry{braces needed with if}}\ignorespaces 

\subsection{Missing Braces}
\label{\detokenize{decisions/ifpitfalls:missing-braces}}\label{\detokenize{decisions/ifpitfalls:index-2}}\label{\detokenize{decisions/ifpitfalls:id2}}
\sphinxAtStartPar
Another place you can fool yourself with nice indenting style is
something like this.  Suppose we start with a perfectly reasonable

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x is: positive\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We may decide to avoid the braces, since there \sphinxstyleemphasis{is} just one statement
that we want as the if\sphinxhyphen{}true part, but if we later decide
that we want this on two lines
and change it to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x is:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}  positive\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We are not going to get the behavior we want.
The word “positive” will \sphinxstyleemphasis{always} be printed.

\sphinxAtStartPar
If we had first taken a bit more effort originally to write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x is: positive\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
then we could have split successfully into

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}x is:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}  positive\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This way we do not have to keep worrying about this question when we revise:
“Have I switched to multiple lines after the \sphinxcode{\sphinxupquote{if}}
and need to introduce braces?”

\sphinxAtStartPar
The last two of the pitfalls mentioned in this section are fixed by consistent
use of braces in the sub\sphinxhyphen{}statements of \sphinxcode{\sphinxupquote{if}} statements.  They fix the \sphinxcode{\sphinxupquote{;}}
after if\sphinxhyphen{}condition problem only if the open brace comes right after
the condition, but you still get a nasty error if you put in a semicolon
between the condition and opening brace.

\sphinxstepscope

\index{\&\&@\spxentry{\&\&}!boolean operation AND@\spxentry{boolean operation AND}}\index{and \&\&@\spxentry{and \&\&}}\index{boolean operation@\spxentry{boolean operation}!\&\& AND@\spxentry{\&\& AND}}\ignorespaces 

\section{Compound Boolean Expressions}
\label{\detokenize{decisions/compoundconditions:compound-boolean-expressions}}\label{\detokenize{decisions/compoundconditions:index-0}}\label{\detokenize{decisions/compoundconditions:id1}}\label{\detokenize{decisions/compoundconditions::doc}}
\sphinxAtStartPar
To be eligible to graduate from Loyola University Chicago, you must
have 120 credits \sphinxstyleemphasis{and} a GPA of at least 2.0. C\# does not use the
word \sphinxstyleemphasis{and}.  Instead it uses \sphinxcode{\sphinxupquote{\&\&}} (inherited from the C language).
Then the requirement
translates directly into C\# as a \sphinxstyleemphasis{compound condition}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{credits}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{120}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{GPA}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{l+m}{2.0}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is true if both \sphinxcode{\sphinxupquote{credits \textgreater{}= 120}} is true and
\sphinxcode{\sphinxupquote{GPA \textgreater{}= 2.0}} is
true. A short example function using this would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{checkGraduation}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{credits}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{GPA}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{credits}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{120}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{GPA}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{l+m}{2.0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}You are eligible to graduate!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}You are not eligible to graduate.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The new C\# syntax for the operator \sphinxcode{\sphinxupquote{\&\&}}:
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{condition1} \sphinxcode{\sphinxupquote{\&\&}} \sphinxstyleemphasis{condition2}
\end{quote}

\sphinxAtStartPar
The compound condition is true if both of the component conditions
are true. It is false if at least one of the conditions is false.

\sphinxAtStartPar
Suppose we want a C\# condition that is true in the same situations as the mathematical
expression: low \textless{} val \textless{} high.  Unfortunately the math is not a
C\# expression.  The C\# operator \sphinxcode{\sphinxupquote{\textless{}}} is binary.  In C\# the statement above is
equivalent to
\begin{quote}

\sphinxAtStartPar
(low \textless{} val) \textless{} high
\end{quote}

\sphinxAtStartPar
comparing a Boolean result to high, and causing a compiler error.
There is a C\# version.  Be sure to use this pattern:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{low}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{high}
\end{sphinxVerbatim}

\index{\textbar{}\textbar{}@\spxentry{\textbar{}\textbar{}}!boolean operation OR@\spxentry{boolean operation OR}}\index{or \textbar{}\textbar{}@\spxentry{or \textbar{}\textbar{}}}\index{boolean operation@\spxentry{boolean operation}!\textbar{}\textbar{} OR@\spxentry{\textbar{}\textbar{} OR}}\ignorespaces 
\sphinxAtStartPar
Now suppose we want the opposite condition:  that val is \sphinxstyleemphasis{not}
strictly between low and high.
There are several approaches.
One is that \sphinxcode{\sphinxupquote{val}} would be less than or equal to low
\sphinxstyleemphasis{or} greater than or equal to \sphinxcode{\sphinxupquote{high}}.  C\# translate \sphinxstyleemphasis{or} into \sphinxcode{\sphinxupquote{||}},
so a C\# expression would be:
\begin{quote}

\sphinxAtStartPar
val \textless{}= low || val \textgreater{}= high
\end{quote}

\sphinxAtStartPar
The new C\# syntax for the operator \sphinxcode{\sphinxupquote{||}}:
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{condition1} \sphinxcode{\sphinxupquote{||}} \sphinxstyleemphasis{condition2}
\end{quote}

\sphinxAtStartPar
The compound condition is true if at least one of the component conditions
are true. It is false if both conditions are false.

\index{"! boolean operation NOT@\spxentry{"! boolean operation NOT}}\index{not "!@\spxentry{not "!}}\index{boolean operation@\spxentry{boolean operation}!"! NOT@\spxentry{"! NOT}}\ignorespaces 
\sphinxAtStartPar
Another logical way to express the opposite of the condition low \textless{} val \textless{} high
is that it is \sphinxstyleemphasis{not} the case
that low \textless{} val \&\& val \textless{}\textless{} high.  C\# translates \sphinxstyleemphasis{not} as \sphinxcode{\sphinxupquote{!}}.  Another way
to state the condition would be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}\PYG{p}{(}\PYG{n}{low}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{high}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parentheses are needed because the \sphinxcode{\sphinxupquote{!}}
operator has higher precedence than
\sphinxcode{\sphinxupquote{\textless{}}}.

\sphinxAtStartPar
A way to remember this strange \sphinxstyleemphasis{not} operator is to think of the use of \sphinxcode{\sphinxupquote{!}}
in the not\sphinxhyphen{}equal operator: \sphinxcode{\sphinxupquote{!=}}

\sphinxAtStartPar
The new C\# syntax for the operator \sphinxcode{\sphinxupquote{!}}:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{!}} \sphinxstyleemphasis{condition}
\end{quote}

\sphinxAtStartPar
This whole expression is true when \sphinxstyleemphasis{condition} is false,
and false when \sphinxstyleemphasis{condition} is true.

\sphinxAtStartPar
Because of the precedence of \sphinxcode{\sphinxupquote{!}}, you are often going to write:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{!(}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{)}}
\end{quote}

\sphinxAtStartPar
Remember when such a condition is used in an \sphinxcode{\sphinxupquote{if}} statement, \sphinxstyleemphasis{outer}
parentheses are also needed:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{if (!(}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{)) \{}}
\end{quote}

\sphinxAtStartPar
We now have a lot of operators!  Most of those in appendix {\hyperref[\detokenize{appendix/precedence:precedence}]{\sphinxcrossref{\DUrole{std,std-ref}{Precedence of Operators}}}}
have now been considered. There
you can see that \sphinxcode{\sphinxupquote{!}} has the high precedence of unary arithmetic operators.
The operators \sphinxcode{\sphinxupquote{\&\&}} and \sphinxcode{\sphinxupquote{||}} are almost at the bottom of the operators
considered in this book, just above the assignment operators, and below the
relational operators, with \sphinxcode{\sphinxupquote{\&\&}} above \sphinxcode{\sphinxupquote{||}}.
You are encourages to use parentheses to make sure.

\sphinxAtStartPar
\sphinxstylestrong{Compound Overkill}:  Look back to the code converting a score to a letter grade
in {\hyperref[\detokenize{decisions/ifelsechained:multiple-tests}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiple Tests and if\sphinxhyphen{}else Statements}}}}.
The condition before assigning the B grade could have been:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{80}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{score}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{90}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
That would have totally nailed the condition, but it is overly verbose in the
\sphinxcode{\sphinxupquote{if}} .. \sphinxcode{\sphinxupquote{else if}} … code where it appeared:
Since you only get to consider a B as a grade if the grade was \sphinxstyleemphasis{not} already
set to A, the second part of the compound condition above is redundant.

\sphinxAtStartPar
There are a couple more wrinkles with compound Boolean expressions introduced
later in {\hyperref[\detokenize{while/condition-short-circuit:short-circuit}]{\sphinxcrossref{\DUrole{std,std-ref}{Short\sphinxhyphen{}Circuiting \&\& and ||}}}}.


\subsection{Congress Exercise}
\label{\detokenize{decisions/compoundconditions:congress-exercise}}\label{\detokenize{decisions/compoundconditions:congressex}}
\sphinxAtStartPar
A person is eligible to be a US Senator who is at least 30 years
old and has been a US citizen for at least 9 years. Write a version
of a program \sphinxcode{\sphinxupquote{congress.cs}} to obtain age and length of
citizenship from the user and print out if a person is eligible to
be a Senator or not. A person is eligible to be a US Representative
who is at least 25 years old and has been a US citizen for at least
7 years. Elaborate your program \sphinxcode{\sphinxupquote{congress.cs}} so it obtains age
and length of citizenship and prints whether a person is eligible
to be a US Representative only, or is eligible for both offices, or
is eligible for neither.

\sphinxAtStartPar
This exercise could be done by making an exhaustive treatment of all
possible combinations of age and citizenship.  Try to avoid that.
(Note the paragraph just before this exercise.)

\sphinxAtStartPar
Caution:  be sure to do exhaustive testing.  It is easy to write code
that is correct for \sphinxstyleemphasis{some} inputs, but not all.

\index{implication operator@\spxentry{implication operator}}\ignorespaces 

\subsection{Implication Exercise}
\label{\detokenize{decisions/compoundconditions:implication-exercise}}\label{\detokenize{decisions/compoundconditions:index-3}}
\sphinxAtStartPar
We have introduced C\# Boolean operators for AND, OR, and NOT.
There are other Boolean operators important in logic,
that are not directly given as a C\# operator.
One example is “implies”, also expressed
in a logical if\sphinxhyphen{}then statement:  If I am expecting rain, then I am carrying an
umbrella.  Otherwise put:  “I am expecting rain” \sphinxstyleemphasis{implies}
“I am carrying an umbrella”. The first part is a Boolean expression called the
\sphinxstyleemphasis{hypothesis}, and the second part is called the \sphinxstyleemphasis{conclusion}.  In general, when
A and B are Boolean expressions, “A implies B” is also a Boolean expression.

\sphinxAtStartPar
Just as the truth of a compound Boolean expression like “A and B” depends on the
truth value of the two parts, so with \sphinxstyleemphasis{implies}:
If you are using good logic, and you start with a true assertion,
you should only be able to conclude something else true, so it is true that
“true implies true”.  If you start with garbage you can use that false statement
in a logical argument and end up with something either false or true:
“false implies false” and “false implies true” are both true. The only thing
that should not work is to start with something true and conclude
something false.  If that were the case, logical arguments would be useless,
so “true implies false” is false.  There is no C\# operator for “implies”, but
you can check all four cases of Boolean values for A and B to see that
“A implies B” is true exactly when “not A or B” is true.  We can
express this in C\# as \sphinxcode{\sphinxupquote{!A || B}}.

\sphinxAtStartPar
So here is a silly little exercise illustrating both implication and using
the C\# Boolean operators:  Ask the user whether “I am expecting rain” is true.
(We have the UI function Agree.)  Then check with the user whether
“I am carrying an umbrella.”  Then conclude and print out
whether the implication “If I am expecting rain, then I am carrying an
umbrella.” is true or not in this situation.

\sphinxstepscope

\index{if@\spxentry{if}!statements nested@\spxentry{statements nested}}\index{statement@\spxentry{statement}!if nested@\spxentry{if nested}}\ignorespaces 

\section{Nested \sphinxstyleliteralintitle{\sphinxupquote{if}} Statements}
\label{\detokenize{decisions/ifnested:nested-if-statements}}\label{\detokenize{decisions/ifnested:if-nested}}\label{\detokenize{decisions/ifnested:index-0}}\label{\detokenize{decisions/ifnested::doc}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements the substatements (the if\sphinxhyphen{}true and if\sphinxhyphen{}false clauses)
are quite arbitrary statements.  They can be more \sphinxcode{\sphinxupquote{if}} or
\sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements.
In {\hyperref[\detokenize{decisions/ifelsechained:multiple-tests}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiple Tests and if\sphinxhyphen{}else Statements}}}}
we have just illustrated placing an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement as the \sphinxcode{\sphinxupquote{else}}
clause, and repeating this pattern, to repeatedly test for one more case,
stopping when the first true condition if reached.
To choose one case from multiple cases,
each condition separates one case terminal case from all the remaining
untested cases.

\sphinxAtStartPar
Consider a different situation:  Steven Covey suggested that people classify
possible actions on two axes: urgent vs. not urgent and important vs. not
important, leading to four possible combinations.
We could ask a person to classify an activity this way, and them give a
process comment, something like from Covey’s book:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Important and urgent:  Be sure to schedule this promptly!

\item {} 
\sphinxAtStartPar
Important and not urgent:  Make sure that this is included regularly in your
plans!  Do not let urgent but unimportant things interfere!

\item {} 
\sphinxAtStartPar
Not important and urgent:  Can you skip this, or is it really worth
letting this displace important things you need to do?

\item {} 
\sphinxAtStartPar
Not important and not urgent:  Is there anything more worthwhile
for you to do now?

\end{itemize}

\sphinxAtStartPar
Assume we have Boolean variables \sphinxcode{\sphinxupquote{important}} and \sphinxcode{\sphinxupquote{urgent}}.
There are four separate combinations, and we could handle this with a
chain of compound conditions checking for one at a time:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{important}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{urgent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Be sure ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{important}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{o}{!}\PYG{n}{urgent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Make sure ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{important}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{urgent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Can you...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Is there ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Compound test conditions
are not necessary if we keep track of partial answers,
nesting \sphinxcode{\sphinxupquote{if}} statements, thinking about the two aspects separately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{important}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{urgent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Be sure ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Make sure ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{urgent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Can you...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Is there ...\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The outer \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} determines whether the action is important, so the inner
conditions only need to deal with urgency.  Also note that in executing
this version there are never more than two short conditions evaluated.
In the first version,
you may have to go through all three conditions.  Both approaches work.
Which is clearer to you?


\subsection{Cartesian Plane Location Exercise/Example}
\label{\detokenize{decisions/ifnested:cartesian-plane-location-exercise-example}}
\sphinxAtStartPar
Points in the Cartesian plane are given by an x and a y coordinate.  Seven
parts of the Cartesian plane are labeled in the figure below.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=135.15bp]{{cartesian}.png}\hspace*{\fill}}

\sphinxAtStartPar
So we match each point with only one name, refer to the point where
both x and y are 0 as the origin, and only use the terms x axis or y axis when
the point is \sphinxstyleemphasis{not} the origin.

\sphinxAtStartPar
Write a program prompting the user for integer x and y values, and print
out the part of the plane as named in the figure.
Separate the input and output from the naming logic:
Have a function with x and y coordinates as parameters that returns the
name of the part of the Cartesian plane.

\sphinxAtStartPar
There are several possible approaches to this function:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Since each part is associated with a condition on both x and y,
you could write a 7 clause chain of if else if else …. with each condition
being a \sphinxstyleemphasis{compound} Boolean expression checking for another specific case.
This gives some more practice with compound boolean expressions.

\item {} 
\sphinxAtStartPar
The previous version is conceptually straightforward,
but you end up checking the sign of x and y
many more times than you need to.  Alternately you can make each condition
check only the sign of \sphinxstyleemphasis{one} coordinate, and \sphinxstyleemphasis{nest} \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements
checking one coordinate inside an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement checking the other
coordinate.  This is more complicated than the Covey importance and
urgency example, since each sign has three possibilities (+, 0, \sphinxhyphen{})
rather than two. \sphinxstyleemphasis{Our} solutions to this approach are in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/cartesian/cartesian.cs}{cartesian/cartesian.cs}.  There are actually two alternative
solutions functions there.
The first version uses many \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statements, but since each clause
executes a \sphinxcode{\sphinxupquote{return}} statement that stops any further execution,
no \sphinxcode{\sphinxupquote{else}} clauses are actually needed, as shown in \sphinxcode{\sphinxupquote{PartOfPlane2}}.

\end{itemize}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{decisions/reviewdecisions:chapter-review-questions}}\label{\detokenize{decisions/reviewdecisions::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Which of these are Boolean expressions?  Assume the variables are of
type \sphinxcode{\sphinxupquote{int}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{true}
\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{10}
\PYG{n}{count}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{22}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{10}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{10}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What are the values of these expressions?  Be able to explain:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{5}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{5}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Correct the last two entries in the first problem, supposing the user
meant “x could be either 2 or 3” and then
“y is strictly between 1 and 10”.

\item {} 
\sphinxAtStartPar
Add parentheses in \sphinxcode{\sphinxupquote{2 \textless{} 3 || 4 \textless{} 5 \&\& 4 \textless{} 3}} to get a different result.

\item {} 
\sphinxAtStartPar
Suppose you have four possible distinct situations in your algorithm,
each requiring a totally
different response in your code,
and exactly one of the situations is sure to occur.
Have many times must you have \sphinxcode{\sphinxupquote{if}} followed by
a condition?

\item {} 
\sphinxAtStartPar
Suppose you have four possible distinct situations in your algorithm,
each requiring a totally
different response in your code,
and at most one of the situations will occur, so
possibly nothing will happen that needs a response at all.
Have many times must you have \sphinxcode{\sphinxupquote{if}} followed by
a condition?

\item {} 
\sphinxAtStartPar
Assume  \sphinxcode{\sphinxupquote{IsBig(x)}} returns a Boolean value.
Remove the redundant part of this statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{IsBig}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{)}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Write an equivalent (and much shorter!) statement with no \sphinxcode{\sphinxupquote{if}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{k}{else}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Write an equivalent (and much shorter!) statement with no \sphinxcode{\sphinxupquote{if}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}
\PYG{+w}{   }\PYG{n}{isSmall}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{k}{else}
\PYG{+w}{   }\PYG{n}{isSmall}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Assume \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} are local \sphinxcode{\sphinxupquote{int}} variables.
Code fragments are separated by a blank line below.
Pairs of the fragments are logically equivalent, but not necessarily with
a directly adjacent fragment. Match the pairs.  Be sure you understand
when different pairs would behave differently.  Caution:
there is some pretty awful code here, that we would \sphinxstyleemphasis{hope} you would never
write, but you might need to correct/read!  Think of pitfalls.
In each equivalent pair, which code fragment is more professional?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{    }\PYG{c+c1}{//a}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{    }\PYG{c+c1}{//b}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{      }\PYG{c+c1}{//c}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{    }\PYG{c+c1}{//d}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{      }\PYG{c+c1}{//e}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{k}{else}\PYG{+w}{ }\PYG{n+nf}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{    }\PYG{c+c1}{//f}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Same situation as the last problem, and same caution,
except this time assume the fragments
appear in a function that returns an \sphinxcode{\sphinxupquote{int}}.
In each pair of equivalent fragments, which is your preference?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{//a}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{//b}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{//c}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{//d}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{//e}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{//f}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{//g}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}

\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{//h}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Same situation as the last problem, and same caution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{+w}{        }\PYG{c+c1}{//a}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}
\PYG{+w}{       }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k}{else}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{+w}{  }\PYG{p}{\PYGZob{}}\PYG{+w}{     }\PYG{c+c1}{//b}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}
\PYG{+w}{       }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{        }\PYG{c+c1}{//c}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{        }\PYG{c+c1}{//d}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}
\PYG{+w}{   }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
When reading a verbal description of a problem to solve,
what are some words or phrases that suggest that some version of
an \sphinxcode{\sphinxupquote{if}} statement will be useful?

\end{enumerate}

\sphinxstepscope

\index{loop@\spxentry{loop}!while@\spxentry{while}}\index{while@\spxentry{while}}\ignorespaces 

\chapter{While Loops}
\label{\detokenize{while/while:while-loops}}\label{\detokenize{while/while:index-0}}\label{\detokenize{while/while:id1}}\label{\detokenize{while/while::doc}}
\sphinxstepscope

\index{while@\spxentry{while}!statement@\spxentry{statement}}\index{statement@\spxentry{statement}!while@\spxentry{while}}\ignorespaces 

\section{While\sphinxhyphen{}Statements}
\label{\detokenize{while/whilestatements:while-statements}}\label{\detokenize{while/whilestatements:index-0}}\label{\detokenize{while/whilestatements:id1}}\label{\detokenize{while/whilestatements::doc}}
\sphinxAtStartPar
We have seen that the sequential flow of a program
can be altered with function calls
and decisions.  The last important pattern is \sphinxstyleemphasis{repetition} or \sphinxstyleemphasis{loops}.
There are several varieties.  The simplest place to start is with
\sphinxcode{\sphinxupquote{while}} loops.

\sphinxAtStartPar
A C\#
\sphinxcode{\sphinxupquote{while}} loop behaves quite similarly to common English usage. If
you hear
\begin{quote}

\sphinxAtStartPar
While your tea is too hot, add a chip of ice.
\end{quote}

\sphinxAtStartPar
Presumably you would test your tea. If it were too hot, you would
add a little ice. If you test again and it is still too hot, you
would add ice again. \sphinxstyleemphasis{As long as} you tested and found it was true
that your tea was too hot, you would go back and add more ice.
C\# has a similar syntax:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{while (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{)}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement
\end{DUlineblock}
\end{DUlineblock}

\sphinxAtStartPar
As with an \sphinxcode{\sphinxupquote{if}} statement we will generally assume a compound statement,
after the condition, so the syntax will actually be:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{while (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
Setting up the English example as pseudocode in a similar format would be:

\begin{DUlineblock}{0em}
\item[] while ( \sphinxstyleemphasis{your tea is too hot} ) \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add a chip of ice
\end{DUlineblock}
\item[] \}
\end{DUlineblock}

\index{playing computer@\spxentry{playing computer}!loop@\spxentry{loop}}\ignorespaces 
\sphinxAtStartPar
To make things concrete and numerical, suppose the following: The
tea starts at 115 degrees Fahrenheit. You want it at 112 degrees. A
chip of ice turns out to lower the temperature one degree each
time. You test the temperature each time, and also print out the
temperature before reducing the temperature. In C\# you could
write and run the code below, saved in example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/cool/cool.cs}{cool/cool.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{115}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{112}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// first while loop code}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temperature}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The tea is cool enough.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We added a final line after the \sphinxcode{\sphinxupquote{while}} loop to remind you that
execution follows sequentially after a loop completes.

\sphinxAtStartPar
It is extremely important to totally understand how the flow of
execution works with loops.  One way to follow it
closely is to make a table with a line for each instruction
executed, keeping track of all the variables, playing computer.
as with \sphinxcode{\sphinxupquote{if}} statements, the executed lines that you show in your table
will not be in textual order, as in
{\hyperref[\detokenize{data/programstructure:sequential-execution}]{\sphinxcrossref{\DUrole{std,std-ref}{Sequential Execution}}}}.
While \sphinxcode{\sphinxupquote{if}} statements merely altered execution order
by skipping some lines, loops allow the same line in the text of your program
to be executed repeatedly, and show up in multiple places in your table.

\index{while@\spxentry{while}!execution sequence@\spxentry{execution sequence}}\index{execution sequence@\spxentry{execution sequence}!while@\spxentry{while}}\ignorespaces 
\sphinxAtStartPar
If you play computer and follow the path of execution, you could
generate the following table. Remember, that each time you reach
the end of the block after the \sphinxcode{\sphinxupquote{while}} heading,
execution returns to the \sphinxcode{\sphinxupquote{while}} heading for another test:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
temperature
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
115
&\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
115 \textgreater{} 112 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&&
\sphinxAtStartPar
prints 115
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
114
&
\sphinxAtStartPar
115 \sphinxhyphen{} 1 is 114, loop back
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
114 \textgreater{} 112 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&&
\sphinxAtStartPar
prints 114
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
113
&
\sphinxAtStartPar
114 \sphinxhyphen{} 1 is 113, loop back
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
113 \textgreater{} 112 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&&
\sphinxAtStartPar
prints 113
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
112
&
\sphinxAtStartPar
113 \sphinxhyphen{} 1 is 112, loop back
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
112 \textgreater{} 112 is false, skip loop
\\
\hline
\sphinxAtStartPar
6
&&
\sphinxAtStartPar
prints that the tea is cool
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Each time the end of the loop body block is reached, execution
\sphinxstyleemphasis{goes back} to the \sphinxcode{\sphinxupquote{while}} loop heading for another test. When the
test is finally false, execution jumps past the indented body of
the \sphinxcode{\sphinxupquote{while}} loop to the next sequential statement.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Unless a program is purely sequential,
the numbers under the \sphinxstylestrong{Line} column are \sphinxstyleemphasis{not} just in textual, sequential
order.  The order of the numbers is the order of \sphinxstyleemphasis{execution}.
Each line number in the “playing computer” table is the
line \sphinxstyleemphasis{number label} for the next particular line \sphinxstyleemphasis{getting executed}.
Since in decisions, loops, and function calls, lines may be reordered
or repeated, the corresponding line numbers may be skipped, repeated,
or otherwise out of numerical order.
\end{sphinxadmonition}

\index{while@\spxentry{while}!rubric@\spxentry{rubric}}\index{pattern for a while loop@\spxentry{pattern for a while loop}}\ignorespaces 
\sphinxAtStartPar
The biggest trick with a loop is to make the same code do the next
thing you want each time through.  That generally involves
the use of variables that are modified for each successive time through
the loop.  Here is a general pattern:

\begin{DUlineblock}{0em}
\item[] initialization
\item[] \sphinxcode{\sphinxupquote{while (}} \sphinxstyleemphasis{continuationCondition} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] do main action to be repeated
\item[] prepare variables for the next time through the loop
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
The simple first example follows this pattern directly.  Note
that the variables needed for the test of the condition must be
set up \sphinxstyleemphasis{both} in the initialization \sphinxstyleemphasis{and} inside the loop
(often at the very end).  Without a change inside the loop, the loop would
run forever!

\sphinxAtStartPar
How to manage all of this in general is a big deal for beginning students.
We will see a number of common patterns in lots of practice.  We will use
the term \sphinxstyleemphasis{successive modification loop} for loops following the pattern
above.

\sphinxAtStartPar
Test yourself: Follow the code.  Figure out what is printed.
If it helps, get detailed and play computer:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Check yourself by running the example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_while1/test\_while1.cs}{test\_while1/test\_while1.cs}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In C\#, \sphinxcode{\sphinxupquote{while}} is not used \sphinxstyleemphasis{quite} like in English. In
English you could mean to stop \sphinxstyleemphasis{as soon as} the condition you want
to test becomes false. In C\# the test is \sphinxstyleemphasis{only} made when
execution for the loop starts (or starts again),
\sphinxstyleemphasis{not} in the middle of the loop.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstyleemphasis{Predict} what will happen with this slight variation on the
previous example, switching the order in the loop body. Follow it
carefully, one step at a time.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//variation on TestWhile1.cs}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Check yourself by running the example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_while2/test\_while2.cs}{test\_while2/test\_while2.cs}.

\sphinxAtStartPar
The line sequence is important. The variable \sphinxcode{\sphinxupquote{i}} is increased before
it is printed, so the first number printed is 6. Another common
error is to assume that 10 will \sphinxstyleemphasis{not} be printed, since 10 is
\sphinxstyleemphasis{past} 9, but the test that may stop the loop is \sphinxstyleemphasis{not} made in the
middle of the loop. Once the body of the loop is started, it
continues to the end, even when \sphinxcode{\sphinxupquote{i}} becomes 10.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
i
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
4
&\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
4 \textless{} 9 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
4+2=6
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
print 6
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
6 \textless{} 9 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
6+2= 8
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
print 8
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
8 \textless{} 9 is true, do loop
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
8+2=10  \sphinxstyleemphasis{No test here}
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
print 10
\\
\hline
\sphinxAtStartPar
2
&&
\sphinxAtStartPar
10 \textless{} 9 is false, skip loop
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
You should be able to generate a table like the one above, following
the execution of one statement at a time.  You are playing through the role
of the computer in detail.
As code gets more complicated, particularly with loops, this “playing computer”
is an important skill.

\sphinxAtStartPar
\sphinxstylestrong{Problem}:  Write a program with a \sphinxcode{\sphinxupquote{while}} loop to print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
9
8
7
6
5
4
3
2
1
Blastoff!
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Analysis}:
We have seen that we can produce a regular sequence of numbers in a loop.
The “Blastoff!” part does not fit the pattern, so it is logically a \sphinxstyleemphasis{separate}
part after the loop.  We need a name for the number that decreases.  It can
be \sphinxcode{\sphinxupquote{time}}.  Remember the general rubric for a \sphinxcode{\sphinxupquote{while}} loop:

\begin{DUlineblock}{0em}
\item[] initialization
\item[] \sphinxcode{\sphinxupquote{while (}} \sphinxstyleemphasis{continuationCondition} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] do main action to be repeated
\item[] prepare variables for the next time through the loop
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
You can consider each part separately.  Where to start is partly a
matter of taste.

\sphinxAtStartPar
The main thing to do is print the time over and over.
The initial value of the time is 10.  We are going to want to keep printing
until the time is down to 1, so we \sphinxstyleemphasis{continue} while the time is at least 1,
meaning the continuationCondition can be \sphinxcode{\sphinxupquote{time \textgreater{}= 1}},
or we could use \sphinxcode{\sphinxupquote{time \textgreater{} 0}}, since \sphinxcode{\sphinxupquote{time}} is an integer here.

\sphinxAtStartPar
Finally we need to get ready to print a different time in
the next pass through the loop.
Since each successive time is one less than the previous one, the
preparation for the next value of time is:  \sphinxcode{\sphinxupquote{time = time \sphinxhyphen{} 1}}.

\sphinxAtStartPar
Putting that all together, and remembering the one thing we noted
to do after the loop,
we get \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/blastoff/blastoff.cs}{blastoff/blastoff.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Blastoff}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{time}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Blastoff!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Look back and see how we fit the general rubric.
There are a bunch of things to think about with a while loop, so
it helps to go one step at a time, thinking of the rubric and the specific
needs of the current problem.

\sphinxAtStartPar
There are many different (and more exciting) patterns of change coming
for loops,
but the simple examples so far get us started.

\index{while@\spxentry{while}!planning rubric@\spxentry{planning rubric}}\index{loop@\spxentry{loop}!planning rubric@\spxentry{planning rubric}}\index{rubric@\spxentry{rubric}!planning a loop@\spxentry{planning a loop}}\index{planning@\spxentry{planning}!loop rubric@\spxentry{loop rubric}}\ignorespaces \phantomsection\label{\detokenize{while/whilestatements:loop-rubric}}\subsubsection*{Loop Planning Rubric}

\sphinxAtStartPar
Looking ahead to more complicated and interesting problems,
here is a more complete list of questions to ask yourself when
designing a function with a \sphinxcode{\sphinxupquote{while}} loop (and most will apply to
later forms of loops, too):
\begin{itemize}
\item {} 
\sphinxAtStartPar
What data is involved? Make sure you give good variable names.

\item {} 
\sphinxAtStartPar
What needs to be initialized and how? This certainly includes any
variable tested in the condition.

\item {} 
\sphinxAtStartPar
What is the condition that will allow the loop to \sphinxstyleemphasis{continue}?  It
may be easier to think of the condition that will \sphinxstyleemphasis{stop} the loop.
That is fine \sphinxhyphen{} but remember to \sphinxstyleemphasis{negate} it (with \sphinxcode{\sphinxupquote{!}}) to turn it
into a proper \sphinxstyleemphasis{continuation} condition.

\item {} 
\sphinxAtStartPar
Distinguish: What is the code that should only be executed once?
What action do I want to repeat?

\item {} 
\sphinxAtStartPar
How do I write the repeating action so I can modify it for the next time
through the loop to work with new data?

\item {} 
\sphinxAtStartPar
What code is needed to do modifications to make the same action code work
the next time through the loop?

\item {} 
\sphinxAtStartPar
Have I thought of variables needed in the middle and declared them;
do other things need initialization?

\item {} 
\sphinxAtStartPar
Will the continuation condition eventually fail?
\sphinxstyleemphasis{Be sure to think about this!}

\item {} 
\sphinxAtStartPar
Separate the actions to be done once before the repetition (code before the
loop) from repetitive actions (in the loop) from actions not repeated, but
done after the loop (code after the loop). Missing this distinction
is a \sphinxstyleemphasis{common error}!

\end{itemize}

\sphinxAtStartPar
This is quite a sequence of steps!  Particularly looking forward to other forms of loops,
we can note a more basic split into two parts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Writing the code to make sure each desired iteration is reached
(loop dynamics: initialized data for the test condition, the test condition itself,
preparing for the next iteration)

\item {} 
\sphinxAtStartPar
Doing the work for a specific item/ireration (most of the body of the loop)

\end{itemize}

\sphinxAtStartPar
You generally only need to concentrate on one of those at a time.
If you set up how to reach all of the repetitions, giving names for the variables
to be acted on, then you can separately just concentrate on dealing with the the action/code
to deal with the \sphinxstyleemphasis{current} situation.


\subsection{Sum To \sphinxstyleliteralintitle{\sphinxupquote{n}}}
\label{\detokenize{while/whilestatements:sum-to-n}}\label{\detokenize{while/whilestatements:sumton}}
\sphinxAtStartPar
Let us write a function to sum the numbers from 1 to \sphinxcode{\sphinxupquote{n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the sum of the numbers from 1 through n.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
For instance SumToN(5) calculates 1 + 2 + 3 + 4 + 5 and returns 15.
We know how to generate a sequence of integers, but this is a place
that a programmer gets tripped up by the speed of the human mind.
You are likely
so quick at this that you just see it all at once, with the answer.

\index{concrete example@\spxentry{concrete example}}\ignorespaces 
\sphinxAtStartPar
In fact, you and the computer need to do this in steps.  To help see, let
us take a concrete example like the one above for SumToN(5), and write out a
detailed sequence of steps like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 = 1 + 2
6 = 3 + 3
10 = 6 + 4
15 = 10 + 5
\end{sphinxVerbatim}

\sphinxAtStartPar
You could put this in code directly for a specific sum, but if \sphinxcode{\sphinxupquote{n}} is general,
we need a loop, and hence we must see a \sphinxstyleemphasis{pattern} in code that we can repeat.

\sphinxAtStartPar
In each calculation the second term in the additions is a successive integer,
that we can generate.  Starting in the second line, the first number
in each addition
is the sum from the previous line.  Of course the next integer and the next
partial sum change from step to step, so in order to use the same code over and
over we will need changeable variables, with names.  We can make the partial
sum be \sphinxcode{\sphinxupquote{sum}} and we can call the next integer \sphinxcode{\sphinxupquote{i}}.  Each addition can be
in the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}
\end{sphinxVerbatim}

\sphinxAtStartPar
We need to remember that result, the new sum.  You might first think to introduce
such a name:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{newSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will work.  We can go through the \sphinxcode{\sphinxupquote{while}} loop rubric:

\sphinxAtStartPar
The variables are \sphinxcode{\sphinxupquote{sum}}, \sphinxcode{\sphinxupquote{newSum}} and \sphinxcode{\sphinxupquote{i}}.

\sphinxAtStartPar
To evaluate

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{newSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
the first time in the loop, we need \sphinxstyleemphasis{initial} values for sum and i.
Our concrete example leads the way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We need a \sphinxcode{\sphinxupquote{while}} loop heading with a continuation condition.  How
long do we want to add the next \sphinxcode{\sphinxupquote{i}}?  That is for all the value up to and
including n:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is one more important piece \sphinxhyphen{} making sure the same code
\begin{quote}

\sphinxAtStartPar
newSum = sum + i;
\end{quote}

\sphinxAtStartPar
works for the \sphinxstyleemphasis{next} time through the loop.  We have dealt before with
the idea of the next number in sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
What about \sphinxcode{\sphinxupquote{sum}}?  What was the \sphinxcode{\sphinxupquote{newSum}}
on \sphinxstyleemphasis{one} time through the loop becomes the old or
just plain \sphinxcode{\sphinxupquote{sum}} the \sphinxstyleemphasis{next} time through, so we can make an assignment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newSum}\PYG{p}{:}
\end{sphinxVerbatim}

\sphinxAtStartPar
All together we calculate the sum with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{newSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newSum}\PYG{p}{:}
\PYG{+w}{   }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This exactly follows our general rubric, with preparation for the next time
through the loop at the end of the loop.
We can condense it in this case: Since \sphinxcode{\sphinxupquote{newSum}} is only used
once, we can do away with this extra variable name,
and directly change the value of sum:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally this was supposed to fit in a function.  The ultimate purpose
was to \sphinxstyleemphasis{return} the sum, which is the final value of the
variable \sphinxcode{\sphinxupquote{sum}}, so the whole function is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the sum of the numbers from 1 through n.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{     }\PYG{c+c1}{// line 1}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{       }\PYG{c+c1}{// 2}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{          }\PYG{c+c1}{// 3}
\PYG{+w}{      }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{// 4}
\PYG{+w}{      }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{             }\PYG{c+c1}{// 5}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}\PYG{+w}{               }\PYG{c+c1}{// 6}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{testing@\spxentry{testing}!edge case@\spxentry{edge case}}\index{range testing@\spxentry{range testing}}\index{edge case@\spxentry{edge case}}\ignorespaces 
\sphinxAtStartPar
The comment before the function definition does not give a clear idea of the
range of possible values for \sphinxcode{\sphinxupquote{n}}.  How small makes sense for the comment?
What actually works in the function?  The smallest expression
starting with 1 would just be 1: (\sphinxcode{\sphinxupquote{n}} is 1).  Does that work in the function?
You were probably not thinking of that when developing the function!
Now look back now at this \sphinxstyleemphasis{edge case}.  You can play computer on the code
or directly test it.  In this case the initialization of \sphinxcode{\sphinxupquote{sum}} is 1,
and the body of the loop \sphinxstyleemphasis{never} runs (2 \textless{}= 1 is false).  The function
execution jumps right to the return statement, and
does return 1, and everything is fine.

\sphinxAtStartPar
Also you should check the program in a more general situation, say with \sphinxcode{\sphinxupquote{n}}
being 4.  You should be able to play computer and generate this table,
using the line numbers shown in comments at the end of lines,
and following one statement of execution at a time.  We only
make entries where variables change value.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
i
&\sphinxstyletheadfamily 
\sphinxAtStartPar
sum
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
1
&&&
\sphinxAtStartPar
assume 4 is passed for n
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1
&\\
\hline
\sphinxAtStartPar
3
&&&
\sphinxAtStartPar
2\textless{}=4: true, enter loop
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
1+2=3
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
3
&&
\sphinxAtStartPar
2+1=3, bottom of loop
\\
\hline
\sphinxAtStartPar
3
&&&
\sphinxAtStartPar
3\textless{}=4: true
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
3+3=6
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
3+1=4, bottom of loop
\\
\hline
\sphinxAtStartPar
3
&&&
\sphinxAtStartPar
4\textless{}=4: true
\\
\hline
\sphinxAtStartPar
4
&&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
6+4=10
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
5
&&
\sphinxAtStartPar
4+1=5, bottom of loop
\\
\hline
\sphinxAtStartPar
3
&&&
\sphinxAtStartPar
5\textless{}=4: false, skip loop
\\
\hline
\sphinxAtStartPar
6
&&&
\sphinxAtStartPar
return 10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The return only happens once, so it is not in the loop.  You get \sphinxstyleemphasis{a} value
for a sum each time through, but not the final one.  A common beginner
error is to put the return statement inside the loop, like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{// 1   BAD VERSION!!!}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{// 2}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{       }\PYG{c+c1}{// 3}
\PYG{+w}{      }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{// 4}
\PYG{+w}{      }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{          }\PYG{c+c1}{// 5}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{// 6  WRONG!}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Recall that \sphinxstyleemphasis{when a return statement is reached, function execution ends},
\sphinxstyleemphasis{no matter what comes next in the code}.
(This is a way to break out of a \sphinxcode{\sphinxupquote{while}} loop that we will find useful
later.)  In this case however, it is not what we want at all.  The first sum
is calculated in line 4, so \sphinxcode{\sphinxupquote{sum}} becomes 2 + 1, but when you get to line
6, the function terminates and never loops back, returning 3.

\sphinxAtStartPar
Now about large n….

\index{big oh@\spxentry{big oh}!order of n@\spxentry{order of n}}\index{order of n@\spxentry{order of n}}\ignorespaces 
\sphinxAtStartPar
With loops we can make programs run for a long time.
The time taken becomes an issue.  In this case we go though the loop
n\sphinxhyphen{}1 times, so the total time is approximately proportional to n.
We write that the time is O(n), spoken “oh of n”, or “big oh of n” or
“order of n”.

\index{pitfall@\spxentry{pitfall}!limit on number size@\spxentry{limit on number size}}\index{overflow@\spxentry{overflow}}\ignorespaces 
\sphinxAtStartPar
Computers are pretty fast, so you can try the testing program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_test/sum\_to\_n\_test.cs}{sum\_to\_n\_test/sum\_to\_n\_test.cs}
and it will go by so fast, that you will hardly notice.  Try these specific
numbers in tests: 5, 6, 1000, 10000, 98765.  All look OK?  Now try 66000.
On many systems you will get quite a surprise!
This is the first place we have to deal with the limited
size of the \sphinxcode{\sphinxupquote{int}} type.
On many systems the limit is a bit over 2 billion.
You can check out the size of \sphinxcode{\sphinxupquote{int.MaxValue}} in csharp.
The answer for 66000,
and \sphinxstyleemphasis{also} 98765, is bigger than the upper limit.
Luckily the obviously wrong negative answer
for 66000 pops out at you.  Did you guess before you saw the answer for
66000, that there was an issue for
98765?  It is a good thing that no safety component in a big bridge was being
calculated!  It is a big deal that the system fails \sphinxstyleemphasis{silently}
in such situations.  \sphinxstyleemphasis{Think} how large the data may be that you deal with!

\sphinxAtStartPar
Now look at and run \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_long/sum\_to\_n\_long.cs}{sum\_to\_n\_long/sum\_to\_n\_long.cs}.  The sum is
a \sphinxcode{\sphinxupquote{long}} integer here. Check out in csharp how big
a \sphinxcode{\sphinxupquote{long}} can be (\sphinxcode{\sphinxupquote{long.MaxValue}}).  This version of the program
works for 100000 and for 98765.  We can get correct
answers for things that will take perceptible time.  Try working up to
1 billion (1000000000, nine 0’s).  It takes a while: O(n) can be slow!

\sphinxAtStartPar
By hand it is a lot slower, unless you totally change the algorithm:
There is a classic story about how a calculation like this
was done in grade school (n=100) by the famous
mathematician Gauss. His teacher was trying to keep him busy.
Gauss discovered the general, exact, mathematical formula:
\begin{quote}

\sphinxAtStartPar
1 + 2 + 3 + … + n = n(n+1)/2.
\end{quote}

\sphinxAtStartPar
That is the number of terms (n), times the average term (n+1)/2.

\index{big oh@\spxentry{big oh}!constant order@\spxentry{constant order}}\index{constant order@\spxentry{constant order}}\ignorespaces 
\sphinxAtStartPar
Our loop was instructive, but not the fastest approach.  The simple exact
formula takes about the same time for any n.
(That is as long as the result fits in
a standard type of computer integer!)
This is basically constant time.  In discussing
how the speed relates to the size of n, we say it is O(1).
The point is here that 1 is a constant.  The time is of \sphinxstyleemphasis{constant order}.

\index{pitfall@\spxentry{pitfall}!division@\spxentry{division}}\index{division@\spxentry{division}!pitfall@\spxentry{pitfall}}\ignorespaces 
\sphinxAtStartPar
We can write a ridiculously short
function following Gauss’s model.  Here we introduce the variable average,
as in the motivation for Gauss’s answer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the sum of the numbers from 1 through n.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//CHANGED:  quick and WRONG}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{average}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{//from Gausse\PYGZsq{}s motivation}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{average}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Run the example program containing it: \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_long\_bad/sum\_to\_n\_long\_bad.cs}{sum\_to\_n\_long\_bad/sum\_to\_n\_long\_bad.cs}.

\sphinxAtStartPar
Test it with 5, and then try 6. ???

\sphinxAtStartPar
“Ridiculously short” does not imply correct!  The problem goes back
to the fact that Gauss was in \sphinxstyleemphasis{math class} and you are doing
Computer Science.  Think of a subtle difference that might come in here:
Though (n+1)/2 is fine as math, recall the division operator does not
always give correct answers in C\#.  You get an integer answer from the
integer (or long) operands.  Of course the exact mathematical final answer
is an integer when \sphinxstyleemphasis{adding} integers, but splitting it according to
Gauss’s motivation can put a mathematical non\sphinxhyphen{}integer in the middle.

\sphinxAtStartPar
The C\# fix: The final answer is clearly an integer, so if we do the division
last, when we know the answer will be an integer (assuming a \sphinxcode{\sphinxupquote{long}} integer),
things should be better:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\end{sphinxVerbatim}

\index{cast@\spxentry{cast}}\ignorespaces 
\sphinxAtStartPar
Here is a shot at the whole function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the sum of the numbers from 1 through n.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//CHANGED:  quick and still WRONG}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// final division will produce an integer}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Run the example program containing it: \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_long\_bad2/sum\_to\_n\_long\_bad2.cs}{sum\_to\_n\_long\_bad2/sum\_to\_n\_long\_bad2.cs}.

\sphinxAtStartPar
Test it with 5, and then try 6. Ok so far, but go on to long integer range:
try 66000 that messed us up before.  ??? You get an answer that is not
a multiple of 1000: not what we got before!  What other issues do we have
between math and C\#?

\sphinxAtStartPar
Further analysis:  To make sure the function always worked, it made sense
to leave the parameter \sphinxcode{\sphinxupquote{n}} an \sphinxcode{\sphinxupquote{int}}.  The function would not work
with \sphinxcode{\sphinxupquote{n}} as the largest \sphinxcode{\sphinxupquote{long}}.  The result can still be big enough
to only fit in a \sphinxcode{\sphinxupquote{long}}, so the return value is a \sphinxcode{\sphinxupquote{long}}.  All
this is reasonable but the C\# result is still wrong!  Look deeper.
While the result of \sphinxcode{\sphinxupquote{n*(n+1)/2}} is \sphinxstyleemphasis{assigned} to a \sphinxcode{\sphinxupquote{long}} variable,
the \sphinxstyleemphasis{calculation} \sphinxcode{\sphinxupquote{n*(n+1)/2}} is done with \sphinxcode{\sphinxupquote{int}}s not mathematical
integers.  By the same general type rule that led to the (n+1)/2 error
earlier, these operations on \sphinxcode{\sphinxupquote{int}}s produce an \sphinxcode{\sphinxupquote{int}} result, even
when wrong.

\sphinxAtStartPar
We need to force the \sphinxstyleemphasis{calculation} to produce a \sphinxcode{\sphinxupquote{long}}.
In the correct looping version \sphinxcode{\sphinxupquote{sum}} was a \sphinxcode{\sphinxupquote{long}}, and that
forced all the later arithmetic to be with longs.  Here are two variations
that work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{nLong}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nLong}\PYG{o}{*}\PYG{p}{(}\PYG{n}{nLong}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or we can avoid a new variable name by {\hyperref[\detokenize{data/types-and-conversions:cast}]{\sphinxcrossref{\DUrole{std,std-ref}{Casting}}}} to \sphinxcode{\sphinxupquote{long}}, converting
the first (left) operand to \sphinxcode{\sphinxupquote{long}}, so all the later left\sphinxhyphen{}to\sphinxhyphen{}right
operations are forced to be \sphinxcode{\sphinxupquote{long}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{n}\PYG{o}{*}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can try example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_long\_quick/sum\_to\_n\_long\_quick.cs}{sum\_to\_n\_long\_quick/sum\_to\_n\_long\_quick.cs}
to finally get a result that is dependably fast and correct.

\sphinxAtStartPar
Important lessons from this humble summation problem:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Working} and being \sphinxstyleemphasis{efficient} are two different things in general.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Math} operations and C\# operations are not always the same.
Knowing this in theory is not the same as remembering it in practice!

\end{itemize}

\sphinxAtStartPar
Further special syntax that only makes sense in any kind of loop is discussed in
{\hyperref[\detokenize{for/forstatements:break-continue}]{\sphinxcrossref{\DUrole{std,std-ref}{Break and Continue}}}}, after we introduce the last kind of loop.

\sphinxstepscope

\index{while@\spxentry{while}!index for sequence@\spxentry{index for sequence}}\index{sequence with while@\spxentry{sequence with while}}\ignorespaces 

\section{While\sphinxhyphen{}Statements with Sequences}
\label{\detokenize{while/while-with-sequence:while-statements-with-sequences}}\label{\detokenize{while/while-with-sequence:while-sequence}}\label{\detokenize{while/while-with-sequence:index-0}}\label{\detokenize{while/while-with-sequence::doc}}

\subsection{One Character Per Line}
\label{\detokenize{while/while-with-sequence:one-character-per-line}}
\sphinxAtStartPar
We will process many sequences or collections.  At this point
the only collection we have discussed is a string \sphinxhyphen{} a sequence of
characters that we can index.

\phantomsection\label{\detokenize{while/while-with-sequence:onecharperline}}
\index{example@\spxentry{example}!OneCharPerLine@\spxentry{OneCharPerLine}}\index{OneCharPerLine example@\spxentry{OneCharPerLine example}}\ignorespaces 
\sphinxAtStartPar
Consider the following silly function description and heading as a start:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Print the characters of s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OneCharPerLine("bug")}} would print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
b
u
g
\end{sphinxVerbatim}

\sphinxAtStartPar
We are accessing one character at a time.  We can do that with
the indexing notation.  Thinking concretely about the example above,
we are looking to print, \sphinxcode{\sphinxupquote{s{[}0{]}}}, \sphinxcode{\sphinxupquote{s{[}1{]}}}, \sphinxcode{\sphinxupquote{s{[}2{]}}}.  If
we knew we would always have three characters, we could do this
with three explicit print statements, but we are looking to write a general
definition for an arbitrary length string:
This requires a loop.
For now our only option is a \sphinxcode{\sphinxupquote{while}} loop.  We can follow our basic
{\hyperref[\detokenize{while/whilestatements:loop-rubric}]{\sphinxcrossref{\DUrole{std,std-ref}{loop planning rubric}}}},
one step at a time:
The index is changing in a simple repetitive sequence.
We can call the
index \sphinxcode{\sphinxupquote{i}}.  Its initial value is clearly 0.
That is our initialization.  We need a \sphinxcode{\sphinxupquote{while}} loop continuation
condition.
For the 3\sphinxhyphen{}character string example, the last index above is 2.
In general we want \sphinxstyleemphasis{all} the characters.  Recall the index of the last
character is the length \sphinxhyphen{} 1, or with our parameter \sphinxcode{\sphinxupquote{s}}, \sphinxcode{\sphinxupquote{s.Length \sphinxhyphen{} 1}}
The \sphinxcode{\sphinxupquote{while}} loop condition needs to allow indices through
\sphinxcode{\sphinxupquote{s.Length \sphinxhyphen{} 1}}.  We could write a condition with \sphinxcode{\sphinxupquote{\textless{}=}} or more
concisely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the body of the loop, the main thing is to print the next character,
and the next character is \sphinxcode{\sphinxupquote{s{[}i{]}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\index{++ increment@\spxentry{++ increment}}\index{\sphinxhyphen{}\sphinxhyphen{} decrement@\spxentry{\sphinxhyphen{}\sphinxhyphen{} decrement}}\index{operator@\spxentry{operator}!++ increment@\spxentry{++ increment}}\index{operator@\spxentry{operator}!\sphinxhyphen{}\sphinxhyphen{} decrement@\spxentry{\sphinxhyphen{}\sphinxhyphen{} decrement}}\ignorespaces 
\sphinxAtStartPar
We also need to remember the part to get ready for the next time
through the loop.  We have dealt with regular sequence of values
before.  We change \sphinxcode{\sphinxupquote{i}} with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This change is so common, there is a simpler syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This increases the value of the numeric variable i by 1.
(The reverse is \sphinxcode{\sphinxupquote{i\sphinxhyphen{}\sphinxhyphen{};}}) %
\begin{footnote}[1]\sphinxAtStartFootnote
To be complete, the statements \sphinxcode{\sphinxupquote{c = c + 1;}} and \sphinxcode{\sphinxupquote{c++;}} are not always
equivalent.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{c++}} the type of \sphinxcode{\sphinxupquote{c}} must be numeric, but not necessarily \sphinxcode{\sphinxupquote{int}}.
It could be a \sphinxstyleemphasis{smaller} type, like \sphinxcode{\sphinxupquote{char}}.

\sphinxAtStartPar
With a  \sphinxcode{\sphinxupquote{c}} of type \sphinxcode{\sphinxupquote{char}} the \sphinxcode{\sphinxupquote{c++}} could
not be replaced by \sphinxcode{\sphinxupquote{c = c + 1}}, but you could use \sphinxcode{\sphinxupquote{c = (char)(c + 1)}}:
The \sphinxcode{\sphinxupquote{int}} literal 1 forces
the sum expression to be an \sphinxcode{\sphinxupquote{int}}, which must be cast back to a \sphinxcode{\sphinxupquote{char}} to be
assigned to \sphinxcode{\sphinxupquote{c}}.  Similarly with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}}} operator.
%
\end{footnote}

\sphinxAtStartPar
So all together:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Print the characters of s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can test this with example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/char\_loop1/char\_loop1.cs}{char\_loop1/char\_loop1.cs}.

\sphinxAtStartPar
This is a very common pattern.
We could do anything we want with each individual character,
not just print it.

\index{ReversedPrint example@\spxentry{ReversedPrint example}}\ignorespaces 

\subsubsection{String Backwards Exercise/Example}
\label{\detokenize{while/while-with-sequence:string-backwards-exercise-example}}\label{\detokenize{while/while-with-sequence:reversed-print-example}}\label{\detokenize{while/while-with-sequence:index-3}}
\sphinxAtStartPar
Here is a variation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print s in reverse order; no extra newlines}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintReversed}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are a few changes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You do not want to go on to the next line, so use \sphinxcode{\sphinxupquote{Write}},
not \sphinxcode{\sphinxupquote{WriteLine}}.

\item {} 
\sphinxAtStartPar
It is still a regular sequence of character indices, but
we are working backwards through the string.  We have created
a decreasing sequence before.  Where do
you start?  Where do you stop?  What is the condition? How do you
get ready for the next time through the loop? (Remember our newest
notation.)

\end{itemize}

\sphinxAtStartPar
Our code with driver is in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/reversed\_print/reversed\_print.cs}{reversed\_print/reversed\_print.cs}.

\index{string@\spxentry{string}!PrintVowels@\spxentry{PrintVowels}}\index{PrintVowels example@\spxentry{PrintVowels example}}\ignorespaces 

\subsection{Print Vowels Function}
\label{\detokenize{while/while-with-sequence:print-vowels-function}}\label{\detokenize{while/while-with-sequence:printvowels}}\label{\detokenize{while/while-with-sequence:index-4}}
\sphinxAtStartPar
Let us get more complicated.  Consider the function described:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print the vowels (aeiou) in s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For instance PrintVowels(“computer”) would print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
o
u
e
\end{sphinxVerbatim}

\sphinxAtStartPar
We have seen that we can go through the whole string and do the same
thing each time through the loop, using \sphinxcode{\sphinxupquote{s{[}i{]}}} in some specific way.

\sphinxAtStartPar
This new description seems problematic.  We do \sphinxstyleemphasis{not} appear to want to do
the same thing each time:  We only want to print \sphinxstyleemphasis{some} of the
characters.  Again your eyes and mind are so fast, you likely miss what you
need to do when you go through \sphinxcode{\sphinxupquote{PrintVowels}} by hand.  Your
eyes let you just grab the vowels easily, but think, what is actually
happening?  You are checking each character to see \sphinxstylestrong{if} it is a vowel,
and printing it if it is:  You are doing the same thing each time \sphinxhyphen{}
\sphinxstyleemphasis{testing} \sphinxstylestrong{if} the character is a vowel.  The pseudocode is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{k}{is}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{n}{vowel}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{print}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We \sphinxstyleemphasis{do} want to do this each time through the loop.  We \sphinxstyleemphasis{can} use
a \sphinxcode{\sphinxupquote{while}} statement.

\sphinxAtStartPar
Next task:  convert the pseudocode “s{[}i{]} is a vowel” to C\#.

\sphinxAtStartPar
There are multiple approaches.  The one you get by following your
nose is just to consider all the cases where it is true:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}e\PYGZsq{}}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}i\PYGZsq{}}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}o\PYGZsq{}}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}u\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
How do you combine them into a condition?
The letter can be a \sphinxstyleemphasis{or} e \sphinxstyleemphasis{or} i \sphinxstyleemphasis{or} o \sphinxstyleemphasis{or} u.  We get the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print the vowels (aeiou) in s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}e\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}i\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}
\PYG{+w}{            }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}o\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}u\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
That has a long condition!  Here is a nice trick to shorten that:
We want to check if a character is in a group of letters.  We have
already seen the string method IndexOf.  Recall we can use it to see if
a character is in or not in a string.  We can use \sphinxcode{\sphinxupquote{"aeiou".IndexOf(s{[}i{]})}}.
We do not care \sphinxstyleemphasis{where} \sphinxcode{\sphinxupquote{s{[}i{]}}} comes in the string of vowels.
All we care is that \sphinxcode{\sphinxupquote{"aeiou".IndexOf(s{[}i{]}) \textgreater{}= 0}}.

\index{string@\spxentry{string}!Contains@\spxentry{Contains}}\index{Contains for strings@\spxentry{Contains for strings}}\ignorespaces 
\sphinxAtStartPar
This is still a bit of a mouthful.  Often it is just important if a
character or string is \sphinxstyleemphasis{contained} in another string, not where it appears,
so it is easier to
use the string method \sphinxcode{\sphinxupquote{Contains}}.  Though IndexOf takes either a string
or a character as parameter, \sphinxcode{\sphinxupquote{Contains}} only takes a string.  There is a
nice quick idiom to convert anything to a string:  use \sphinxcode{\sphinxupquote{""+}}.
The condition could be \sphinxcode{\sphinxupquote{"aeiou".Contains(""+s{[}i{]})}}.
The \sphinxcode{\sphinxupquote{"" + s{[}i{]}}} adds
the string version of \sphinxcode{\sphinxupquote{s{[}i{]}}} to the empty string.

\sphinxAtStartPar
The function is still not as general as it might be:
Only lowercase vowels are listed.  We could do something with
\sphinxcode{\sphinxupquote{ToLower}}, or just use the condition: \sphinxcode{\sphinxupquote{"aeiouAEIOU".Contains(""+s{[}i{]})}}

\sphinxAtStartPar
This variation is in example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/vowels2/vowels2.cs}{vowels2/vowels2.cs}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print the vowels (aeiou) in s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{vowels}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}aeiouAEIOU\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{vowels}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{example@\spxentry{example}!check\_digits@\spxentry{check\_digits}}\index{IsDigits example function@\spxentry{IsDigits example function}}\ignorespaces 

\subsection{IsDigits Function}
\label{\detokenize{while/while-with-sequence:isdigits-function}}\label{\detokenize{while/while-with-sequence:isdigits}}\label{\detokenize{while/while-with-sequence:index-6}}
\sphinxAtStartPar
Consider a variation, determining if \sphinxstyleemphasis{all} the characters
in a string are vowels.  We could work on that, but it is
not very useful.  Instead let us consider if all the
characters are digits.  This is a true\sphinxhyphen{}false question, so the function
to determine this would return a Boolean result:

\sphinxAtStartPar
There are several ways to check if a character is a digit.  We could use the
\sphinxcode{\sphinxupquote{Contains}} idiom from above, but here is another option:
The integer codes for digits are sequential,
and since characters are technically a kind of integer, we can
compare:  The character \sphinxcode{\sphinxupquote{s{[}i{]}}} is a digit if it is in the range from \sphinxcode{\sphinxupquote{\textquotesingle{}0\textquotesingle{}}}
to \sphinxcode{\sphinxupquote{\textquotesingle{}9\textquotesingle{}}}, so the condition can be written:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly  the condition \sphinxcode{\sphinxupquote{s{[}i{]}}} is not a digit, can be written
negating the compound condition as in {\hyperref[\detokenize{decisions/compoundconditions:compound-boolean-expressions}]{\sphinxcrossref{\DUrole{std,std-ref}{Compound Boolean Expressions}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you think of going through by hand and checking,
you would check through the
characters sequentially and if you find a non\sphinxhyphen{}digit,
you would want to \sphinxstyleemphasis{remember} that the string is not only digits.

\sphinxAtStartPar
One way to do this is have a variable holding an answer so far:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course initially, you have not found any non\sphinxhyphen{}digits, so it starts off true.
As you go through
the string, you want to make sure that answer is changed to \sphinxcode{\sphinxupquote{false}}
if a non\sphinxhyphen{}digit is encountered:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When we get all the way through the string, the answer so far is the
final answer to be returned:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return true if s contains one or more digits}
\PYG{c+c1}{/// and nothing else. Otherwise return false.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Remember something to always consider:  edge cases.
In the description it says it is true for a string of \sphinxstyleemphasis{one or more} digits.

\sphinxAtStartPar
Check examples of length 1 and 0.
Length 1 is fine, but it fails for the empty string,
since the loop is skipped and the initial answer, \sphinxcode{\sphinxupquote{true}} is returned.

\sphinxAtStartPar
There are many ways to fix this.  We will know right up front that the answer
is false if the length is 0, and we could immediately set
\sphinxcode{\sphinxupquote{allDigitsSoFar}} to false.  We would need to change the initialization
so it checks the length and chooses the right value for \sphinxcode{\sphinxupquote{allDigitsSoFar}},
true or false. Since we are selecting between two values,
an \sphinxcode{\sphinxupquote{if}} statement should occur to you:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we substitute this initialization for \sphinxcode{\sphinxupquote{allDigitsSoFar}},
the code will satisfy the edge case, and the code will always
work.  Still, this code can be improved:

\sphinxAtStartPar
Examine the \sphinxcode{\sphinxupquote{if}} statement more closely:

\begin{DUlineblock}{0em}
\item[] if the condition is  \sphinxcode{\sphinxupquote{true}}, \sphinxcode{\sphinxupquote{allDigitsSoFar}} is \sphinxcode{\sphinxupquote{true}};
\item[] if the condition is \sphinxcode{\sphinxupquote{false}}, \sphinxcode{\sphinxupquote{allDigitsSoFar}} is \sphinxcode{\sphinxupquote{false}};
\end{DUlineblock}

\sphinxAtStartPar
See the symmetry: the value assigned to \sphinxcode{\sphinxupquote{allDigitsSoFar}} is always
the \sphinxstyleemphasis{value of the condition}.

\sphinxAtStartPar
A \sphinxstyleemphasis{much} more concise and still equivalent initialization is just:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In more generality this
conciseness comes from the fact that it is a \sphinxstyleemphasis{Boolean} value that
you are trying to set each time, based on a \sphinxstyleemphasis{Boolean} condition:  You do not
need to do that with an \sphinxcode{\sphinxupquote{if}} statement!  You just need an
assignment statement.  If you use an \sphinxcode{\sphinxupquote{if}} statement in such a situation,
you being verbose and marking yourself as a novice!

\sphinxAtStartPar
It could even be slightly more concise:  The precedence of assignment is
very low, lower than the comparison \sphinxcode{\sphinxupquote{\textgreater{}}},
so the parentheses could be omitted.  We think the
code is easier to read with the parentheses left in, as written above.

\sphinxAtStartPar
The whole function would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return true if s contains one or more digits}
\PYG{c+c1}{/// and nothing else. Otherwise return false.}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{allDigitsSoFar}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can try this code in example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/check\_digits1/check\_digits1.cs}{check\_digits1/check\_digits1.cs}.

\index{return@\spxentry{return}!from inside loop@\spxentry{from inside loop}}\ignorespaces 
\sphinxAtStartPar
Note that we earlier made an improvement by replacing an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement
generating a Boolean value by a simple Boolean assignment.
In the most recent sample code, there is an \sphinxcode{\sphinxupquote{if}} statement setting a Boolean
value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You might be tempted to replace this \sphinxcode{\sphinxupquote{if}} statement by a simple Boolean
assignment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{allDigitsSoFar}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// bad!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Play computer with this change to see for yourself why it is bad, before
looking at our explanation below….

\sphinxAtStartPar
The place where we originally said to use a simple Boolean assignment was
replacing an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement, that \sphinxstyleemphasis{always} set a Boolean value.  In the more
recent correct code for digits, we had a simple \sphinxcode{\sphinxupquote{if}} statement,
and were only setting the boolean variable
to \sphinxcode{\sphinxupquote{false}} \sphinxstyleemphasis{some} of the time: when we had \sphinxstyleemphasis{not} found a digit.  The bad code
sets the variable for \sphinxstyleemphasis{each} character in the string,
so it can change an earlier \sphinxcode{\sphinxupquote{false}} value back to \sphinxcode{\sphinxupquote{true}} for a later digit.
The final value
always comes from the the \sphinxstyleemphasis{last} character in the string!  We want the
function to come up with an answer \sphinxcode{\sphinxupquote{false}} if \sphinxstyleemphasis{any} character is not a digit,
not just the last character.  The bad code would give the wrong answer
with the string “R2D2”.  If you do not see that, play computer with this string
and the bad code variation
that sets \sphinxcode{\sphinxupquote{allDigitsSoFar}} every time through the loop.

\sphinxAtStartPar
There is a less commonly useful way to make an assignment without \sphinxcode{\sphinxupquote{if}}
work here %
\begin{footnote}[2]\sphinxAtStartFootnote
The Boolean assignment did not work when \sphinxcode{\sphinxupquote{allDigitsSoFar}} was already
\sphinxcode{\sphinxupquote{false}}, and the next character was a digit.  This could be fixed with
a compound Boolean expression in the assignment:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{allDigitsSoFar = allDigitsSoFar  \&\& (s{[}i{]} \textless{} \textquotesingle{}0\textquotesingle{} || s{[}i{]} \textgreater{} \textquotesingle{}9\textquotesingle{});}}

\sphinxAtStartPar
This way, once \sphinxcode{\sphinxupquote{allDigitsSoFar}} is \sphinxcode{\sphinxupquote{false}}, it stays \sphinxcode{\sphinxupquote{false}}.
%
\end{footnote}, but a much more important,
improved approach follows:

\sphinxAtStartPar
The last correct code is still inefficient.  If an early
character in a long string is not a digit, we already know the
final answer, but this code goes through and still checks all the
other characters in the string!  People checking by hand
would stop as soon as they found a
non\sphinxhyphen{}digit.  We can do that in several ways with C\#, too.
Since this is a function, and we would know the final answer
where we find a non\sphinxhyphen{}digit,
the simplest thing is to use the fact that a return statement
\sphinxstyleemphasis{immediately terminates} the function (even if in a loop).

\sphinxAtStartPar
Instead of setting a variable to \sphinxcode{\sphinxupquote{false}} to \sphinxstyleemphasis{later} be returned,
we can return right away, using the loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
What if the loop terminates normally (no return from inside)?
That means no
non\sphinxhyphen{}digit was found, so if there are any characters at all,
they are all digits. There are
\sphinxstyleemphasis{one or more} digits as long as the string length is \sphinxstyleemphasis{positive}.
Again we do \sphinxstyleemphasis{not} need an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement to check the length and
set the Boolean result.
Look in the full
code for the function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return true if s contains one or more digits}
\PYG{c+c1}{/// and nothing else. Otherwise return false.}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The full code with a \sphinxcode{\sphinxupquote{Main}} testing program is in
example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/check\_digits2/check\_digits2.cs}{check\_digits2/check\_digits2.cs}.

\sphinxAtStartPar
Returning out of a loop
is a good pattern to remember when you are searching for something,
and you know the final answer for your function as soon as you find it.

\index{playing computer@\spxentry{playing computer}!loop@\spxentry{loop}}\index{loop@\spxentry{loop}!playing computer@\spxentry{playing computer}}\ignorespaces 

\subsection{Play Computer With a Loop}
\label{\detokenize{while/while-with-sequence:play-computer-with-a-loop}}\label{\detokenize{while/while-with-sequence:index-8}}
\sphinxAtStartPar
We have not given you a chance to play computer with a loop.  Here is
some simple silly code,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/loop\_steps/loop\_steps.cs}{loop\_steps/loop\_steps.cs},
also using a sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{LoopSteps}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// play computer and predict what this loop does}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}abcd\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Play computer, completing the table.  You fill in the line numbers,
carefully.  The sequence is \sphinxstyleemphasis{not} 9, 10, 11, 12, 13!


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
i
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comment
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
Start at beginning of Main
\\
\hline
\sphinxAtStartPar
7
&&
\sphinxAtStartPar
set s = “abcd” (does not change)
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
initialize i
\\
\hline
\sphinxAtStartPar
…
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Duplicate Character Exercise}
\label{\detokenize{while/while-with-sequence:duplicate-character-exercise}}
\sphinxAtStartPar
Create a file \sphinxcode{\sphinxupquote{double\_char\_test.cs}},
and write and test a function with the documentation and heading below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// If two consecutive characters in s are the same, return true.}
\PYG{c+c1}{/// Return false otherwise.  Examples:}
\PYG{c+c1}{/// HasDoubleChar(\PYGZdq{}bigfoot\PYGZdq{}) and HasDoubleChar(\PYGZdq{}aaah!\PYGZdq{}) are true;}
\PYG{c+c1}{/// HasDoubleChar(\PYGZdq{}treated\PYGZdq{}) and HasDoubleChar(\PYGZdq{}haha!\PYGZdq{}) are false.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{HasDoubleChar}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You may want to play computer on a short example \sphinxhyphen{} there is an easy mistake
to make.

\sphinxstepscope

\index{interactive while loop@\spxentry{interactive while loop}}\index{loop@\spxentry{loop}!while@\spxentry{while}}\index{while@\spxentry{while}!interactive@\spxentry{interactive}}\ignorespaces 

\section{Interactive \sphinxstyleliteralintitle{\sphinxupquote{while}} Loops}
\label{\detokenize{while/whileinteractive:interactive-while-loops}}\label{\detokenize{while/whileinteractive:index-0}}\label{\detokenize{while/whileinteractive:id1}}\label{\detokenize{while/whileinteractive::doc}}
\sphinxAtStartPar
Next we consider a particular form of \sphinxcode{\sphinxupquote{while}} loops:  Interactive while loops
involve input from the user each time through the loop.
We consider them now for three reasons:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Interactive \sphinxcode{\sphinxupquote{while}} loops have one special ‘gotcha’
worth illustrating.

\item {} 
\sphinxAtStartPar
We will illustrate some general techniques for understanding and developing
\sphinxcode{\sphinxupquote{while}} loops.

\item {} 
\sphinxAtStartPar
As a practical matter,
we can greatly improve the utility input functions we have been using, and
add some more.

\end{itemize}

\sphinxAtStartPar
We already have discussed the PromptInt function.  The user can choose
any int.  Sometimes we only want an integer in a certain range.
One approach is to not accept a bad value, but make the user repeat
trying until explicitly
entering a value in the right range.  In theory the user could make errors
for some time, so a loop makes sense.  For instance we might have a slow
user, and there could be an exchange like the following
when you want a number from 0 to 100.  For illustration, user input is shown
in boldface:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter a score: (0 through 100) \sphinxstylestrong{233}
\item[] 233 is out of range!
\item[] Enter a score: (0 through 100) \sphinxstylestrong{101}
\item[] 101 is out of range!
\item[] Enter a score: (0 through 100) \sphinxstylestrong{\sphinxhyphen{}1}
\item[] \sphinxhyphen{}1 is out of range!
\item[] Enter a score: (0 through 100) \sphinxstylestrong{100}
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
and the value 100 would be accepted.

\sphinxAtStartPar
This is a well\sphinxhyphen{}defined idea.  A function makes sense.  Its heading
includes a prompt and low and high limits of the allowed range:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Prompt the user to obtain an int until the response is in the}
\PYG{c+c1}{/// range [lowLim, highLim].  Then return the int in range.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{PromptIntInRange}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example to generate
sequence above, the call would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PromptIntInRange}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a score: (0 through 100) \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}
\end{sphinxVerbatim}

\index{concrete example@\spxentry{concrete example}!splitting a loop@\spxentry{splitting a loop}}\index{loop@\spxentry{loop}!splitting concrete example@\spxentry{splitting concrete example}}\index{splitting a loop concrete example@\spxentry{splitting a loop concrete example}}\ignorespaces 
\sphinxAtStartPar
There is an issue with the common term “loop” in programming.
In normal English, a loop has no beginning and no end, like a circle.
C\# loops have a sequence of statements with a definite beginning and end.

\sphinxAtStartPar
Consider the sequence above in pseudocode.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input a number with prompt (233)
Print error message
Input a number with prompt (101)
Print error message
Input a number (\PYGZhy{}1)
Print error message
Input a number with prompt (100)
Return 100
\end{sphinxVerbatim}

\sphinxAtStartPar
We can break this into a repeating
pattern in two ways.  The most obvious is the following,
with three repetitions of a basic pattern,
with the last two line not in the same pattern
(so they would go after the loop).  :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input a number with prompt (233)
Print error message

Input a number with prompt (101)
Print error message

Input a number (\PYGZhy{}1)
Print error message

Input a number with prompt (100)
Return 100
\end{sphinxVerbatim}

\sphinxAtStartPar
Another choice, since
you can split a loop at any point, would be the following, with the first and
last lines not in the  pattern that repeats three times in the middle:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input a number with prompt (233)

Print error message
Input a number with prompt (101)

Print error message
Input a number (\PYGZhy{}1)

Print error message
Input a number with prompt (100)

Return 100
\end{sphinxVerbatim}

\sphinxAtStartPar
When you consider \sphinxcode{\sphinxupquote{while}} loops, there is a problem with the first version:
Before the first pass through the loop and at the end of the block of code
in the body of the loop, you must be \sphinxstyleemphasis{able} to run the test in the
while heading.  We will be testing the latest input from the user.

\sphinxAtStartPar
It is the second version that has us getting new input
\sphinxstyleemphasis{before the first} loop \sphinxstyleemphasis{and} at the \sphinxstyleemphasis{end of each} loop!

\sphinxAtStartPar
Now we can think more of the basic process to turn this into a C\# solution:
What variables do we need?   We will call the user’s response \sphinxcode{\sphinxupquote{number}}.

\sphinxAtStartPar
What is the test in the while loop heading?
The easiest thing to think of is that we are done when
we get something correct.  That, however, is a \sphinxstyleemphasis{termination} condition.
We need to reverse it to get the \sphinxstyleemphasis{continuation condition}, that the answer is
out of range.  There are two ways to be out of range:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lowLim}
\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{highLim}
\end{sphinxVerbatim}

\sphinxAtStartPar
How do we combine them?  Either one rules out a correct answer,
so \sphinxcode{\sphinxupquote{number}} is out of range
if too high OR too low.  Remember the C\# symbolism for “or”: \sphinxcode{\sphinxupquote{||}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Following the sequence in the concrete example we had above,
we can see how to put things
together.
We need to get input from the user \sphinxstyleemphasis{before} first beginning
the \sphinxcode{\sphinxupquote{while}} loop, so we immediately have something to test
in the \sphinxcode{\sphinxupquote{while}} heading’s condition.

\sphinxAtStartPar
Do not reinvent the wheel!
We can use our earlier general \sphinxcode{\sphinxupquote{PromptInt}} function.  It needs a prompt.
As a first version, we can use the parameter \sphinxcode{\sphinxupquote{prompt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is the initialization step before the loop.

\index{pitfall@\spxentry{pitfall}!repeat interactive input@\spxentry{repeat interactive input}}\index{interactive while loop@\spxentry{interactive while loop}!repeat interactive input@\spxentry{repeat interactive input}}\ignorespaces 
\sphinxAtStartPar
\sphinxstyleemphasis{If} we get into the body of the loop, it means there is an error,
and the concrete example indicates we print a warning message.
The concrete example \sphinxstyleemphasis{also} shows another step in the loop, asking
the user for input.  It is
easy to think
\begin{quote}

\sphinxAtStartPar
“I already have the code included to read a value from the user,
so there is nothing really to do.”
\end{quote}

\sphinxAtStartPar
WRONG!  The initialization code with
the input from the user is \sphinxstyleemphasis{before} the loop.  C\# execution approaches the
test in the \sphinxcode{\sphinxupquote{while}} headings from \sphinxstyleemphasis{two} places at different times:
the initialization \sphinxstyleemphasis{and} coming back
from the bottom of the loop.  To get a \sphinxstyleemphasis{new} value to test, we must
\sphinxstyleemphasis{repeat} getting input from the user at the \sphinxstyleemphasis{bottom of the loop body}.

\index{compiler error@\spxentry{compiler error}!declaration repeat@\spxentry{declaration repeat}}\index{declaration repeat error@\spxentry{declaration repeat error}}\index{type@\spxentry{type}!declaration repeat error@\spxentry{declaration repeat error}}\ignorespaces 
\sphinxAtStartPar
You might decide to be quick
and just copy the initialization line into the bottom of the
loop (and indent it):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Luckily you will get a compiler error in that situation, avoiding
more major troubleshooting:
The \sphinxstyleemphasis{complete} copy of the line copies the \sphinxstyleemphasis{declaration}
part as well as the assignment part, and the compiler sees the declaration of
\sphinxcode{\sphinxupquote{number}} already there
from the scope outside the while block, and complains.

\sphinxAtStartPar
Hence copy the line, \sphinxstyleemphasis{without} the \sphinxcode{\sphinxupquote{int}} declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
When the loop condition becomes false, and you get past the loop,
you have a correct value in \sphinxcode{\sphinxupquote{number}}.  You have done all the hard work.
Do not forget to return it at the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Prompt the user to obtain an int until the response is in the}
\PYG{c+c1}{/// range [lowLim, highLim].  Then return the int in range.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{PromptIntInRange}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} is out of range!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can try this full example, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/input\_in\_range1/input\_in\_range1.cs}{input\_in\_range1/input\_in\_range1.cs}.
Look at it and then try compiling and running.

\sphinxAtStartPar
Look at the Main code.
It is redundant \sphinxhyphen{} the limits are written both in the prompt and in the
parameters.  We can do better.  In general we endeavor to supply data only
once, and let the program use it in several places if it needs to.
Since the limits are given as parameters, anyway, we prefer
to have the program elaborate the prompt automatically.
If the limits are \sphinxhyphen{}10 and 10,
automatically add to the prompt something like (\sphinxhyphen{}10 through 10).

\sphinxAtStartPar
We could use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{} (\PYGZob{}0\PYGZcb{} through \PYGZob{}1\PYGZcb{}) \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
but we need the code twice, producing the same string each time.
If you recall the
{\hyperref[\detokenize{functions/funcreturn:string-format}]{\sphinxcrossref{\DUrole{std,std-ref}{string.Format function}}}}, then we can just create
the string once, and use it twice.
Here is a revised version, in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/input\_in\_range2/input\_in\_range2.cs}{input\_in\_range2/input\_in\_range2.cs},
without redundancy in the prompts in \sphinxcode{\sphinxupquote{Main}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{//testing routine}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PromptIntInRange}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a score: \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Your score is \PYGZob{}0\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Try another test.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PromptIntInRange}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a number: \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Your number is \PYGZob{}0\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{/// Prompt the user to obtain an int until the response is in the}
\PYG{c+c1}{/// range [lowLim, highLim].  Then return the int in range.}
\PYG{c+c1}{/// Use the specified prompt, adding a reminder of the allowed range.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{PromptIntInRange}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{longPrompt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} (\PYGZob{}1\PYGZcb{} through \PYGZob{}2\PYGZcb{}) \PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                                     }\PYG{n}{prompt}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} is out of range!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This time around we did the user input correctly, with the
request for new input \sphinxstyleemphasis{repeated} at the end of the loop.
That repetition \sphinxstyleemphasis{is} easy to forget.  Before we see what happens
when you forget, note:

\index{pitfall@\spxentry{pitfall}!infinite loop@\spxentry{infinite loop}}\index{infinite loop@\spxentry{infinite loop}}\ignorespaces 
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{while}} loop may be written so the continuation condition is
\sphinxstyleemphasis{always} true, and the loop \sphinxstyleemphasis{never} stops by itself.
This is an \sphinxstyleemphasis{infinite loop}.
In practice, in many operating environments, particularly
where you are getting input from the user,
you can abort the execution of a program in
an infinite loop by entering
\sphinxkeyboard{\sphinxupquote{Ctrl\sphinxhyphen{}C}}.
\end{sphinxadmonition}

\sphinxAtStartPar
In particular you get an infinite loop
if you fail to get new input from the user at the
end of the loop.  The condition uses the bad
original choice forever.  Here is the loop in the mistaken version,
from example  \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/input\_in\_range2\_bad/input\_in\_range2\_bad.cs}{input\_in\_range2\_bad/input\_in\_range2\_bad.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UIF}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lowLim}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{number}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{highLim}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// infinte loop!}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} is out of range!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// number = UIF.PromptInt(longPrompt); //OMITS repeated prompt!}
\PYG{p}{\PYGZcb{}}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{number}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can run the program.  Remember \sphinxkeyboard{\sphinxupquote{Ctrl\sphinxhyphen{}C}} !
There are two tests in \sphinxcode{\sphinxupquote{Main}}.
If you give a legal answer immediately in the first test,
it works fine (never getting into the loop body).  If you
give a bad input in the second test, you see that you can never fix it!
Remember \sphinxkeyboard{\sphinxupquote{Ctrl\sphinxhyphen{}C}} !

\sphinxAtStartPar
A more extreme abort is to close the entire console/terminal window
running the program.

\index{exercise@\spxentry{exercise}!Agree@\spxentry{Agree}}\index{Agree exercise@\spxentry{Agree exercise}}\ignorespaces 

\subsection{Agree Function Exercise}
\label{\detokenize{while/whileinteractive:agree-function-exercise}}\label{\detokenize{while/whileinteractive:index-5}}\label{\detokenize{while/whileinteractive:id2}}
\sphinxAtStartPar
Save example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_agree\_stub/test\_agree.cs}{test\_agree\_stub/test\_agree.cs}
in a project of your own.

\sphinxAtStartPar
Yes\sphinxhyphen{}no (true/false) questions are common.
How might you write an input utility function \sphinxcode{\sphinxupquote{Agree}}?
You can speed things
up by considering only the first letter of responses.
Assume that it is important that the user makes a clear response:
Then you should
consider three categories of answer:  ones accepted as true,
ones accepted as false, and ambiguous ones.
You need to allow for
the possibility that the user keeps
giving ambiguous answers for some time….


\subsection{Interactive Sum Exercise}
\label{\detokenize{while/whileinteractive:interactive-sum-exercise}}\label{\detokenize{while/whileinteractive:interactive-sumex}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{sum\_all.cs}} that prompts the user to enter
numbers, one per line, ending with a line containing 0, and keep a
running sum of the numbers. Only print out the sum after all the
numbers are entered (at least in your \sphinxstyleemphasis{final} version).

\index{exercise@\spxentry{exercise}!InputWhole@\spxentry{InputWhole}}\index{InputWhole exercise@\spxentry{InputWhole exercise}}\ignorespaces 

\subsection{Safe Whole Number Input Exercise}
\label{\detokenize{while/whileinteractive:safe-whole-number-input-exercise}}\label{\detokenize{while/whileinteractive:safe-whole-number-input}}\label{\detokenize{while/whileinteractive:index-6}}
\sphinxAtStartPar
Save example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_input\_whole\_stub/test\_input\_whole.cs}{test\_input\_whole\_stub/test\_input\_whole.cs} as
a project of your own.  The code should test
a function \sphinxcode{\sphinxupquote{PromptWhole}}, as described below.

\sphinxAtStartPar
There is an issue with reading in numbers with the PromptInt function.
If you make a typo and enter something that cannot be converted from a
string to the right kind of number, a naive program will bomb.
This is avoidable if you test the string and repeat the input
if the string is illegal.
Places where more complicated tests for illegality are needed are
considered in {\hyperref[\detokenize{while/stringmethods2:safe-input-number}]{\sphinxcrossref{\DUrole{std,std-ref}{Safer PromptInt and PromptDouble Exercise}}}} and
{\hyperref[\detokenize{while/stringmethods2:safest-input-int}]{\sphinxcrossref{\DUrole{std,std-ref}{Safest PromptInt Exercise}}}}.  For now we just consider
reading in whole numbers (integers greater than or equal to 0).
Note that such
a number is written as just a sequence of digits.
Follow the interactive model of PromptIntInRange, looping until
the user enters something that is legal: in this case, all digits.

\sphinxAtStartPar
The stub code already includes the earlier function \sphinxcode{\sphinxupquote{IsDigits}}.

\sphinxstepscope

\index{short\sphinxhyphen{}circuit \&\& and \textbar{}\textbar{}@\spxentry{short\sphinxhyphen{}circuit \&\& and \textbar{}\textbar{}}}\index{\textbar{}\textbar{}@\spxentry{\textbar{}\textbar{}}!short\sphinxhyphen{}circuit@\spxentry{short\sphinxhyphen{}circuit}}\index{\&\&@\spxentry{\&\&}!short\sphinxhyphen{}circuit@\spxentry{short\sphinxhyphen{}circuit}}\ignorespaces 

\section{Short\sphinxhyphen{}Circuiting \&\& and ||}
\label{\detokenize{while/condition-short-circuit:short-circuiting-and}}\label{\detokenize{while/condition-short-circuit:short-circuit}}\label{\detokenize{while/condition-short-circuit:index-0}}\label{\detokenize{while/condition-short-circuit::doc}}
\sphinxAtStartPar
Follow along with the following silly, but illustrative csharp sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{true}
\end{sphinxVerbatim}

\sphinxAtStartPar
The compound condition includes \sphinxcode{\sphinxupquote{x != 0}},
so what happens if we change x to 0 and
try the condition again.  Will you get \sphinxcode{\sphinxupquote{false}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{System}\PYG{p}{.}\PYG{n}{DivideByZeroException}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{Division}\PYG{+w}{ }\PYG{k}{by}\PYG{+w}{ }\PYG{n}{zero}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
No, one of the parts involves dividing by zero, and you see the result.
What if we swap the two conditions to get the \sphinxstyleemphasis{logically equivalent}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{;}
\PYG{k}{false}
\end{sphinxVerbatim}

\sphinxAtStartPar
Something is going on here besides pure mathematical logic.
Remember the final version in {\hyperref[\detokenize{while/while-with-sequence:isdigits}]{\sphinxcrossref{\DUrole{std,std-ref}{IsDigits}}}}.  We did not
need to continue processing when we knew the final answer
already.  The \sphinxcode{\sphinxupquote{\&\&}} and \sphinxcode{\sphinxupquote{||}} operators work the same way,
evaluating from left to right.  If \sphinxcode{\sphinxupquote{x != 0}} is \sphinxcode{\sphinxupquote{false}},
then \sphinxcode{\sphinxupquote{x != 0 \&\& y/x \textgreater{} z}} starts off being evaluated like
\sphinxcode{\sphinxupquote{false \&\& ??}}.  We do no need the second part evaluated to
know the overall result is \sphinxcode{\sphinxupquote{false}}, so C\#
\sphinxstyleemphasis{does not evaluate further}.  This behavior has
acquired the jargon \sphinxstyleemphasis{short\sphinxhyphen{}circuiting}.  Many computer languages share
this feature.

\sphinxAtStartPar
It also applies to \sphinxcode{\sphinxupquote{||}}.  In what situation do you know
what the final result is after evaluating
the first condition?  In this case you know:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{true}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{o}{??}
\end{sphinxVerbatim}

\sphinxAtStartPar
evaluates to true.  Continuing with the same csharp sequence above
(where x is 0, y is 5, and z is 1):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{;}
\PYG{k}{true}
\end{sphinxVerbatim}

\sphinxAtStartPar
The division by 0 in the second condition \sphinxstyleemphasis{never happens}.
It is short\sphinxhyphen{}circuited.

\sphinxAtStartPar
For completeness, try the other order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{System}\PYG{p}{.}\PYG{n}{DivideByZeroException}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{Division}\PYG{+w}{ }\PYG{k}{by}\PYG{+w}{ }\PYG{n}{zero}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This idea is useful in the \sphinxcode{\sphinxupquote{Agree}} function, where you
want to deal with the first character in the user’s answer.

\sphinxAtStartPar
In situations where you want to
test conditionThatWillBombWithBadData, you want to avoid
causing an Exception.
When there is good data, you want the result to actually
come from conditionThatWillBombWithBadData.  There are two cases,
however, depending on what result
you want if the data for this condition \sphinxstyleemphasis{is bad}, so you cannot evaluate it:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If you want the result to be \sphinxcode{\sphinxupquote{false}} with bad data for the dangerous
condition, use
\begin{quote}

\sphinxAtStartPar
falseConditionIfDataBad \sphinxcode{\sphinxupquote{\&\&}} conditionThatWillBombWithBadData
\end{quote}

\item {} 
\sphinxAtStartPar
If you want the result to be \sphinxcode{\sphinxupquote{true}} with bad data for
the dangerous condition, use
\begin{quote}

\sphinxAtStartPar
trueConditionIfDataBad \sphinxcode{\sphinxupquote{||}} conditionThatWillBombWithBadData
\end{quote}

\end{itemize}

\sphinxstepscope


\section{While Examples}
\label{\detokenize{while/whileexamples:while-examples}}\label{\detokenize{while/whileexamples::doc}}
\index{bisection method@\spxentry{bisection method}}\ignorespaces 

\subsection{Bisection Method}
\label{\detokenize{while/whileexamples:bisection-method}}\label{\detokenize{while/whileexamples:index-0}}\label{\detokenize{while/whileexamples:id1}}
\sphinxAtStartPar
For a very different example we look to scientific computing.  In math
class you likely learned various ways to find roots of functions f(x) exactly.
In practice those methods almost never work beyond low order polynomials.
Hence the best we can do usually is to approximate solutions numerically.
One broadly useful approach is the \sphinxstyleemphasis{bisection method}.  You just need a
continuous function (with an unbroken graph),
and you need to first find two places,
a and b, where f(a) and f(b) have opposite signs. If f is continuous and goes
between positive and negative values, then it must cross 0 somewhere in between,
and so there must be a real solution.  The question is how to get close
to a crossing point efficiently.

\sphinxAtStartPar
As an example we show \(f(x)=x^2 - 2\), in the range from x = 0 to x = 2.
As a first example we choose a simple function where the root can be figured symbolically,
in this case the square root of 2.  The figure below shows the graph,
with extra horizontal and vertical lines that will will be explained.

\noindent\sphinxincludegraphics[width=200bp]{{bisection}.png}

\sphinxAtStartPar
In the figure a= 0, f(0) \textless{} 0, b = 2, f(2) \textgreater{} 0.

\sphinxAtStartPar
The basic idea is to bisect the interval between a and b, finding the midpoint,
c = (a+b)/2. If f(c) is 0, you are done.
Otherwise f(c) has a sign which must be opposite \sphinxstyleemphasis{one} of f(a) and f(b).

\sphinxAtStartPar
In the figure the initial interval has the same x coordinates as for the top gray line.
Its midpoint is at 1, the x coordinate of the red vertical segment coming down from
the top gray line in the figure.  Note f(1) \textless{} 0, the opposite sign of f(2),
so we next consider the half of the original interval from the midpoint 1 to 2,
with the next gray line marking this interval.
The function still must cross 0 in the smaller interval because of the opposite
signs for f on the endpoints.  In
the iterative procedure, you  continue this process, halving the length of
the interval,
shifting one endpoint or the other to be the middle
of the most recent interval, so for each interval, the signs of f on
the two ends are opposite.
Repeating this procedure, you can home in on as small an interval around a
crossing point (root) as you like.
The figure show this process for the first 5 steps,
halving the interval length each time.  You need to look at the output of the code to
follow the results for even smaller intervals.

\sphinxAtStartPar
This approach always works, as long as the signs of f
at the initial endpoints are distinct.  Our \sphinxcode{\sphinxupquote{Bisection}} functions check,
and if this initial requirement
is violated, the function returns the special double code value,
\sphinxcode{\sphinxupquote{double.NaN}}, meaning \sphinxstyleemphasis{not a number}.

\sphinxAtStartPar
There are other approaches to finding roots that may be faster when they work,
but many of these methods can also have some chance of completely failing,
so root finding algorithms generally have two
extra parameters:  a maximum number of iterations and a tolerance that
indicates how close to a root is close enough.

\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{Bisection}} function we use \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}
as the endpoints of an interval and \sphinxcode{\sphinxupquote{c}} as the
midpoint.  In each iteration the value of \sphinxcode{\sphinxupquote{a}} or \sphinxcode{\sphinxupquote{b}} is reset to be the
previous midpoint value \sphinxcode{\sphinxupquote{c}}.
Of course a production version would not print out all the intermediate data,
as the interval shrinks, but we do for illustration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{Bisection}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}
\PYG{+w}{                               }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{tolerance}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{iterations}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{c+c1}{// check the preconditions for the method to work}
\PYG{+w}{   }\PYG{c+c1}{// a must be less than b so we can do the interval search}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{NaN}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}a \PYGZgt{}= b ok\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}

\PYG{+w}{   }\PYG{c+c1}{// The function must cross the x\PYGZhy{}axis between the endpoints,}
\PYG{+w}{   }\PYG{c+c1}{//   meaning its sign changes.}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Test 1 passed\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Test 2 passed\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{ok}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{NaN}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{iterations}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}a = \PYGZob{}0\PYGZcb{}  b=\PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{tolerance}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{else}
\PYG{+w}{         }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{n}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{NaN}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since the bisection method always homes in on a real root rapidly,
an alternate version specifically for the bisection method
finds the \sphinxstyleemphasis{best} approximation possible with \sphinxcode{\sphinxupquote{double}}
arithmetic.  While you can always halve an interval mathematically, you
eventually run out of distinct \sphinxcode{\sphinxupquote{double}} values! We can stop when
the midpoint (calculated with limited \sphinxcode{\sphinxupquote{double}} precision)
is \sphinxstyleemphasis{exactly} the same as \sphinxcode{\sphinxupquote{a}} or \sphinxcode{\sphinxupquote{b}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// This bisection method returns the best double approximation}
\PYG{c+c1}{/// to a root of f.  Returns double.NaN if the f(a)*f(b) \PYGZgt{} 0.}
\PYG{c+c1}{/// Does not require a \PYGZlt{} b.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{Bisection}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//or f(a)*f(b)\PYGZgt{}0}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{NaN}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// If no f(c) is exactly 0, iterate until the smallest possible}
\PYG{+w}{   }\PYG{c+c1}{// double interval, when there is no distinct double midpoint.}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}a = \PYGZob{}0\PYGZcb{}  b= \PYGZob{}1\PYGZcb{}, diff = \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sign}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{else}
\PYG{+w}{         }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
C\# remembers \sphinxcode{\sphinxupquote{double}} values to more decimal places than it will actually
display, so the second illustration also shows the difference between \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}},
indicating the double values are still not really equal even after their
displays match.

\sphinxAtStartPar
You can try this full example,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/bisection\_method1/bisection\_method1.cs}{bisection\_method1/bisection\_method1.cs}.
Note the special function checking for \sphinxcode{\sphinxupquote{double.NaN}} in \sphinxcode{\sphinxupquote{Main}},
because \sphinxcode{\sphinxupquote{double.NaN}} is not equal to itself!

\sphinxAtStartPar
The current versions have a major limitation:  They just work with the one
canned version of the function \sphinxcode{\sphinxupquote{f}} in the class.
You need to edit
the source code to use the same process with a different function!
There are several ways around this using more advanced C\# features.
After the section {\hyperref[\detokenize{interfaces/interfaces:interface}]{\sphinxcrossref{\DUrole{std,std-ref}{Interfaces}}}}, a more flexible version
should make sense, \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/bisection\_method/bisection\_method.cs}{bisection\_method/bisection\_method.cs},
explored further in {\hyperref[\detokenize{interfaces/csproj-revisited:bisection-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Bisection With Function Interface Exercise}}}}.  The more
advanced version illustrates with the function in the initial version and
several others, all using the same bisection function.

\index{exercise@\spxentry{exercise}!savings@\spxentry{savings}}\ignorespaces 

\subsection{Savings Exercise}
\label{\detokenize{while/whileexamples:savings-exercise}}\label{\detokenize{while/whileexamples:index-1}}\label{\detokenize{while/whileexamples:id2}}
\sphinxAtStartPar
The idea here is to see how many years it will take a bank account to grow
to at least a given value, assuming a fixed annual interest.
Write a program \sphinxcode{\sphinxupquote{savings.cs}}.
Prompts the user for three numbers: an initial balance, the annual percentage
for interest as a decimal. like .04 for 4\%, and the final balance desired.
Print the initial balance, and the balance each year until
the desired amount is reached. Round displayed amounts
to two decimal places, as usual.

\sphinxAtStartPar
The math:  The amount next year is the amount now times
(1 + interest fraction),
so if I have \$500 now and the interest rate is .04,
I have \$500*(1.04) = \$520 after one year, and after two years I have,
\$520*(1.04) = \$540.80.
If I enter into the program a \$500 starting balance, .04 interest rate and
a target of \$550, the program prints:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{500.00}
\PYG{l+m}{520.00}
\PYG{l+m}{540.80}
\PYG{l+m}{563.42}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!strange sequence@\spxentry{strange sequence}}\ignorespaces 

\subsection{Strange Sequence Exercise}
\label{\detokenize{while/whileexamples:strange-sequence-exercise}}\label{\detokenize{while/whileexamples:strange-seq-ex}}\label{\detokenize{while/whileexamples:index-2}}
\sphinxAtStartPar
Save the example program \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/strange\_seq\_stub/strange\_seq.cs}{strange\_seq\_stub/strange\_seq.cs}
in a project of your own.

\sphinxAtStartPar
There are three functions to complete.  Do one at a time and test.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Jump}}: First complete the definitions of function \sphinxcode{\sphinxupquote{Jump}}.
For any integer \sphinxcode{\sphinxupquote{n}}, \sphinxcode{\sphinxupquote{Jump(n)}} is \sphinxcode{\sphinxupquote{n/2}} if \sphinxcode{\sphinxupquote{n}} is even,
and \sphinxcode{\sphinxupquote{3*n+1}} if \sphinxcode{\sphinxupquote{n}} is odd.
In the \sphinxcode{\sphinxupquote{Jump}} function definition use an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}}
statement.  Hint %
\begin{footnote}[1]\sphinxAtStartFootnote
If you divide an even number by 2, what is the remainder?  Use this idea
in your \sphinxcode{\sphinxupquote{if}} condition.
%
\end{footnote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PrintStrangeSequence}}:
You can start with one number, say n = 3, and \sphinxstyleemphasis{keep} applying the
\sphinxcode{\sphinxupquote{Jump}} function to the \sphinxstyleemphasis{last} number given,
and see how the numbers jump around!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{o}{*}\PYG{l+m}{3}\PYG{o}{+}\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{10}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{o}{*}\PYG{l+m}{5}\PYG{o}{+}\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{16}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{16}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{16}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{8}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{  }\PYG{o}{=}\PYG{+w}{   }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{   }\PYG{l+m}{4}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{o}{/}\PYG{l+m}{2}\PYG{+w}{  }\PYG{o}{=}\PYG{+w}{   }\PYG{l+m}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
This process of repeatedly applying the same function to the most recent result
is called function \sphinxstyleemphasis{iteration}.  In this case you see that iterating the
\sphinxcode{\sphinxupquote{Jump}} function, starting from n=3, eventually reaches the value 1.

\sphinxAtStartPar
It is an \sphinxstyleemphasis{open research question} whether iterating the Jump function
from an integer \sphinxcode{\sphinxupquote{n}} will eventually reach 1,
for \sphinxstyleemphasis{every} starting integer \sphinxcode{\sphinxupquote{n}} greater than 1.
Researchers have only found examples of \sphinxcode{\sphinxupquote{n}} where it is true.
Still, no general argument has been made to apply to the
\sphinxstyleemphasis{infinite} number of possible starting integers.

\sphinxAtStartPar
In the PrintStrangeSequence you iterate the \sphinxcode{\sphinxupquote{Jump}} function
starting from parameter value \sphinxcode{\sphinxupquote{n}}, as long as the current number is not 1.
If you start with 1, stop immediately.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CountStrangeSequence}}:  Iterate the \sphinxcode{\sphinxupquote{Jump}} function as in
\sphinxcode{\sphinxupquote{PrintStrangeSequence}}.  Instead of printing each number in the sequence,
just count them, and return the count.

\index{exercise@\spxentry{exercise}!roundoff II@\spxentry{roundoff II}}\ignorespaces 

\subsection{Roundoff Exercise II}
\label{\detokenize{while/whileexamples:roundoff-exercise-ii}}\label{\detokenize{while/whileexamples:roundoff2}}\label{\detokenize{while/whileexamples:index-3}}
\sphinxAtStartPar
Write a program to complete and test the function with this heading
and documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the largest possible number y, so in C\PYGZsh{}: x+y = x}
\PYG{c+c1}{/// If x is Infinity return Infinity.}
\PYG{c+c1}{/// If x is \PYGZhy{}Infinity, return double.MaxValue.}
\PYG{c+c1}{/// Assume x is not NaN (which is equal to nothing).}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{Epsilon}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Hint:  The non\sphinxhyphen{}exceptional case can have some similarity
to the bisection in the best root approximation example:
start with two endpoints, \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}, where \sphinxcode{\sphinxupquote{x+a = x}} and
\sphinxcode{\sphinxupquote{x+b \textgreater{} x}}, and reduce the interval size by half….

\sphinxstepscope

\index{string@\spxentry{string}!method@\spxentry{method}}\ignorespaces 

\section{More String Methods}
\label{\detokenize{while/stringmethods2:more-string-methods}}\label{\detokenize{while/stringmethods2:index-0}}\label{\detokenize{while/stringmethods2:id1}}\label{\detokenize{while/stringmethods2::doc}}
\sphinxAtStartPar
Before we do more elaborate things with strings, some more string methods
will be helpful.  Be sure you are familiar with the earlier discussion of
strings in
{\hyperref[\detokenize{basicstringops/basicstringops:basic-string-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Basic String Operations}}}}.

\sphinxAtStartPar
Play with the new string methods in csharp!

\sphinxAtStartPar
This variation of \sphinxcode{\sphinxupquote{IndexOf}} has a second parameter:

\index{string@\spxentry{string}!IndexOf@\spxentry{IndexOf}}\index{IndexOf string method@\spxentry{IndexOf string method}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{int IndexOf(string target, int start)}}}
\sphinxAtStartPar
Returns the index of the beginning of the first occurrence of the string
\sphinxcode{\sphinxupquote{target}}
in \sphinxstylestrong{this} string object, starting at index \sphinxcode{\sphinxupquote{start}} or after.
Returns \sphinxhyphen{}1 if \sphinxcode{\sphinxupquote{target}} is not found. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{state}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Mississippi\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}01234567890\PYGZbs{}n\PYGZdq{}}\PYG{o}{+}\PYG{n}{state}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{// to see indices}
\PYG{l+m}{01234567890}
\PYG{n}{Mississippi}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// same as state.IndexOf(\PYGZdq{}is\PYGZdq{});}
\PYG{l+m}{1}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{4}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}i\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{7}
\end{sphinxVerbatim}

\end{description}

\index{string@\spxentry{string}!Trim@\spxentry{Trim}}\index{Trim string method@\spxentry{Trim string method}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{string Trim()}}}
\sphinxAtStartPar
Returns a string formed from \sphinxstylestrong{this} string object, but
with leading and trailing whitespace removed. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} string s = \PYGZdq{}\PYGZbs{}n  123    \PYGZdq{};
csharp\PYGZgt{} \PYGZdq{}\PYGZsh{}\PYGZdq{} + s + \PYGZdq{}\PYGZsh{}\PYGZdq{};
\PYGZsh{}
  123   \PYGZsh{}
csharp\PYGZgt{} \PYGZdq{}\PYGZsh{}\PYGZdq{} + s.Trim() + \PYGZdq{}\PYGZsh{}\PYGZdq{};
\PYGZsh{}123\PYGZsh{}
\end{sphinxVerbatim}

\end{description}

\index{string@\spxentry{string}!Replace@\spxentry{Replace}}\index{Replace string method@\spxentry{Replace string method}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{string Replace(string target, string replacement)}}}
\sphinxAtStartPar
Returns a string formed from \sphinxstylestrong{this} string by replacing
all occurrences of the substring \sphinxcode{\sphinxupquote{target}} by \sphinxcode{\sphinxupquote{replacement}}.
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}This is it!\PYGZdq{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}This/is/it!\PYGZdq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}at\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}That at it!\PYGZdq{}}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}oooooh\PYGZdq{}}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}oo\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}ah\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{\PYGZdq{}ahahoh\PYGZdq{}}
\end{sphinxVerbatim}

\end{description}

\index{string@\spxentry{string}!StartsWith@\spxentry{StartsWith}}\index{StartsWith string method@\spxentry{StartsWith string method}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{bool StartsWith(string prefix)}}}
\sphinxAtStartPar
Returns \sphinxcode{\sphinxupquote{true}} if  \sphinxstylestrong{this} string object starts
with string \sphinxcode{\sphinxupquote{prefix}}, and \sphinxcode{\sphinxupquote{false}} otherwise.
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZhy{}123\PYGZdq{}}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}downstairs\PYGZdq{}}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}down\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}1 \PYGZhy{} 2 \PYGZhy{} 3\PYGZdq{}}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\end{sphinxVerbatim}

\end{description}

\index{string@\spxentry{string}!EndsWith@\spxentry{EndsWith}}\index{EndsWith string method@\spxentry{EndsWith string method}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{bool EndsWith(string suffix)}}}
\sphinxAtStartPar
Returns \sphinxcode{\sphinxupquote{true}} if  \sphinxstylestrong{this} string object ends
with string \sphinxcode{\sphinxupquote{suffix}}, and \sphinxcode{\sphinxupquote{false}} otherwise.
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZhy{}123\PYGZdq{}}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}downstairs\PYGZdq{}}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}airs\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}downstairs\PYGZdq{}}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}air\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\end{sphinxVerbatim}

\end{description}

\index{exercise@\spxentry{exercise}!CountRep@\spxentry{CountRep}}\index{CountRep exercise@\spxentry{CountRep exercise}}\ignorespaces 

\subsection{Count Repetitions in a String Exercise}
\label{\detokenize{while/stringmethods2:count-repetitions-in-a-string-exercise}}\label{\detokenize{while/stringmethods2:countrep}}\label{\detokenize{while/stringmethods2:index-6}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{test\_count\_rep.cs}}, with a Main testing method,
that tests a function with the following heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Return the number of separate repetitions of target in s.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CountRep}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example here is what \sphinxcode{\sphinxupquote{CountRep( "Mississippi", target)}}
would return with various values for \sphinxcode{\sphinxupquote{target}}:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{"i"}}: 4
\item[] \sphinxcode{\sphinxupquote{"is"}}: 2
\item[] \sphinxcode{\sphinxupquote{"sss"}}: 0
\end{DUlineblock}

\sphinxAtStartPar
Assume each repetition is completely separate, so
\sphinxcode{\sphinxupquote{CountRep("Wheee!", "ee")}} returns 1.  The last
two e’s do not count, since the middle e is already
used in the match of the first two e’s.

\index{exercise@\spxentry{exercise}!safe PromptInt and PromptDouble@\spxentry{safe PromptInt and PromptDouble}}\index{safe PromptInt and PromptDouble exercises@\spxentry{safe PromptInt and PromptDouble exercises}}\ignorespaces 

\subsection{Safer PromptInt and PromptDouble Exercise}
\label{\detokenize{while/stringmethods2:safer-promptint-and-promptdouble-exercise}}\label{\detokenize{while/stringmethods2:safe-input-number}}\label{\detokenize{while/stringmethods2:index-7}}
\sphinxAtStartPar
Save the example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/safe\_number\_input\_stub/safe\_number\_input.cs}{safe\_number\_input\_stub/safe\_number\_input.cs}
in a project of your own.

\sphinxAtStartPar
The idea is to write safe versions of the utility functions
PromptInt and PromptDouble (which can then be used in further
places like PromptIntInRange).

\sphinxAtStartPar
Be sure you are familiar with {\hyperref[\detokenize{while/whileinteractive:safe-whole-number-input}]{\sphinxcrossref{\DUrole{std,std-ref}{Safe Whole Number Input Exercise}}}},
and the development of its \sphinxcode{\sphinxupquote{InputWhole}} function.

\sphinxAtStartPar
A legal whole number string consists entirely of digits.  We have
already written example \sphinxcode{\sphinxupquote{IsDigits}} to identify a string for a
whole number.

\sphinxAtStartPar
The  improvements to PromptInt and PromptDouble are
very similar and straightforward \sphinxstyleemphasis{if} you have developed the two main
Boolean support functions,
\sphinxcode{\sphinxupquote{IsIntString}} and \sphinxcode{\sphinxupquote{IsDecimalString}} respectively.

\sphinxAtStartPar
A complicating issue with integer and decimal strings
is that they may include parts other than
digits.  An integer may start with a minus sign.  A
decimal number can also contain a decimal point in an appropriate
place.  The suggestion is to confirm that these other characters appear in
legal places, remove them, and see that what is left is digits.
The recently introduced string methods should help….

\sphinxAtStartPar
Using the ideas above,
develop the functions in order and test after each one:
write \sphinxcode{\sphinxupquote{IsIntString}}, revise \sphinxcode{\sphinxupquote{PromptInt}},
write \sphinxcode{\sphinxupquote{IsDecimalString}}, and revise \sphinxcode{\sphinxupquote{PromptDouble}}.

\sphinxAtStartPar
Be sure to test carefully.  Not only confirm that all
appropriate strings return \sphinxcode{\sphinxupquote{true}}:
Also be sure to test that you return \sphinxcode{\sphinxupquote{false"}}
for \sphinxstyleemphasis{all} sorts of bad strings.

\sphinxAtStartPar
There is still one issue with \sphinxcode{\sphinxupquote{IsIntString}} not considered yet:  see
the next exercise for the final improvement.

\sphinxAtStartPar
Hopefully
you learned something from writing the earlier PromptWhole.
Probably it is not worth keeping in our utility library
any longer, since we have
the more general and safe PromptInt, and we can
restrict to many ranges with PromptIntInRange.

\sphinxAtStartPar
We will arrange for these functions to be a library class later.
For now just develop and test them in this one class.


\subsection{Safest PromptInt Exercise}
\label{\detokenize{while/stringmethods2:safest-promptint-exercise}}\label{\detokenize{while/stringmethods2:safest-input-int}}
\sphinxAtStartPar
With the suggestions so far the in the previous exercise,
\sphinxcode{\sphinxupquote{IsIntString}} will catch a strange stray character, and be
sure that the string for an \sphinxstyleemphasis{integer} is entered, but an \sphinxcode{\sphinxupquote{int}} is
not an arbitrary integer:  it has limited range, between
\sphinxcode{\sphinxupquote{int.MinValue}} =  \sphinxhyphen{}2147483648 and \sphinxcode{\sphinxupquote{int.MaxValue}} = 2147483647.

\sphinxAtStartPar
Revise the \sphinxcode{\sphinxupquote{IsIntString}} function of the previous
exercise so that it checks that the result is in range, too, allowing
the PromptInt function to be totally reliable.

\sphinxAtStartPar
There is a problem:  your current version of IsIntString is likely
to accept a string like \sphinxcode{\sphinxupquote{"9876543210"}}, and you cannot convert it to an
\sphinxcode{\sphinxupquote{int}} to do the comparison to see that it is in fact
too large for an \sphinxcode{\sphinxupquote{int}}!  Catch 22?

\sphinxAtStartPar
There is an alternate approach involving comparing strings, not numbers.

\sphinxAtStartPar
There is a string instance method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CompareTo}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It does roughly lexicographical string comparisons, so

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
is true when s “comes before” t or is equal to t.  This works with
alphabetizing letter strings:  “at” comes before “ate” which comes before
“attention” which comes before “eat”.  It also works with digit strings
\sphinxstyleemphasis{of the same length}
to give the same relationship as the corresponding numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}123456890\PYGZdq{}}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}2147483647\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
is true, and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}9876543210\PYGZdq{}}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}2147483647\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
is false.

\sphinxAtStartPar
This idea can be leveraged into a completely reliable version of IsIntString.
(With this approach you could also create an IsLongString very similarly,
but we skip it since it teaches you nothing new.)

\sphinxAtStartPar
The idea of a \sphinxcode{\sphinxupquote{CompareTo}} method is much more general
and is used much later in {\hyperref[\detokenize{interfaces/fractions-revisited:rationals-revisited}]{\sphinxcrossref{\DUrole{std,std-ref}{Rationals Revisited}}}}.

\sphinxstepscope

\index{library@\spxentry{library}!UI@\spxentry{UI}}\index{UI library class@\spxentry{UI library class}}\ignorespaces 

\section{User Input: UI}
\label{\detokenize{while/userinput:user-input-ui}}\label{\detokenize{while/userinput:ui}}\label{\detokenize{while/userinput:index-0}}\label{\detokenize{while/userinput::doc}}
\sphinxAtStartPar
With the exercises in the last section, we have all we need for a much improved
User Input library class.  This will be the class \sphinxcode{\sphinxupquote{UI}}.
We have the original \sphinxcode{\sphinxupquote{PromptLine}}, improved \sphinxcode{\sphinxupquote{PromptInt}},
\sphinxcode{\sphinxupquote{PromptDouble}}, \sphinxcode{\sphinxupquote{PromptIntInRange}}, \sphinxcode{\sphinxupquote{PromptDoubleInRange}}, \sphinxcode{\sphinxupquote{Agree}},
and assorted supporting functions.
The only changes to individual methods were to make
sure that the static methods are public.

\sphinxAtStartPar
Henceforth we will be using \sphinxcode{\sphinxupquote{UI}} in place of \sphinxcode{\sphinxupquote{UIF}}.  In fact all the places \sphinxcode{\sphinxupquote{UIF}}
was used before could be replaced by \sphinxcode{\sphinxupquote{UI}}:
It includes all the functionality of \sphinxcode{\sphinxupquote{UIF}}.

\sphinxAtStartPar
You can look at the code all together in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/ui/ui.cs}{ui/ui.cs}.

\sphinxAtStartPar
There are even fancier ways of arranging for legal numeric input.
We have only been reading whole lines, but it is possible to read
individual characters with \sphinxcode{\sphinxupquote{Console.ReadKey}},
without a newline being entered yet.  A much more extensive advanced
subject is the special regular expression language for
describing arbitrary patterns in strings using the \sphinxcode{\sphinxupquote{Regex}} class.
Though we will not discuss the details, another slick replacement for UI
using these features is in the example class \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/uifnt/UIFNT.cs}{uifnt/UIFNT.cs}.

\sphinxstepscope

\index{algorithms@\spxentry{algorithms}!greatest common divisor@\spxentry{greatest common divisor}}\index{Euclid\textquotesingle{}s algorithm@\spxentry{Euclid\textquotesingle{}s algorithm}}\index{greatest common divisor algorithm@\spxentry{greatest common divisor algorithm}}\ignorespaces 

\section{Greatest Common Divisor}
\label{\detokenize{while/gcdexamples:greatest-common-divisor}}\label{\detokenize{while/gcdexamples:gcd}}\label{\detokenize{while/gcdexamples:index-0}}\label{\detokenize{while/gcdexamples::doc}}

\subsection{Euclid’s Algorithm}
\label{\detokenize{while/gcdexamples:euclid-s-algorithm}}
\sphinxAtStartPar
The greatest common divisor of two non\sphinxhyphen{}zero integers is a great
example to illustrate the power of loops. Everyone learns about the
\sphinxstyleemphasis{concept} of a greatest common divisor when faced with a fraction that
is not in \sphinxstyleemphasis{reduced} form.

\sphinxAtStartPar
Consider the fraction \(\frac{2}{4}\), which is the same as
\(\frac{1}{2}\). The fraction \(\frac{2}{4}\)
can be reduced, because the
numerator and denominator both have greatest common factor of 2. That
is, \(\frac{2}{4} = \frac{1 \cdot 2}{2 \cdot 2}\). So the factor of 2 can
be canceled from both the numerator and the denominator.

\sphinxAtStartPar
Euclid (the mathematician from classic times and author of \sphinxstyleemphasis{Elements})
is credited with having come up with a clever algorithm for how to
compute the greatest common divisor efficiently. It is written as
follows, where \(a \bmod b\) means \sphinxcode{\sphinxupquote{a \% b}} in C\#.
\begin{align*}\!\begin{aligned}
gcd(a, b) = gcd(b, a \bmod b)\\
gcd(a, 0) = a\\
\end{aligned}\end{align*}
\sphinxAtStartPar
It is common in mathematics to list functions as one or more
\sphinxstyleemphasis{cases}. The way you read this is as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In general, the greatest common divisor of \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} is the
same as computing the greatest common divisor of \sphinxcode{\sphinxupquote{b}} and the
remainder of \sphinxcode{\sphinxupquote{a}} divided by \sphinxcode{\sphinxupquote{b}}.

\item {} 
\sphinxAtStartPar
In the case where \sphinxcode{\sphinxupquote{b}} is zero, the result is \sphinxcode{\sphinxupquote{a}}. This makes
sense because \sphinxcode{\sphinxupquote{a}} divides itself and 0.

\end{itemize}

\sphinxAtStartPar
To gain some appreciation of how the definition \sphinxstyleemphasis{always} allows you to
compute the greatest common divisor, it is worthwhile to try it out
for a couple of numbers where you \sphinxstyleemphasis{know} the greatest common
divisor. For example, we already know that the greatest common divisor
of 10 and 15 is 5. Let’s use Euclid’s method to verify this:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(gcd(10, 15) = gcd(15, 10 \bmod 15) = gcd(15, 10)\)

\item {} 
\sphinxAtStartPar
\(gcd(15, 10) = gcd(10, 15 \bmod 10) = gcd(10, 5)\)

\item {} 
\sphinxAtStartPar
\(gcd(10, 5) = gcd(5, 10 \bmod 5) = gcd(5, 0)\)

\item {} 
\sphinxAtStartPar
\(gcd(5, 0) = 5\)

\end{itemize}

\sphinxAtStartPar
Notice that in the example above, the first number (10) was smaller than
the second (15), and the first transformation just swapped the numbers,
so the larger number was first.  Thereafter the first number is always
larger.


\subsection{GCD “Brute Force” Method}
\label{\detokenize{while/gcdexamples:gcd-brute-force-method}}
\sphinxAtStartPar
Now that we’ve gotten the preliminaries out of the way and have a basic
mathematical explanation for how
to calculate the greatest common divisor,
we’ll take a look at how to translate this into code using the
machinery of while loops that you’ve recently learned.

\sphinxAtStartPar
The way GCD is formulated above is, indeed, the most clever way to
calculate the greatest common divisor.
Yet the way we learn about the greatest common divisor in elementary
school (at least at first) is to
learn how to factor the numbers a and b, often in a brute force way.
So for example, when calculating the
greatest common divisor of 10 and 15, we can immediately see it,
because we know that both of these
numbers are divisible by 5 (e.g. 5 * 2 = 10 and 5 * 3 = 15).
So the greatest common divisor is 5.

\sphinxAtStartPar
But if we had something more tricky to do like 810 and 729,
we might have to think a bit more.

\sphinxAtStartPar
Before we learn to find the factors of numbers,
we will often just “try” numbers until we get the
greatest common divisor. This sort of trial process can take place in a loop,
where we start at 1 and end at min(a, b). Why the minimum?
We know that none of the values after the minimum can divide both a and b
(in integer division),
because no larger number can divide a smaller positive number. The smaller
number would be the (non\sphinxhyphen{}zero) remainder.

\sphinxAtStartPar
Now take a look at a basic version of GCD:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Return the greatest common divisor of positive numbers.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GreatestCommonDivisor}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Min}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{gcd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}

\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{gcd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{gcd}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code works as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
We begin by finding \sphinxcode{\sphinxupquote{Math.Min(a, b)}}.
This is how to compute the minimum of any two
values in C\#. Technically, we don’t need to use the minimum of a and b,
but there is no
point in doing any more work than necessary.

\item {} 
\sphinxAtStartPar
We’ll use the variable \sphinxcode{\sphinxupquote{i}} as the loop index, starting at 1.

\item {} 
\sphinxAtStartPar
The variable \sphinxcode{\sphinxupquote{gcd}} will hold the largest currently known common divisor.
We start with 1, which divides any integer, and we will
look for a higher value that also divides a and b.

\item {} 
\sphinxAtStartPar
The line \sphinxcode{\sphinxupquote{while (i \textless{}= n)}} is used to indicate that we are
iterating the values of
\sphinxcode{\sphinxupquote{i}} until the minimum of \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} (computed earlier) is reached.

\item {} 
\sphinxAtStartPar
The line \sphinxcode{\sphinxupquote{if (a \% i == 0 \&\& b \% i == 0)}}
is used to check whether we have found a
new value that replaces our previous \sphinxstyleemphasis{candidate} for the GCD.
A value can only be
a candidate for the GCD if it divides a and b without a remainder.
The modulus
operator \sphinxcode{\sphinxupquote{\%}} is our way of determining whether there is a
remainder from the
division operation \sphinxcode{\sphinxupquote{a / i}} or \sphinxcode{\sphinxupquote{b / i}}.

\item {} 
\sphinxAtStartPar
The line \sphinxcode{\sphinxupquote{i++}} is our way of going to the next value of \sphinxcode{\sphinxupquote{i}}
to be tested as the new GCD.

\item {} 
\sphinxAtStartPar
When this loop terminates, the greatest common divisor has been found.

\end{itemize}

\sphinxAtStartPar
So this gives you a relatively straightforward way of calculating the
greatest common divisor. While simple, it is not necessarily the most
efficient way of determining the GCD. If you think about what is going on,
this loop could run a significant number of times.
For example, if you were calculating the GCD two very large numbers, say,
one billion (1,000,000,000) and two billion (2,000,000,000)
it is painfully evident that you would consider a large number of values
(a billion, in fact) before obtaining
the candidate GCD, which we know is 1,000,000,000.


\subsubsection{Brute\sphinxhyphen{}Force GCD Exercise}
\label{\detokenize{while/gcdexamples:brute-force-gcd-exercise}}
\sphinxAtStartPar
The code above goes though all integers 2 through \sphinxcode{\sphinxupquote{min(a, b)}}.  That is
not generally necessary when the GCD is greater than 1,
even with a brute\sphinxhyphen{}force mindset.   Write a
\sphinxcode{\sphinxupquote{g\_c\_d\_basic\_faster.cs}} to do this with a slightly different
\sphinxcode{\sphinxupquote{GreatestCommonDivisor}} function. %
\begin{footnote}[1]\sphinxAtStartFootnote
The original brute\sphinxhyphen{}force gcd approach always goes through all the integers
between 1 and \sphinxcode{\sphinxupquote{min(a, b)}}.  There is a way to stop the first time
the real gcd is reached.  How can you arrange that?
%
\end{footnote}


\subsection{GCD Subtraction Method}
\label{\detokenize{while/gcdexamples:gcd-subtraction-method}}
\sphinxAtStartPar
The subtraction method (also attributable to Euclid) to compute the
Greatest Common Divisor works as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Based on the \sphinxstyleemphasis{mathematical} definition in the previous section, the
greatest common divisor algorithm saves a step when we already have
\sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} in the \sphinxstyleemphasis{right order}.

\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{right order} means that \(a > b\). As we noted earlier, the
cleverness of the \sphinxstyleemphasis{mathematical} definition is that \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}
are swapped as the first step to ensure that \(a > b\), after
which we can repeatedly divide to get the GCD.

\item {} 
\sphinxAtStartPar
Division, of course, is a form of repetitive subtraction, so the way
to divide by \sphinxcode{\sphinxupquote{b}} is to repeatedly subtract it (from a) until \sphinxcode{\sphinxupquote{a}}
is no longer greater than \sphinxcode{\sphinxupquote{b}}.

\item {} 
\sphinxAtStartPar
The subtraction method basically makes no attempt to put \sphinxcode{\sphinxupquote{a}} and
\sphinxcode{\sphinxupquote{b}} in the right order. Instead, we just write similar loops to
allow for the possibility of either order.

\item {} 
\sphinxAtStartPar
A simple check must be performed to ensure that the approach of
repeated subtraction actually resulted in the GCD. This will happen
if \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} bump into one another, thereby meaning that we
have computed the GCD.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GreatestCommonDivisor}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A look at the source code more or less follows the above explanation.

\sphinxAtStartPar
Let’s start by looking at the inner loop at line 5, \sphinxcode{\sphinxupquote{while (a \textgreater{}
b)}}. In this loop, we are repeatedly subtracting \sphinxcode{\sphinxupquote{b}} from \sphinxcode{\sphinxupquote{a}},
which we know we can do, because \sphinxcode{\sphinxupquote{a}} started out as being larger
than \sphinxcode{\sphinxupquote{b}}.  At the end of loop \sphinxcode{\sphinxupquote{a}} is reduced to either
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}}, in which case \sphinxcode{\sphinxupquote{b}} exactly divided the earlier \sphinxcode{\sphinxupquote{a}},
and \sphinxcode{\sphinxupquote{b}} is the GCD, or

\item {} 
\sphinxAtStartPar
a number less than \sphinxcode{\sphinxupquote{b}}, namely
\(a \bmod b\) (or in C\# terms \sphinxcode{\sphinxupquote{a \% b}}), and the process continues….

\end{enumerate}

\sphinxAtStartPar
The loop on line 9 is similar to the loop in line 5. For the same
reasons as we already explained, \sphinxcode{\sphinxupquote{b}} ends up equal to \sphinxcode{\sphinxupquote{a}},
which is the GCD, or \sphinxcode{\sphinxupquote{b}} ends up as
\(b \bmod a\).

\sphinxAtStartPar
As discussed above, if \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} end up as the same number,
that is the GCD.  On the other hand,
the first GCD algorithm example showed how remainders may need to be to
be calculated over and over.  The outer loop in this version keeps this up
until \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} are reduced to equal
values.  At this point the inner loops would make no further changes,
and the common value is the GCD.

\sphinxAtStartPar
As an exercise to the reader, you may want to consider adding some
\sphinxcode{\sphinxupquote{Console.WriteLine()}} statements to print the values of \sphinxcode{\sphinxupquote{a}} and
\sphinxcode{\sphinxupquote{b}} within each loop, and after both loops have executed. It will
allow you to see in visual terms how this method does its work.

\index{greatest common divisor@\spxentry{greatest common divisor}!iterative@\spxentry{iterative}}\ignorespaces 

\subsection{GCD Remainder Loop}
\label{\detokenize{while/gcdexamples:gcd-remainder-loop}}\label{\detokenize{while/gcdexamples:index-1}}\label{\detokenize{while/gcdexamples:id2}}
\sphinxAtStartPar
There are several ways to code the shorter Euclidean algorithm at the beginning of this
GCD section.  It is a repetitive pattern,
and a loop can be used.  There are two parameters, \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}, to the gcd,
and they can be successively changed, suggesting a loop.  What is the continuation
condition?  You stop when \sphinxcode{\sphinxupquote{b}} is 0, so you continue while \sphinxcode{\sphinxupquote{b != 0}}.
The parameters \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} need to be replaced by \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{a \% b}}.
One extra variable needs to be introduced to make this double change work.  The simplest
is to introduce a variable \sphinxcode{\sphinxupquote{r}} for the remainder.  Check and see for yourself that you
need an extra variable like \sphinxcode{\sphinxupquote{r}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the greatest comon divisor of nonnegative numbers,}
\PYG{c+c1}{/// not both 0.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GreatestCommonDivisor}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
More verbose demonstration code,
that prints the progress each time through
loop is in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/g\_c\_d\_remainder\_loop/g\_c\_d\_remainder\_loop.cs}{g\_c\_d\_remainder\_loop/g\_c\_d\_remainder\_loop.cs}.

\index{recursion@\spxentry{recursion}!greatest common divisor@\spxentry{greatest common divisor}}\index{greatest common divisor@\spxentry{greatest common divisor}!recursion@\spxentry{recursion}}\ignorespaces 

\subsection{Preview: Recursive GCD}
\label{\detokenize{while/gcdexamples:preview-recursive-gcd}}\label{\detokenize{while/gcdexamples:gcd-recursive}}\label{\detokenize{while/gcdexamples:index-2}}
\sphinxAtStartPar
The first statement of Euclid’s algorithm said (in C\#) when

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gcd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{gcd}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is saying the result of the function with one set of parameters is equal to
calling the function with another set of parameters.  If we put this into a
C\# function definition, it would mean the instructions for the function say
to \sphinxstyleemphasis{call itself}.  This is a broadly useful technique called \sphinxstyleemphasis{recursion},
where a function calls \sphinxstyleemphasis{itself} inside its definition.
We don’t expect you to master this
technique immediately but do feel that it is important you at least
\sphinxstyleemphasis{hear} about it and see its tremendous power:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return the greatest comon divisor of nonnegative numbers,}
\PYG{c+c1}{/// not both 0.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GreatestCommonDivisor}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{                               }\PYG{c+c1}{// base}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}\PYG{+w}{                                }\PYG{c+c1}{//   case}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nf}{GreatestCommonDivisor}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// recursion}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Recalling our earlier definition, the case \(gcd(a, 0) = a\) is
handled directly by lines commented as “base case”.

\item {} 
\sphinxAtStartPar
And the case \(gcd(a, b) = gcd(b, a \bmod b)\) is handled by
line with comment “recursion”, with the function calling itself.

\end{itemize}

\sphinxAtStartPar
In \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/g\_c\_d\_euclid\_recursive/g\_c\_d\_euclid\_recursive.cs}{g\_c\_d\_euclid\_recursive/g\_c\_d\_euclid\_recursive.cs}
is a wordier demonstration version that prints to the screen
the progress at each recursive call.

\sphinxAtStartPar
The recursive version of the \sphinxcode{\sphinxupquote{gcd}} function \sphinxstyleemphasis{refers to itself}
by \sphinxstyleemphasis{calling} itself.  Though this seems circular, you can see
from the examples that it works very well.  The important point is that
the calls to the same function are not completely the same:
\sphinxstyleemphasis{Successive} calls have \sphinxstyleemphasis{smaller} second numbers, and the second
number eventually reaches 0, and in that case
there is a direct final answer.  Hence the function is not really circular.

\sphinxAtStartPar
This recursive version is a much more direct translation of the original
mathematical algorithm than the looping version!

\sphinxAtStartPar
The general idea of recursion is for a
function to call itself with \sphinxstyleemphasis{simpler} parameters, until a simple enough place
is reached, where the answer can be directly calculated.

\sphinxstepscope

\index{statement@\spxentry{statement}!do while@\spxentry{do while}}\index{do while@\spxentry{do while}}\index{while vs. do while@\spxentry{while vs. do while}}\ignorespaces 

\section{Do\sphinxhyphen{}While Loops}
\label{\detokenize{while/do-while:do-while-loops}}\label{\detokenize{while/do-while:do-while}}\label{\detokenize{while/do-while:index-0}}\label{\detokenize{while/do-while::doc}}
\sphinxAtStartPar
Suppose you want the user to enter three integers for sides of a
right triangle.  If they do not make a right triangle, say so
and make the user try again.

\sphinxAtStartPar
One way to look at the while statement rubric is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
set data for condition
while (condition) \PYGZob{}
   accomplish something
   set data for condition
\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we have pointed out before this involves setting data in two places.
With the triangle problem, three pieces for data need to be entered,
and the condition to test is fairly simple.   (In any case the condition
could be calculated in a function.)

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}} loop will help here.  It tests the condition at the end of the
loop, so there is no need to gather data before the loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{k}{do}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Think of integer sides for a right triangle.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter integer leg: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter another integer leg: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter integer hypotenuse: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{o}{*}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Not a right triangle: Try again!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{o}{*}\PYG{n}{b}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The general form of a \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}} statement is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{do \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\} while (}} \sphinxstyleemphasis{continuationCondition} \sphinxcode{\sphinxupquote{);}}
\end{DUlineblock}

\sphinxAtStartPar
Here the block of statement(s) is \sphinxstyleemphasis{always} executed at least once, but it continues
to be executed in a loop only so long as the condition tested
after the loop body is true.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}} loop is the \sphinxstyleemphasis{one} place where you \sphinxstyleemphasis{do} want a semicolon
right after a condition, unlike the places mentioned in
{\hyperref[\detokenize{decisions/ifpitfalls:dangerous-semicolon}]{\sphinxcrossref{\DUrole{std,std-ref}{Dangerous Semicolon}}}}.  At least if you omit it here you
are likely to get a compiler error rather than a difficult logical
bug.
\end{sphinxadmonition}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}} loop, like the example above,
can accomplish exactly the same thing as the \sphinxcode{\sphinxupquote{while}}
loop rubric at the beginning of this section.  It has the general form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
do \PYGZob{}
   set data for condition
   if (condition) \PYGZob{}
       accomplish something
   \PYGZcb{}
\PYGZcb{} while (condition);
\end{sphinxVerbatim}

\sphinxAtStartPar
It only sets the data to be tested \sphinxstyleemphasis{once}.
(The trade\sphinxhyphen{}off is that the condition is tested \sphinxstyleemphasis{twice}.)

\sphinxAtStartPar
In the example above note that the declaration of \sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}}, and \sphinxcode{\sphinxupquote{c}} is
\sphinxstyleemphasis{before} the \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}}
loop.  You can try moving the declaration inside the braces for the loop body,
and see the compiler error that you get!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Recall the variables declared inside
a braces\sphinxhyphen{}delimited block have scope \sphinxstyleemphasis{local to that block}.  The condition at
the end of the loop is \sphinxstyleemphasis{outside} that scope.  Hence the declaration of variables that
you want in the final test or for later use after the loop must be
declared \sphinxstyleemphasis{before} the \sphinxcode{\sphinxupquote{do}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{while}} loop.
\end{sphinxadmonition}

\index{exercise@\spxentry{exercise}!loan table@\spxentry{loan table}}\index{decimal@\spxentry{decimal}!loan table exercise@\spxentry{loan table exercise}}\ignorespaces 

\subsection{Loan Table Exercise}
\label{\detokenize{while/do-while:loan-table-exercise}}\label{\detokenize{while/do-while:index-1}}\label{\detokenize{while/do-while:id1}}
\sphinxAtStartPar
Loans are common with a specified interest rate and with a fixed periodic
payment.  Interest is charged at a fixed rate on the amount left in the loan
after the last periodic payment (or start of the loan for the first payment).

\sphinxAtStartPar
For example, if an initial \$100 loan is made with 10\% interest per pay
period, and a regular \$20 payment each pay period:
At the time of the first payment interest of \$100*.10 = \$10 is accrued,
so the total owed is \$110.  Right after the payment of \$20,
\$110 \sphinxhyphen{} \$20 = \$90 remains.  That \$90 gains interest of \$90*.10 = \$9 up to the
next payment, when \$90 + \$9 = \$99 is owed.  After the regular payment of
\$20, \$99 \sphinxhyphen{} \$20 = \$79 is left, and so on.  When a payment of at most \$20 brings
the amount owed to 0, the loan is done.

\sphinxAtStartPar
We can make a table showing
\begin{itemize}
\item {} 
\sphinxAtStartPar
Payment number (starting from 1)

\item {} 
\sphinxAtStartPar
The principal amount after the previous payment (or the beginning of the loan
for the first payment)

\item {} 
\sphinxAtStartPar
The interest on that principal up until the next periodic payment

\item {} 
\sphinxAtStartPar
The payment made as a result.

\end{itemize}

\sphinxAtStartPar
Continuing the example above, the whole table
would look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Number Principal   Interest    Payment
     1    100.00      10.00      20.00
     2     90.00       9.00      20.00
     3     79.00       7.90      20.00
     4     66.90       6.69      20.00
     5     53.59       5.36      20.00
     6     38.95       3.90      20.00
     7     22.85       2.29      20.00
     8      5.14       0.51       5.65
\end{sphinxVerbatim}

\sphinxAtStartPar
In the final line, the principal plus interest equal the payment, finishing
off the loan.

\sphinxAtStartPar
Similarly, with a \$1000.00 starting loan, 5\% interest per pay period, and
\$196 payments due, we would get

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Number Principal   Interest    Payment
     1   1000.00      50.00     196.00
     2    854.00      42.70     196.00
     3    700.70      35.04     196.00
     4    539.74      26.99     196.00
     5    370.73      18.54     196.00
     6    193.27       9.66     196.00
     7      6.93       0.35       7.28
\end{sphinxVerbatim}

\sphinxAtStartPar
If a \$46 payment were specified, the principal would not decrease from the
initial amount, and the loan would never be paid off.

\sphinxAtStartPar
There are a couple of wrinkles here:  \sphinxcode{\sphinxupquote{double}} values do not hold decimal
values exactly.  The \sphinxcode{\sphinxupquote{decimal}} type does hold decimal numbers exactly
(and in an enormous range, see {\hyperref[\detokenize{data/types-and-conversions:numeric-type-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{Numeric Types and  Limits}}}}) and
hence are beter for monetary calculations.  Decimal literals end with m, like
\sphinxcode{\sphinxupquote{34.56m}} for \sphinxstyleemphasis{exactly} 34.56.

\sphinxAtStartPar
Though decimals are exact, money only has two decimal places.  We make the
assumption that interest will always be calculated as current
principal*rate, rounded
to two decimal places:  \sphinxcode{\sphinxupquote{Math.Round(principal*rate, 2)}}.

\sphinxAtStartPar
Write \sphinxcode{\sphinxupquote{loan\_calc.cs\textasciigrave{}}}, completing \sphinxcode{\sphinxupquote{LoanTable}} and write a
\sphinxcode{\sphinxupquote{Main}} testing program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print a loan table, showing payment number, principal at the}
\PYG{c+c1}{/// beginning of the payment period, interest over the period, and}
\PYG{c+c1}{/// payment at the end of the period.}
\PYG{c+c1}{/// The principal is the initial amount of the loan.}
\PYG{c+c1}{/// The rate is fraction representing the rate of interest per PAYMENT.}
\PYG{c+c1}{/// The periodic regular payment is also specified.}
\PYG{c+c1}{/// If the payment is insufficient, merely print \PYGZdq{}payment too low\PYGZdq{}.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{LoanTable}\PYG{p}{(}\PYG{k+kt}{decimal}\PYG{+w}{ }\PYG{n}{principal}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{decimal}\PYG{+w}{ }\PYG{n}{rate}\PYG{p}{,}
\PYG{+w}{                             }\PYG{k+kt}{decimal}\PYG{+w}{ }\PYG{n}{payment}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the \sphinxcode{\sphinxupquote{rate}}, too, is a \sphinxcode{\sphinxupquote{decimal}},
even though it does not represent money.
That is important, because arithmetic with a \sphinxcode{\sphinxupquote{decimal}} and a \sphinxcode{\sphinxupquote{double}} is
forbidden:  A \sphinxcode{\sphinxupquote{double}} would have to be explicitly cast to a \sphinxcode{\sphinxupquote{decimal}}.
Insisting on \sphinxcode{\sphinxupquote{decimal}} parameter simplifies the function code.

\sphinxAtStartPar
This exercise is much more sophisticated than the {\hyperref[\detokenize{while/whileexamples:savings-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Savings Exercise}}}},
so it is placed in this section, much later in the chapter.  Use what
ever form of loop makes the most sense to you.

\sphinxstepscope

\index{labs@\spxentry{labs}!string manipulations@\spxentry{string manipulations}}\ignorespaces 

\section{Number Guessing Game Lab}
\label{\detokenize{while/lab-number-game:number-guessing-game-lab}}\label{\detokenize{while/lab-number-game:lab-number-game}}\label{\detokenize{while/lab-number-game:index-0}}\label{\detokenize{while/lab-number-game::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Objectives}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Work with functions

\item {} 
\sphinxAtStartPar
Work with interactive while loops

\item {} 
\sphinxAtStartPar
Use decisions

\item {} 
\sphinxAtStartPar
Introduce random values

\end{itemize}

\sphinxAtStartPar
This lab is inspired by a famous children’s game
known as the number\sphinxhyphen{}guessing game. We suppose two people are playing.

\sphinxAtStartPar
The rules are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Person A chooses a positive integer less than N and keeps it in his or
her head.

\item {} 
\sphinxAtStartPar
Person B makes repeated guesses to determine the number. Person A
must indicate whether the guess is higher or lower.

\item {} 
\sphinxAtStartPar
Person A must tell the truth.

\end{itemize}

\sphinxAtStartPar
So as an example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
George and Andy play the game.

\item {} 
\sphinxAtStartPar
George chooses a positive number less than 100 (29) and puts it in his
head.

\item {} 
\sphinxAtStartPar
Andy guesses 50. George says “Lower”. Andy now knows that
\(1 \leq number < 50\).

\item {} 
\sphinxAtStartPar
Andy guesses 25. George says “Higher”. Andy now knows that
\(26 \leq number < 50\).

\item {} 
\sphinxAtStartPar
Andy guesses 30. George says “Lower”. Andy now knows that the
\(26 \leq number < 30\).

\item {} 
\sphinxAtStartPar
Andy starts thinking that he is close to knowing the correct answer. He
decides to guess 29. Andy guesses the correct number. So George
says, “Good job! You win.”

\end{itemize}

\sphinxAtStartPar
We are going to elaborate this game in small steps.  You might save
the intermediate versions under new names.

\sphinxAtStartPar
The computer code for the
game is going to be acting like Player A.


\subsection{Part 1: No Hints; Fixed Secret Number}
\label{\detokenize{while/lab-number-game:part-1-no-hints-fixed-secret-number}}
\sphinxAtStartPar
You will want to use the UI class, so either copy ui.cs into your project, or
(for Xamarin Studio) create a new project in a solution
in which you already have added the ui library project, and add the ui project
as a \sphinxstyleemphasis{reference} for the lab project.
Make sure your program has \sphinxcode{\sphinxupquote{namespace IntroCS;}} to match the UI class.

\sphinxAtStartPar
You are going to play a game, and later may repeat it, so put the code
for playing the number game in a function called \sphinxcode{\sphinxupquote{Game}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Game}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For now your write a \sphinxcode{\sphinxupquote{Main}} function to just call \sphinxcode{\sphinxupquote{Game()}}.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Game}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
For the simplest versions, which help testing, have the
program assign a specific
secret number (like 29), and call it \sphinxcode{\sphinxupquote{secret}}.
Admittedly, this is not much fun for the player the second time!

\item {} 
\sphinxAtStartPar
Prompt the player for a guess.
Use \sphinxcode{\sphinxupquote{UI.PromptInt}}.
Every time the player guesses wrong,
print “Wrong!”.  A later version will give clues.  Keep
prompting for another number until the player guesses correctly.
(Since you, the programmer, knows the secret number, this need not go
on forever.)

\item {} 
\sphinxAtStartPar
When the player guesses the right number, print “Correct!  You win!”

\end{enumerate}

\sphinxAtStartPar
Sample play could look like:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number: \sphinxstylestrong{55}
\item[] Wrong!
\item[] Guess the number: \sphinxstylestrong{12}
\item[] Wrong!
\item[] Guess the number:  \sphinxstylestrong{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
You could also make the game stop immediately,
(since you know the secret number):
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number:  \sphinxstylestrong{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 2: Add Hints}
\label{\detokenize{while/lab-number-game:part-2-add-hints}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Game}}:
Instead of just printing “Wrong!” when the player is incorrect,
print “Lower!” or “Higher!”  as appropriate.  For example:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number: \sphinxstylestrong{55}
\item[] Lower!
\item[] Guess the number: \sphinxstylestrong{12}
\item[] Higher!
\item[] Guess the number: \sphinxstylestrong{25}
\item[] Higher!
\item[] Guess the number:  \sphinxstylestrong{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 3:  Add a Random Secret Number}
\label{\detokenize{while/lab-number-game:part-3-add-a-random-secret-number}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Game}}, make the following alterations and additions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
For now set an \sphinxcode{\sphinxupquote{int}} variable \sphinxcode{\sphinxupquote{big}} to 100.  We will make sure
the secret number is less than \sphinxcode{\sphinxupquote{big}}.

\item {} 
\sphinxAtStartPar
Have the Game function print
“In this game you guess a positive number less than 100.”
For future use it is best if you have the printing statement
reference the variable \sphinxcode{\sphinxupquote{big}}, rather than the literal \sphinxcode{\sphinxupquote{100}}.

\end{enumerate}

\index{random number generator@\spxentry{random number generator}}\ignorespaces \begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Thus far the secret number was fixed in the program.  Now we are
going to let it vary, by having the game generate a \sphinxstyleemphasis{random} number.
For your convenience, we are going to give you the C\#
code to compute the random number.  Assuming we want a secret number
so \(1 \leq secret < big\), we can use the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Random}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{secret}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{big}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In case you are wondering, we are creating a \sphinxstyleemphasis{new object}
of the \sphinxstyleemphasis{class} \sphinxcode{\sphinxupquote{Random}} which serves as the
random number generator. We’ll cover this in more detail when we
get to the {\hyperref[\detokenize{classes/classes:classes}]{\sphinxcrossref{\DUrole{std,std-ref}{Classes and Object\sphinxhyphen{}Oriented Programming}}}} chapter. Here is some illustration using a \sphinxcode{\sphinxupquote{Random}}
object in csharp.  Your answers will not be the same!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{Random}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{55}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{31}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{79}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{4}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general the minimum possible value of the number returned by \sphinxcode{\sphinxupquote{r.Next}}
is the first parameter, and the value returned is always \sphinxstyleemphasis{less} than
the second parameter, \sphinxstyleemphasis{never equal}.

\sphinxAtStartPar
You can see that \sphinxcode{\sphinxupquote{r.Next()}} is smart enough to give what appears to
be a randomly chosen number every time.

\sphinxAtStartPar
Example (where \sphinxcode{\sphinxupquote{secret}} ended up as 68):
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess a number less than 100!
\item[] Guess the number: \sphinxstylestrong{60}
\item[] Higher!
\item[] Guess the number: \sphinxstylestrong{72}
\item[] Lower!
\item[] Guess the number: \sphinxstylestrong{66}
\item[] Higher!
\item[] Guess the number: \sphinxstylestrong{68}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
For debugging purposes, you might want to have \sphinxcode{\sphinxupquote{secret}}
be printed out right away.
(Eliminate that part when everything works!)

\end{enumerate}


\subsection{Part 4:  Let the Player Set the Range of Values}
\label{\detokenize{while/lab-number-game:part-4-let-the-player-set-the-range-of-values}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Game}}:
Instead of declaring \sphinxcode{\sphinxupquote{big}} and  automatically initializing it to 100,
make \sphinxcode{\sphinxupquote{big}} be a parameter, so the heading looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Game}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{big}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Main}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Prompt the player for the limit on the secret number.
An exchange might look like:
\begin{quote}

\sphinxAtStartPar
Enter a secret number bound: \sphinxstylestrong{10}
\end{quote}

\item {} 
\sphinxAtStartPar
Pass the value given by the player to the \sphinxcode{\sphinxupquote{Game}} function
(so it will be \sphinxcode{\sphinxupquote{big}} inside \sphinxcode{\sphinxupquote{Game}}).

\end{enumerate}

\sphinxAtStartPar
Hence the program might start with:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter a secret number bound: \sphinxstylestrong{10}
\item[] In this game you guess a number less than 10!
\item[] Guess the number: \sphinxstylestrong{5}
\item[] Higher!
\item[] Guess the number: \sphinxstylestrong{7}
\item[] Lower!
\item[] Guess the number: \sphinxstylestrong{6}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 5:  Count the Guesses}
\label{\detokenize{while/lab-number-game:part-5-count-the-guesses}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Game}}: When the player finally wins, print the number of guesses
the player made.  For example, for the game sequence shown above,
the last line would become:
\begin{quote}

\sphinxAtStartPar
Good job!  You win on guess 3!
\end{quote}

\sphinxAtStartPar
You need to keep a count, adding 1 with each guess.


\subsection{Possible Extra Credit Improvements or Variations}
\label{\detokenize{while/lab-number-game:possible-extra-credit-improvements-or-variations}}
\sphinxAtStartPar
Should you finish everything early, try the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{(20\% extra credit)}  In \sphinxcode{\sphinxupquote{Main}}:

\sphinxAtStartPar
Use an outer \sphinxcode{\sphinxupquote{while}} loop to allow the game to be played
repeatedly. Change the prompt for the bound in \sphinxcode{\sphinxupquote{Main}} to:
\begin{quote}

\sphinxAtStartPar
Enter a secret number bound (or 0 to quit):
\end{quote}

\sphinxAtStartPar
Continue to play games until the player enters 0 for the bound.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{(40\% extra credit)}
In \sphinxcode{\sphinxupquote{Main}} prompt users to see if they want to guess numbers or reverse roles and
choose
the secret number.  In the first case, just call the existing Game function.
In the second case you need a new function,
where the user is the one who knows the secret
number and the computer guesses numbers until the answer
is obtained. Write and use a new function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{GameReversed}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{big}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Pass it the parameter \sphinxcode{\sphinxupquote{big}}, still set in \sphinxcode{\sphinxupquote{Main}}.
The new \sphinxcode{\sphinxupquote{GameReversed}} will tell the user to put a number in
his/her head, and press return to continue.
(You can throw away the string entered \sphinxhyphen{} this is just to cause a pause.)
Then the computer guesses.
For simplicity let the human enter “L” for lower, “H” for higher, and
“E” for equal (when the computer wins).
As you saw in the initial example with George and Andy,
each hint reduces the range of the possible secret numbers.
Have the computer guess a \sphinxstyleemphasis{random} number in the \sphinxstyleemphasis{exact} range that
remains possible.

\sphinxAtStartPar
To do this you must note the asymmetry of the parameters for the method
\sphinxcode{\sphinxupquote{Next}}:  suppose \sphinxcode{\sphinxupquote{n = r.Next(low, higher)}}, then
\begin{quote}

\sphinxAtStartPar
\(low \leq number < higher\)
\end{quote}

\sphinxAtStartPar
The first parameter \sphinxstyleemphasis{may} be returned, but second
parameter is \sphinxstyleemphasis{never} returned.

\sphinxAtStartPar
You will need two variables \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{higher}} that keep
bracketing the allowed range.  The simplest thing is to set them so they
will be the parameters for the following call to \sphinxcode{\sphinxupquote{Next}}.

\sphinxAtStartPar
That would mean initially \sphinxcode{\sphinxupquote{low}}
is 1 and \sphinxcode{\sphinxupquote{higher}} is equal to \sphinxcode{\sphinxupquote{big}}.
With each hint you adjust one or the other of \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{higher}} so they
get closer together.
The game ends after the human enters “E”.

\sphinxAtStartPar
Have the computer complain that the human is cheating (and stop the game)
if the computer
guesses the only possible value, and the human does \sphinxstyleemphasis{not} respond with “E”.

\end{enumerate}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{while/reviewwhile:chapter-review-questions}}\label{\detokenize{while/reviewwhile::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
While loops are a very important part of your programming tools.
Put in your own words:  when should you think to use a while loop?
What words or phrases in the description of a problem suggest the use of a loop?

\sphinxAtStartPar
More concretely, each sentence below introduces a problem.
What words/combinations suggest a loop/repetition?

\sphinxAtStartPar
Square each number from 1 to n.

\sphinxAtStartPar
Respond until the user says to stop.

\sphinxAtStartPar
Repeat the process until the width is \textless{} .00001.

\sphinxAtStartPar
Count the vowels in the sentence that you are given.

\sphinxAtStartPar
See if there are any double letters in the word that you are given.

\item {} 
\sphinxAtStartPar
Loops are also among the hardest things for many students \textendash{}
with lots of things to think about.
There is a sequence of general process questions that you can ask yourself
to help you organize your work.  What are they in your words?
Do you know them well, or have them written down in a place you
can easily jump to?

\item {} 
\sphinxAtStartPar
Compare do\sphinxhyphen{}while and while loops:
How do you think about which one to use?

\item {} 
\sphinxAtStartPar
In an interactive while loop you need to continuously get data
from the user.  Where do you generally put the code to get more data?

\item {} 
\sphinxAtStartPar
In general, what causes an infinite \sphinxcode{\sphinxupquote{while}} loop?

\item {} 
\sphinxAtStartPar
What is wrong with this statement:  When the condition in a \sphinxcode{\sphinxupquote{while}} loop
heading becomes false, the loop statement immediately terminates.

\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{while}} loop will terminate when the program evaluates the
condition in its heading and the value becomes false.
What is the important difference in this statement from the previous
incorrect statement?

\item {} 
\sphinxAtStartPar
When is the next step in a program to evaluate the condition in a \sphinxcode{\sphinxupquote{while}} loop heading?
(There are two situations.)

\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{while}} loop is generally terminated when the program evaluates the
condition in its heading and it becomes false.
How else can a program exit from a \sphinxcode{\sphinxupquote{while}} loop?

\item {} 
\sphinxAtStartPar
We generally construct a loop so its body is a compound statement,
composed of a sequence of statements inside.  If this body is a sequence of
simple statements, does it make sense for
one of them to be a return statement?

\item {} 
\sphinxAtStartPar
When inside a loop,
a return statement should generally only appear as a \sphinxstyleemphasis{sub\sphinxhyphen{}statement}
of what kind of statement?

\item {} 
\sphinxAtStartPar
Which of these conditions is safer in general, with \sphinxstyleemphasis{arbitrary}
\sphinxcode{\sphinxupquote{string}} \sphinxcode{\sphinxupquote{s}} and
\sphinxcode{\sphinxupquote{int}} \sphinxcode{\sphinxupquote{i}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}\PYGZsh{}\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}

\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}\PYGZsh{}\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//          012345678901234567890}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Is coding cool?  Yes!\PYGZdq{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}is\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}co\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}co\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}co\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{loop@\spxentry{loop}!foreach@\spxentry{foreach}}\index{foreach@\spxentry{foreach}}\ignorespaces 

\chapter{Foreach Loops}
\label{\detokenize{foreach/foreach:foreach-loops}}\label{\detokenize{foreach/foreach:foreach}}\label{\detokenize{foreach/foreach:index-0}}\label{\detokenize{foreach/foreach::doc}}
\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{foreach}} Syntax}
\label{\detokenize{foreach/foreachintro:foreach-syntax}}\label{\detokenize{foreach/foreachintro:id1}}\label{\detokenize{foreach/foreachintro::doc}}
\index{statement@\spxentry{statement}!foreach@\spxentry{foreach}}\index{foreach@\spxentry{foreach}!syntax@\spxentry{syntax}}\ignorespaces 
\sphinxAtStartPar
These sections on \sphinxcode{\sphinxupquote{foreach}} loops and the later {\hyperref[\detokenize{for/for:for-loops}]{\sphinxcrossref{\DUrole{std,std-ref}{For Loops}}}}
introduce new looping statements.
Neither is absolutely necessary:
You could do all the same things with \sphinxcode{\sphinxupquote{while}} loops,
but there are many situations where \sphinxcode{\sphinxupquote{foreach}} loops and \sphinxcode{\sphinxupquote{for}} loops
are more convenient and easier to read.

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{foreach}} statement
only works with an object that holds a sequence or collection.
We will see many more kinds of sequences later.  For now we can illustrate
with a string, which is a sequence of characters.

\sphinxAtStartPar
We have already processed strings a character at a time, with \sphinxcode{\sphinxupquote{while}} loops.
We took advantage of the fact that strings could be indexed.  Our \sphinxcode{\sphinxupquote{while}}
loops directly controlled the sequence of indices. Then we could
look up the character at each index of a given string \sphinxcode{\sphinxupquote{s}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{code}\PYG{+w}{ }\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{the}\PYG{+w}{ }\PYG{k}{value}\PYG{+w}{ }\PYG{n}{of}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{   }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Examples have been in {\hyperref[\detokenize{while/while-with-sequence:while-sequence}]{\sphinxcrossref{\DUrole{std,std-ref}{While\sphinxhyphen{}Statements with Sequences}}}}, like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Print the characters of s, one per line.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example we really only care about the characters, not the indices.
Managing the indices is just a way to get at the
underlying sequence of characters.

\sphinxAtStartPar
A conceptually simpler view is just:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{n}{each}\PYG{+w}{ }\PYG{n}{character}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{s}
\PYG{+w}{    }\PYG{n}{use}\PYG{+w}{ }\PYG{n}{the}\PYG{+w}{ }\PYG{k}{value}\PYG{+w}{ }\PYG{n}{of}\PYG{+w}{ }\PYG{n}{the}\PYG{+w}{ }\PYG{n}{character}
\end{sphinxVerbatim}

\sphinxAtStartPar
To \sphinxstyleemphasis{use} “the character” in C\#, we must be able to refer to it.
We might name the current character \sphinxcode{\sphinxupquote{ch}}.
The following is a variant of \sphinxcode{\sphinxupquote{OneCharPerLine}} with a \sphinxcode{\sphinxupquote{foreach}}
loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{ch}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{ch}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is all you need! The \sphinxcode{\sphinxupquote{foreach}} heading feeds us one
character from \sphinxcode{\sphinxupquote{s}} each time through, using the name \sphinxcode{\sphinxupquote{ch}}
to refer to it.
Of course any new variable name must be declared in C\#, so \sphinxcode{\sphinxupquote{ch}}
is preceded in the heading by its type, \sphinxcode{\sphinxupquote{char}}.
Then we can use \sphinxcode{\sphinxupquote{ch}} inside the body of the loop.
Advancing to the next element in the sequence is automatic in the next
time through the loop.  No \sphinxcode{\sphinxupquote{i++}} to remember;
no possibility of an infinite loop!

\sphinxAtStartPar
The general syntax of a \sphinxcode{\sphinxupquote{foreach}} loop is

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{foreach (}} \sphinxstylestrong{type itemName} \sphinxcode{\sphinxupquote{in}} \sphinxstyleemphasis{sequence} \sphinxcode{\sphinxupquote{) \{}}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) using \sphinxstylestrong{itemName}
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
Here is a version of IsDigits:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{ch}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{ch}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{ch}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}9\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{          }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{+w}{       }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See the advantages of \sphinxcode{\sphinxupquote{foreach}} in these examples:
\begin{itemize}
\item {} 
\sphinxAtStartPar
They are more concise than the indexing versions.

\item {} 
\sphinxAtStartPar
They keep the emphasis on the characters, not the secondary indices.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{foreach}} heading emphasizes that an entire particular sequence is being
processed.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxstyleemphasis{If} you have explicit need to refer to the indices of the items in the sequence,
then a \sphinxcode{\sphinxupquote{foreach}} statement does not work.  Also a \sphinxcode{\sphinxupquote{foreach}} loop supplies the items in
a specific order; if you need a different order, it will not work.
\end{sphinxadmonition}

\sphinxAtStartPar
Of course you can refer to the indices of items in  sequence with a flexible
\sphinxcode{\sphinxupquote{while}} loop, or see {\hyperref[\detokenize{for/for:for-loops}]{\sphinxcrossref{\DUrole{std,std-ref}{For Loops}}}}, coming soon….

\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{foreach}} Examples}
\label{\detokenize{foreach/foreachexamples:foreach-examples}}\label{\detokenize{foreach/foreachexamples::doc}}
\index{char@\spxentry{char}!underlying numeric code@\spxentry{underlying numeric code}}\ignorespaces \phantomsection\label{\detokenize{foreach/foreachexamples:codeofstringchar}}
\sphinxAtStartPar
In {\hyperref[\detokenize{while/while-with-sequence:isdigits}]{\sphinxcrossref{\DUrole{std,std-ref}{IsDigits}}}} we use the underlying int Unicode value
of the characters in comparisons.
When printing, you cannot see this code directly,
since the \sphinxcode{\sphinxupquote{char}} type prints as \sphinxstyleemphasis{characters}!
To see the underlying code value for a character, ch,
it can be cast to an int:  \sphinxcode{\sphinxupquote{(int)ch}}

\sphinxAtStartPar
We can easily write a loop to print the unicode value of each character in a
string, \sphinxcode{\sphinxupquote{s}}.  We do not need indices here, so a \sphinxcode{\sphinxupquote{foreach}} loop is
appropriate:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{ch}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Unicode for \PYGZob{}0\PYGZcb{} is \PYGZob{}1\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ch}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{ch}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try this in csharp.

\sphinxAtStartPar
We will have many more examples after we introduce more kinds of sequences.

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{foreach/reviewforeach:chapter-review-questions}}\label{\detokenize{foreach/reviewforeach::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Describe in general when a \sphinxcode{\sphinxupquote{foreach}} loop is going to be easier to use
than a \sphinxcode{\sphinxupquote{while}} loop.

\item {} 
\sphinxAtStartPar
Even if you want to process every element of a sequence, what would keep
you from using a \sphinxcode{\sphinxupquote{foreach}} loop?

\end{enumerate}

\sphinxstepscope

\index{loop@\spxentry{loop}!for@\spxentry{for}}\index{for@\spxentry{for}}\ignorespaces 

\chapter{For Loops}
\label{\detokenize{for/for:for-loops}}\label{\detokenize{for/for:index-0}}\label{\detokenize{for/for:id1}}\label{\detokenize{for/for::doc}}
\sphinxstepscope

\index{statement@\spxentry{statement}!for@\spxentry{for}}\ignorespaces 

\section{For\sphinxhyphen{}Statement Syntax}
\label{\detokenize{for/forstatements:for-statement-syntax}}\label{\detokenize{for/forstatements:index-0}}\label{\detokenize{for/forstatements::doc}}
\sphinxAtStartPar
We now introduce the last kind of loop syntax: \sphinxcode{\sphinxupquote{for}} loops.

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{for}} loop is an example of \sphinxstyleemphasis{syntactic sugar}:  syntax that can simplify
things for the programmer, but can be immediately translated into an
equivalent syntax by the compiler.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
is exactly equivalent to this code similar to part of
{\hyperref[\detokenize{while/whilestatements:sumton}]{\sphinxcrossref{\DUrole{std,std-ref}{SumToN}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
More generally:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{for (}} \sphinxstyleemphasis{initialization} \sphinxcode{\sphinxupquote{;}} \sphinxstyleemphasis{condition} ; \sphinxstyleemphasis{update} \sphinxcode{\sphinxupquote{)}} \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
translates to

\begin{DUlineblock}{0em}
\item[] \sphinxstyleemphasis{initialization} \sphinxcode{\sphinxupquote{;}}
\item[] \sphinxcode{\sphinxupquote{while (}} \sphinxstyleemphasis{condition} \sphinxcode{\sphinxupquote{)}} \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\item[] \sphinxstyleemphasis{update} \sphinxcode{\sphinxupquote{;}}
\end{DUlineblock}
\item[] \sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}

\sphinxAtStartPar
In the example above, \sphinxstyleemphasis{initialization} is \sphinxcode{\sphinxupquote{i=2}}, \sphinxstyleemphasis{condition} is \sphinxcode{\sphinxupquote{i \textless{}= n}},
and \sphinxstyleemphasis{update} is \sphinxcode{\sphinxupquote{i++}}.

\sphinxAtStartPar
Why bother with this rearrangement?  It is a matter of taste,
but the heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
puts all the information about the variable controlling the loop
into one place at the top, which may help quickly visualize the overall
sequence in the loop.  If you use this format, and get used to the
three parts you are less likely to forget the \sphinxcode{\sphinxupquote{i++}}
than when it comes tacked on to the end of a while loop body, after all
the specific things you were trying to accomplish.

\sphinxAtStartPar
Although the \sphinxcode{\sphinxupquote{for}} loop syntax is very general,
a strongly recommended convention
is to only use a \sphinxcode{\sphinxupquote{for}} statement when all the control of variables
determining loop repetition are in the heading.

\sphinxAtStartPar
For example if a \sphinxcode{\sphinxupquote{for}}
loop uses \sphinxcode{\sphinxupquote{i}} in the heading, \sphinxcode{\sphinxupquote{i}} can have a value assigned or
reassigned in the heading, but should \sphinxstyleemphasis{not} have its value modified
anywhere inside the loop body.
If you want more complicated behavior, use a \sphinxcode{\sphinxupquote{while}} loop.

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{for}} loop can also include variable declaration in the initialization,
as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is close, but not quite equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Variables declared in a \sphinxcode{\sphinxupquote{for}} loop heading are local to the
\sphinxcode{\sphinxupquote{for}} loop heading and body.  The variable \sphinxcode{\sphinxupquote{i}} declared before
the \sphinxcode{\sphinxupquote{while}} statement above is still defined after the \sphinxcode{\sphinxupquote{while}} loop.

\sphinxAtStartPar
The two semicolons are always needed in the \sphinxcode{\sphinxupquote{for}} heading, but any of the
parts they normally separate may be omitted.
If the condition part is omitted, the condition is
interpreted as always true, leading to an infinite loop, that can only
terminate due to a \sphinxcode{\sphinxupquote{return}} or {\hyperref[\detokenize{for/forstatements:break-continue}]{\sphinxcrossref{\DUrole{std,std-ref}{break statement}}}} in the body.

\index{execution sequence@\spxentry{execution sequence}!for loop@\spxentry{for loop}}\ignorespaces 
\sphinxAtStartPar
Note the different parts of the heading used at different times (consistent
with the positions in the corresponding while loop):
\begin{itemize}
\item {} 
\sphinxAtStartPar
When starting the whole statement, the initialization is done, and then
the test.

\item {} 
\sphinxAtStartPar
After finishing the body and returning to the heading, the update operations
are done, followed by the test.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Other variations}

\sphinxAtStartPar
As in a regular local variable declaration,
there may be several variables of the
same type initialized at the beginning of a \sphinxcode{\sphinxupquote{for}} loop heading,
separated by commas.  Also, at the end of the \sphinxcode{\sphinxupquote{for}} loop heading, the
update portion may include more than one expression, separated by commas.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Guess what this does, and then paste it into csharp to check.

\sphinxAtStartPar
The comma separated lists in a \sphinxcode{\sphinxupquote{for}} statement heading
are mentioned here for completeness.  Later we will find a situation
where this is actually useful.

\index{statement@\spxentry{statement}!break@\spxentry{break}}\index{statement@\spxentry{statement}!continue@\spxentry{continue}}\index{break statement@\spxentry{break statement}}\index{continue statement@\spxentry{continue statement}}\ignorespaces 

\subsection{Break and Continue}
\label{\detokenize{for/forstatements:break-and-continue}}\label{\detokenize{for/forstatements:break-continue}}\label{\detokenize{for/forstatements:index-2}}
\sphinxAtStartPar
This section concerns special \sphinxstyleemphasis{break} and \sphinxstyleemphasis{continue} statements
that can \sphinxstyleemphasis{only} occur inside a loop (any kind:
\sphinxcode{\sphinxupquote{while}}, \sphinxcode{\sphinxupquote{for}} or \sphinxcode{\sphinxupquote{foreach}}).
The syntax is convenient in various circumstances, but not necessary.  You are free
to use it, but for this course it is an \sphinxstyleemphasis{optional extra}:

\sphinxAtStartPar
You can already stop a loop in the middle with an \sphinxcode{\sphinxupquote{if}} statement
that leads to a choice with a \sphinxcode{\sphinxupquote{return}} statement.
Of course that forces you to completely leave the current function.  If you only want to
break out of the \sphinxstyleemphasis{innermost current loop}, but \sphinxstyleemphasis{not} out of the whole function, use
a break statement:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{break;}}
\end{quote}

\sphinxAtStartPar
in place of return.  Execution continues after the end of the whole innermost
currently running loop statement.
The \sphinxcode{\sphinxupquote{break}} and \sphinxcode{\sphinxupquote{continue}} statements only
make practical sense inside of an \sphinxcode{\sphinxupquote{if}} statement that is inside the loop.

\sphinxAtStartPar
Examples, assuming  \sphinxcode{\sphinxupquote{target}} already has a string value and \sphinxcode{\sphinxupquote{a}} is an array of
strings:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{found}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target found at index \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target not found\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When an element is reached that matches \sphinxcode{\sphinxupquote{target}},
execution goes on \sphinxstyleemphasis{past the loop} with \sphinxcode{\sphinxupquote{if (found)}} ….

\sphinxAtStartPar
An alternate implementation with a compound condition in the heading and no \sphinxcode{\sphinxupquote{break}} is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{o}{!}\PYG{n}{found}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{found}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target found at index \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target not found\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
With a \sphinxcode{\sphinxupquote{foreach}} loop, which has no explicit continuation condition,
the \sphinxcode{\sphinxupquote{break}} would be more clearly useful.
Here is a variant if you do not care about the specific location of the target:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}
\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{found}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target found\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Target not found\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{break}} statements is a matter of taste.  There is some advantage in reading
and following a loop that has only one exit criteria,
which is easily visible in the heading.  On the other hand, in many situations,
using a break statement makes the code much less verbose, and hence easier to follow.
If you \sphinxstyleemphasis{are} reading through the loop, it may be clearer to have an immediate action
where it is certain that the loop should terminate.

\sphinxAtStartPar
All the modifiers about \sphinxstyleemphasis{innermost} loop are important
in a situation like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The break statement is in the inner loop.  If it is reached, the inner loop ends,
but the inner loop is just a single statement inside the outer loop,
and the outer loop continues.
If the outer loop continuation condition remains true,
the inner loop will be executed again,
and the break may or may not be reached that time, so the inner loop may or may
not terminate normally….

\sphinxAtStartPar
For completeness we mention the much less used \sphinxcode{\sphinxupquote{continue}} statement:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continue;}}
\end{quote}

\sphinxAtStartPar
It does not break out of the whole loop:
It just
skips the rest of the \sphinxstyleemphasis{body} of the innermost current loop, \sphinxstyleemphasis{this time} through the loop.
In the simplest situations a \sphinxcode{\sphinxupquote{continue}} statement just avoids an extra \sphinxcode{\sphinxupquote{else}} clause.
It can considerable shorten code if the test is inside of complicated, deeply nested
\sphinxcode{\sphinxupquote{if}} statements.

\sphinxstepscope


\section{Examples With \sphinxstyleliteralintitle{\sphinxupquote{for}} Statements}
\label{\detokenize{for/forexamples:examples-with-for-statements}}\label{\detokenize{for/forexamples::doc}}
\sphinxAtStartPar
Thus far all of our \sphinxcode{\sphinxupquote{for}} loops have used a sequence of successive integers.
Suppose you want to print the first \sphinxcode{\sphinxupquote{n}} multiples of \sphinxcode{\sphinxupquote{k}},
like the first 5 multiples
of 3:  3, 6, 9, 12, 15.  This could be handled by generating
a sequence \sphinxcode{\sphinxupquote{i}} = 1 through \sphinxcode{\sphinxupquote{n}}, and multiply each \sphinxcode{\sphinxupquote{i}} by \sphinxcode{\sphinxupquote{k}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another approach is to note that the numbers you want to print advance
in a regular fashion, too, but with an increment 3 in the example above,
or k in general:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{k}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
is a common pattern, less common than incrementing by one,
but still very common.  C\# and many other languages allow a shorter version:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This means to increment the variable i by k.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Be careful: the \sphinxcode{\sphinxupquote{+=}} must be in
that order, with no space between.  Unfortunately the reverse order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{+}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
is also legal, and just assigns the value of k to i.
\end{sphinxadmonition}

\index{operator@\spxentry{operator}!+= \sphinxhyphen{}= *= /= \%=@\spxentry{+= \sphinxhyphen{}= *= /= \%=}}\index{+= operator@\spxentry{+= operator}}\index{\sphinxhyphen{}= operator@\spxentry{\sphinxhyphen{}= operator}}\index{*= operator@\spxentry{*= operator}}\index{/= operator@\spxentry{/= operator}}\index{\%= operator@\spxentry{\%= operator}}\ignorespaces 
\sphinxAtStartPar
Most C\# binary operations have a similar variation.  For instance
if \sphinxstyleemphasis{op} is \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{/}} or \sphinxcode{\sphinxupquote{\%}},
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{variable} \sphinxstyleemphasis{op}= \sphinxstyleemphasis{expression}
\end{quote}

\sphinxAtStartPar
means the same as
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{variable} = \sphinxstylestrong{variable} op \sphinxstyleemphasis{expression}
\end{quote}

\sphinxAtStartPar
For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
is the same as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\end{sphinxVerbatim}

\index{format@\spxentry{format}!field width and precision@\spxentry{field width and precision}}\index{field width formatting@\spxentry{field width formatting}}\index{precision@\spxentry{precision}!format@\spxentry{format}}\index{table formatting@\spxentry{table formatting}}\index{example@\spxentry{example}!power\_table.cs@\spxentry{power\_table.cs}}\index{power\_table.cs example@\spxentry{power\_table.cs example}}\index{right justification@\spxentry{right justification}}\index{justification@\spxentry{justification}!right@\spxentry{right}}\index{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}@\spxentry{\sphinxleftcurlybrace{} \sphinxrightcurlybrace{}}!format field width and precision@\spxentry{format field width and precision}}\ignorespaces 

\subsection{Tables}
\label{\detokenize{for/forexamples:tables}}\label{\detokenize{for/forexamples:index-1}}\label{\detokenize{for/forexamples:id1}}
\sphinxAtStartPar
Reports commonly include tables, often with successive lines generated by
a consistent formula.  As a simple first
table, we can show the square, cube, and square root of numbers 1 through 10.
The Math class has a function Sqrt, so we take the square root with Math.Sqrt
function.  The pattern is consistent, so we can loop easily:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{} \PYGZob{}3\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The numbers will be there, but the output is not pretty:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1 1 1 1
2 4 8 1.4142135623731
3 9 27 1.73205080756888
4 16 64 2
5 25 125 2.23606797749979
6 36 216 2.44948974278318
7 49 343 2.64575131106459
8 64 512 2.82842712474619
9 81 729 3
10 100 1000 3.16227766016838
\end{sphinxVerbatim}

\sphinxAtStartPar
First we might not need all those digits in the square root approximations.
We can replace \sphinxcode{\sphinxupquote{\{3\}}} by \sphinxcode{\sphinxupquote{\{3:F4\}}} to just show 4 decimal places.

\sphinxAtStartPar
We can adjust the spacing to make nice
columns by using a further formatting option.  The longest entries are all
in the last row, where they take up, 2, 3, 4, and 6 columns (for 3.1623).
Change the format string:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,2\PYGZcb{} \PYGZob{}1,3\PYGZcb{} \PYGZob{}2,4\PYGZcb{} \PYGZob{}3,6:F4\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                       }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and we generate the neater output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 1   1    1 1.0000
 2   4    8 1.4142
 3   9   27 1.7321
 4  16   64 2.0000
 5  25  125 2.2361
 6  36  216 2.4495
 7  49  343 2.6458
 8  64  512 2.8284
 9  81  729 3.0000
10 100 1000 3.1623
\end{sphinxVerbatim}

\sphinxAtStartPar
We are using two new formatting forms:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{\{}}index\sphinxcode{\sphinxupquote{,}}fieldWidth\sphinxcode{\sphinxupquote{\}}}  and
\item[] \sphinxcode{\sphinxupquote{\{}}index\sphinxcode{\sphinxupquote{,}}fieldWidth\sphinxcode{\sphinxupquote{:F}}\#\sphinxcode{\sphinxupquote{\}}}
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
where index, fieldWidth, and \# are replaces by specific literal integers.
The new part with the comma (not colon) and fieldWidth, sets the \sphinxstyleemphasis{minimum}
number of columns used for the substituted string, padding with blanks as needed.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
There is a \sphinxstyleemphasis{special} language for the
characters between the braces in a format string.
The rules are different than in regular C\# code, where
comma and colon are symbols,
and the parser allows \sphinxstyleemphasis{optional whitespace} around them.
This is \sphinxstyleemphasis{not} the case inside the braces of a format string:
There cannot be a space after the colon or before the comma.
Some blanks are legal; some blanks lead to exceptions being thrown,
and other positions for blanks
just silently give the wrong format.

\sphinxAtStartPar
The safest approach for a programmer is just to have
\sphinxstyleemphasis{no} blanks between the braces in a format string.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstyleemphasis{If the string to be inserted is wider than the fieldWidth,}
then the \sphinxstyleemphasis{whole} string is inserted, \sphinxstyleemphasis{ignoring} the fieldWidth.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}stuff\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}123456789\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,9\PYGZcb{}\PYGZbs{}n\PYGZob{}0,7\PYGZcb{}\PYGZbs{}n\PYGZob{}0,5\PYGZcb{}\PYGZbs{}n\PYGZob{}0,3\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
generates:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
123456789
    stuff
  stuff
stuff
stuff
\end{sphinxVerbatim}

\sphinxAtStartPar
filling 9, 7, and then 5 columns, by padding with 4, 2, and 0 blanks.
\sphinxstyleemphasis{The last line sticks out past the proposed 3\sphinxhyphen{}column fieldWidth.}

\sphinxAtStartPar
One more thing to add to our power table is a heading.  We might want:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
n   square    cube    root
\end{sphinxVerbatim}

\sphinxAtStartPar
To make the data line up with the heading titles,
we can expand the columns, with code in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/power\_table/power\_table.cs}{power\_table/power\_table.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,2\PYGZcb{}\PYGZob{}1,7\PYGZcb{}\PYGZob{}2,5\PYGZcb{}\PYGZob{}3,7\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}square\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}cube\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}root\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,2\PYGZcb{}\PYGZob{}1,7\PYGZcb{}\PYGZob{}2,5\PYGZcb{}\PYGZob{}3,7:F4\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
generating:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 n  square    cube    root
 1       1       1  1.0000
 2       4       8  1.4142
 3       9      27  1.7321
 4      16      64  2.0000
 5      25     125  2.2361
 6      36     216  2.4495
 7      49     343  2.6458
 8      64     512  2.8284
 9      81     729  3.0000
10     100    1000  3.1623
\end{sphinxVerbatim}

\sphinxAtStartPar
Note how we make sure the columns are consistent in the heading and further rows:
We used a format string for the headings with the same field widths as
in the body of the table. A separate variation: We also reduced the length
of the format string by putting all the substitution expressions in braces
right beside each other, and generate the space between columns with a
larger field width.

\index{left justification@\spxentry{left justification}}\index{format@\spxentry{format}!left justification@\spxentry{left justification}}\index{justification@\spxentry{justification}!left@\spxentry{left}}\ignorespaces \phantomsection\label{\detokenize{for/forexamples:left-justification}}
\sphinxAtStartPar
\sphinxstylestrong{Left Justification:}  Though our examples have always right justified in
a field (padding on the left), for completeness we note this alternative:
A minus sign in front of the fieldWidth
places the result left justified (padded on the right).
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}stuff\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}1234567890\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,\PYGZhy{}9\PYGZcb{}|\PYGZbs{}n\PYGZob{}0,\PYGZhy{}7\PYGZcb{}|\PYGZbs{}n\PYGZob{}0,\PYGZhy{}5\PYGZcb{}|\PYGZbs{}n\PYGZob{}0,\PYGZhy{}3\PYGZcb{}|\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
prints:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1234567890
stuff    |
stuff  |
stuff|
stuff|
\end{sphinxVerbatim}

\sphinxAtStartPar
where the ‘|’ appears after any blank padding in each line.

\index{ASCII example@\spxentry{ASCII example}}\index{example@\spxentry{example}!ASCII@\spxentry{ASCII}}\ignorespaces 

\subsection{ASCII Codes}
\label{\detokenize{for/forexamples:ascii-codes}}\label{\detokenize{for/forexamples:ascii}}\label{\detokenize{for/forexamples:index-3}}
\sphinxAtStartPar
Here is a reverse lookup from the
{\hyperref[\detokenize{foreach/foreachexamples:codeofstringchar}]{\sphinxcrossref{\DUrole{std,std-ref}{Numeric Code of String Characters}}}}:
Find the characters for a list of numeric codes. Just as we can cast a
\sphinxcode{\sphinxupquote{char}} to an \sphinxcode{\sphinxupquote{int}}, we can cast an \sphinxcode{\sphinxupquote{int}} 0\sphinxhyphen{}127 to a \sphinxcode{\sphinxupquote{char}}.

\sphinxAtStartPar
The Unicode used
by C\# is an extension of the ASCII codes corresponding to the
characters on a US keyboard.  The codes were originally
used to drive printers,
and the first 32 codes are non\sphinxhyphen{}printable instructions to the printer.
Characters 32 \sphinxhyphen{} 126 yield the 95 characters on a standard US keyboard.

\sphinxAtStartPar
A loop to print each code followed by a space and the corresponding
printable character
would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{32}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{127}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,3\PYGZcb{} \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To make all the character line up we added a field width 3 for the code column.

\sphinxAtStartPar
If you run  this in csharp,
the first line printed does not appear to have a character:  That is the
blank character.  All the other characters are visible.

\sphinxAtStartPar
Let us make a more concise table, putting 8 entries per line.
We can print successive parts using \sphinxcode{\sphinxupquote{Write}} instead of \sphinxcode{\sphinxupquote{WriteLine}},
but we still need to advance to the next line after every 8th
entry, for codes 39, 47, 55, ….
Since they are 8 apart, their remainder when divided by 8 is always
the same:
\begin{quote}

\sphinxAtStartPar
7 = 39 \% 8 = 47 \% 8 = 55 \% 8 = ….
\end{quote}

\sphinxAtStartPar
We can add a newline after each of these is printed.  This requires a test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{32}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{127}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0,3\PYGZcb{} \PYGZob{}1\PYGZcb{}  \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{8}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Recall that \sphinxcode{\sphinxupquote{Console.WriteLine()}}
with no parameters \sphinxstyleemphasis{only} advances to the next line.

\sphinxAtStartPar
Paste that whole code at once into csharp to see the result.

\sphinxAtStartPar
The next csharp\textgreater{} prompt appears right after \sphinxcode{\sphinxupquote{126 \textasciitilde{}}}.
There is no eighth entry on the last line, and hence no advance to the
next line.  A program printing this table should include an extra
\sphinxcode{\sphinxupquote{Console.WriteLine()}} after the loop.

\index{example@\spxentry{example}!mod\_mult\_table.cs@\spxentry{mod\_mult\_table.cs}}\index{mod\_mult\_table.cs example@\spxentry{mod\_mult\_table.cs example}}\index{nested loop@\spxentry{nested loop}!table@\spxentry{table}}\ignorespaces 

\subsection{Modular Multiplication Table}
\label{\detokenize{for/forexamples:modular-multiplication-table}}\label{\detokenize{for/forexamples:modular-mult-table}}\label{\detokenize{for/forexamples:index-4}}
\sphinxAtStartPar
We have introduced the remainder operator \sphinxcode{\sphinxupquote{\%}} and mentioned that the corresponding
mathematical term is “mod”.  We can extend that to the idea of modular arithmetic
systems.  For example, if we only look at remainders mod 7, we can just consider
numbers 0, 1, 2, 3, 4, 5, and 6.  We can do multiplication and addition and take
remainders mod 7 to get answers in the same range.  For example 3 * 5 mod 7
is \sphinxcode{\sphinxupquote{(3 * 5) \% 7}} in C\#, which is 1.  As we look more at this system, we will
observe and explain more properties.

\sphinxAtStartPar
The next example is to make a table of multiplication, mod 7, and later generalize.

\sphinxAtStartPar
Tables generally have row and column labels.  We can aim for something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{6}
\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}
\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{6}
\PYG{l+m}{2}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{5}
\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{4}
\PYG{l+m}{4}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{5}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{2}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The border labels make the table much more readable, but let us start simpler,
with just the modular multiplications:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{6}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{5}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{4}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{3}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{2}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is more complicated in some respects than our previous table, so start slow,
with some pseudocode.  We need a row for each number 0\sphinxhyphen{}6, and so a \sphinxcode{\sphinxupquote{for}} loop
suggests itself:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{print}\PYG{+w}{ }\PYG{n}{row}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each individual row also involves a repeated pattern:
calculate for the next number.  We can name the second number c for column.  The
next revision replaces “print row” by a loop:  a \sphinxstyleemphasis{nested} loop, inside the loop for
separate rows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{n}{print}\PYG{+w}{ }\PYG{n}{modular}\PYG{+w}{ }\PYG{n}{multiple}\PYG{+w}{ }\PYG{k}{on}\PYG{+w}{ }\PYG{n}{same}\PYG{+w}{ }\PYG{n}{line}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and the modular multiplication is just regular multiplication followed by
taking the remainder mod 7, so you might come up with the C\# code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can test this in csharp, and see it is not quite right!
Chopped\sphinxhyphen{}off output starts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }\PYG{l+m}{0.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Though we want each entry in a row on the same line, we need to go down to the
next line at the end of each line!  Where do we put in the newline in the code?
A line is \sphinxstyleemphasis{all} the modular products by r, \sphinxstyleemphasis{followed} by \sphinxstyleemphasis{one} newline.
Each modular product for a row is printed in the inner \sphinxcode{\sphinxupquote{for}} loop.  We want to
advance \sphinxstyleemphasis{after} that, so the newline must be inserted \sphinxstyleemphasis{outside the inner loop}.
On the other hand we do want it done for \sphinxstyleemphasis{each} row, so it must be
\sphinxstyleemphasis{inside the outer loop}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can copy and test that code in csharp, and it works!

\sphinxAtStartPar
It is important to be able to play computer on nested loops and follow execution,
statement by statement.  Look more closely at the code above,
noting the added line numbers.
The basic pattern \sphinxstyleemphasis{is} sequential:  \sphinxstyleemphasis{Complete} one statement before going on to the next.
\sphinxstyleemphasis{Inside} the execution of a looping statement, there are extra rules, for testing and
looping through the whole body.  Within a loop body, each \sphinxstyleemphasis{complete}
statement is executed sequentially.

\sphinxAtStartPar
Most new students can get successfully to line 4:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
r
&\sphinxstyletheadfamily 
\sphinxAtStartPar
c
&\sphinxstyletheadfamily 
\sphinxAtStartPar
modProd
&\sphinxstyletheadfamily 
\sphinxAtStartPar
comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
initialize outer loop
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
initialize inner loop
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Write 0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
After reaching the bottom of the loop, where do you go?
You finish the \sphinxstyleemphasis{innermost} enclosing statement.
You are in the inner loop, so the next line is the \sphinxstyleemphasis{inner} loop heading
where you increment c and continue with the loop since 1 \textless{} 7.  This
inner loop continues until you reach the bottom of the inner loop,
line 4, with c = 6, and return to the heading, line 2, and the test fails,
finishing the inner row loop:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
r
&\sphinxstyletheadfamily 
\sphinxAtStartPar
c
&\sphinxstyletheadfamily 
\sphinxAtStartPar
modProd
&\sphinxstyletheadfamily 
\sphinxAtStartPar
comment
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
initialize outer loop
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
0 \textless{} 7, enter loop body
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
(0*0)\%7
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Write 0
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
c=0+1=1,  1 \textless{} 7: true
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
(0*1)\%7
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Write 0
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
c=1+1=2,  2 \textless{} 7: true
\\
\hline
\sphinxAtStartPar
…
&&&&
\sphinxAtStartPar
… through c = 6
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Write 0
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
c=+1=7,  7 \textless{} 7: false
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
At this point the inner loop statement, lines 2\sphinxhyphen{}4, has completed,
and you continue.  You go on to the next statement in the
same sequential chuck as the inner loop statement in lines 2\sphinxhyphen{}4:
That sequential chunk is the the outer loop body, lines 2\sphinxhyphen{}6.
The next statement is line 6, advancing printing to the next line.
That is the last statement of the outer loop, so you
return to the heading of the outer loop and modify its loop
variable r.  The two lines just described are:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
line
&\sphinxstyletheadfamily 
\sphinxAtStartPar
r
&\sphinxstyletheadfamily 
\sphinxAtStartPar
c
&\sphinxstyletheadfamily 
\sphinxAtStartPar
modProd
&\sphinxstyletheadfamily 
\sphinxAtStartPar
comment
\\
\hline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
print a newline
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
r=s0+1=1, 1 \textless{} 7 enter outer loop
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
Then you go all the way through the inner loop again,
for all columns, with c going from 0 through 6, and exit at c=7,
finish the body of the outer loop by advancing to a new print line,
and return to the outer loop heading, setting r = 2…, until
all rows are completed.

\sphinxAtStartPar
The common error here is to forget what loop is the innermost one
that you are working on, and exit that loop before is is totally finished:
It finishes when the test of the condition controlling the loop becomes false.

\sphinxAtStartPar
Look back one more time and make sure the code for this \sphinxstyleemphasis{simpler} table makes
sense before we continue to the one with labels….

\sphinxAtStartPar
The fancier table has a couple of extra rows at the top.  These two rows
are unlike the remaining rows in the body of the table, so they need special code.

\sphinxAtStartPar
If we go back to our pseudocode we could add to it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{print}\PYG{+w}{ }\PYG{n}{heading}\PYG{+w}{ }\PYG{n}{row}
\PYG{n}{print}\PYG{+w}{ }\PYG{n}{dash}\PYG{o}{\PYGZhy{}}\PYG{n}{row}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{print}\PYG{+w}{ }\PYG{n}{body}\PYG{+w}{ }\PYG{n}{row}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
First analyze the heading row:  Some parts are repetitive and
some are not: Print \sphinxcode{\sphinxupquote{"* |"}} once, and then there is a repetitive pattern printing
0 \sphinxhyphen{} 6, which we can do with a simpler loop than in the table body:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}* | \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The dashed line can be generated using \sphinxcode{\sphinxupquote{StringOfReps}} from
{\hyperref[\detokenize{for/lab-nested-loops:lab-loops}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab: Loops}}}}.  How many dashes?  A digit and a space for each of
seven columns and for a row header,
so we need
(7+1)*(1+1) characters, plus one for the ‘|’:  1 + (7+1)*(1+1).
Thinking ahead, we will leave that expression unsimplified.

\sphinxAtStartPar
We have done most of the work for the rows of the body of the table in the simpler
version.  We just
have a bit of printing for the initial row label.
Where does the code go?  It is repeated for each row, so it is inside
the outer loop, but it is just printed once per row, so it comes \sphinxstyleemphasis{before} the
inner column loop.  The row label is r.
The whole code is in example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/mod7\_table/mod7\_table.cs}{mod7\_table/mod7\_table.cs} and below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//heading}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}* | \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//column headings}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{StringOfReps}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{7}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m}{1}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{     }\PYG{c+c1}{// table body}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{r}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} | \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{// row heading}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// data columns}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{modProd}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Besides the 0 row and 0 column in the mod 7 table,
note that in each line the products are a permutation of all the numbers 1\sphinxhyphen{}6.
That means it is
possible to define the \sphinxstyleemphasis{inverse} of the multiplication operation, and mod 7 arithmetic
actually forms a mathematical \sphinxstyleemphasis{field}.
Modular arithmetic (with much larger moduli!) is extremely important in
\sphinxstyleemphasis{public key cryptography}, which
protects all your online financial transactions….
Knowing a lot more math is useful!
(But it is not required for this course.)

\sphinxAtStartPar
The inverse operation to multiplication for prime moduli is
easy to work out by brute force, going through the row of products.
A much more efficient
method is needed for cryptography:  That method involves
an elaboration of {\hyperref[\detokenize{while/gcdexamples:gcd}]{\sphinxcrossref{\DUrole{std,std-ref}{Greatest Common Divisor}}}}.

\sphinxAtStartPar
Finally, let us generalize this table to mod n.  With n up to about 25,
it is reasonable to print.
Most of the changes are just replacing 7 by n.
There is a further complication
with column width, since the numbers can be more than one digit long.
We can do formatting with a field width.
Unfortunately in C\# the field width must be a \sphinxstyleemphasis{literal}
integer embedded in the format string,
but our number of digits in n is \sphinxstyleemphasis{variable}.

\sphinxAtStartPar
Here is a good trick:  Construct the format string inside the program.
To get the format for a
number and an extra space
mod 7, we want format string “\{0,1\} “, but for mod 11, we want “\{0,2\} “.
This 1 or 2 is the number of characters in n as a string,
given by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{numberWidth}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can create the format string
with a string concatenation expression:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{colFormat}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZob{}0,\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{numberWidth}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZcb{}\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or use
\sphinxstyleemphasis{another} format string and substitution.  This is an excuse to
illustrate including explicit braces (for the main format string).
Recall the explicit braces are doubled.  Check out this version:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{colFormat}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}\PYGZob{}0,\PYGZob{}0\PYGZcb{}\PYGZcb{}\PYGZcb{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{numberWidth}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
which we use in the code for the whole function, below,
and in example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/mod\_mult\_table/mod\_mult\_table.cs}{mod\_mult\_table/mod\_mult\_table.cs}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print a table for modular multiplication mod n.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{MultTable}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{numberWidth}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{colFormat}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}\PYGZob{}0,\PYGZob{}0\PYGZcb{}\PYGZcb{}\PYGZcb{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{numberWidth}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{rowHeaderFormat}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{colFormat}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}| \PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{rowHeaderFormat}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}*\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// start main heading}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{colFormat}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{StringOfReps}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{numberWidth}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{//rows of table body}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{rowHeaderFormat}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{colFormat}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{string@\spxentry{string}!reverse@\spxentry{reverse}}\index{reverse string example;@\spxentry{reverse string example;}}\ignorespaces 

\subsection{Reversed String Returned}
\label{\detokenize{for/forexamples:reversed-string-returned}}\label{\detokenize{for/forexamples:reverse-string-returned}}\label{\detokenize{for/forexamples:index-5}}
\sphinxAtStartPar
In {\hyperref[\detokenize{while/while-with-sequence:reversed-print-example}]{\sphinxcrossref{\DUrole{std,std-ref}{String Backwards Exercise/Example}}}} we discuss iterating through a string’s
indices and characters to print the string reversed.  That might be useful,
but it logically the joining of two separate ideas:  reversing a string and
printing it.  We already know how to print a string as a step.  Now consider
the first part as its own function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return s in reverse order.}
\PYG{+w}{      }\PYG{c+c1}{/// If s is \PYGZdq{}drab\PYGZdq{}, return \PYGZdq{}bard\PYGZdq{}.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{Reverse}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To go along with this chapter, we will use a \sphinxcode{\sphinxupquote{for}} loop heading rather
a \sphinxcode{\sphinxupquote{while}} loop as in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/reversed\_print/reversed\_print.cs}{reversed\_print/reversed\_print.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A more significant difference is that in
the previous example we immediately printed,
individually, each letter that we wanted.  Now we need to create a single
string, with all the characters, before returning the result.

\sphinxAtStartPar
Let us think of the example in the documentation:  If we start with
\sphinxcode{\sphinxupquote{s}} as \sphinxcode{\sphinxupquote{"drab"}}, and we go through the letters one at a time in
reverse order, b a r d, we build up successively:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
b
ba
bar
bard
\end{sphinxVerbatim}

\sphinxAtStartPar
We need a loop with variables and operations.  The sequence
of reversed letters, \sphinxcode{\sphinxupquote{s{[}i{]}}}, are the
last character on the end of each line above.

\sphinxAtStartPar
At least lines after the first are constructed from previous parts,
so, for instance,  \sphinxcode{\sphinxupquote{"bar"}}  comes from combining the initial part \sphinxcode{\sphinxupquote{"ba"}}
with the latest character \sphinxcode{\sphinxupquote{\textquotesingle{}r\textquotesingle{}}} (\sphinxcode{\sphinxupquote{s{[}i{]}}}).
We need a name for the initial part.
I used the name \sphinxcode{\sphinxupquote{rev}}.
Combining with a string is done with the \sphinxcode{\sphinxupquote{+}} operator.
Then when \sphinxcode{\sphinxupquote{rev}} is \sphinxcode{\sphinxupquote{"ba"}} and \sphinxcode{\sphinxupquote{s{[}i{]}}} is \sphinxcode{\sphinxupquote{\textquotesingle{}r\textquotesingle{}}}, the combination,
using the variable names, is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
We want this in our loop, so we must be able to use
that expression \sphinxstyleemphasis{each} time through the loop,
so \sphinxcode{\sphinxupquote{rev}}  changes each time through the loop.  In the next iteration \sphinxcode{\sphinxupquote{rev}}
is the \sphinxstyleemphasis{result} of the previous expression.  The assignment statement
to give us the next version of \sphinxcode{\sphinxupquote{rev}} can just be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
That gives us the general rule.  Pay attention now to the beginning and end:
The end is simple:  The last value for \sphinxcode{\sphinxupquote{rev}} is the complete reversed string,
so that is what we return.

\sphinxAtStartPar
How do we initialize \sphinxcode{\sphinxupquote{rev}}?  You could imagine \sphinxcode{\sphinxupquote{rev}} starting as \sphinxcode{\sphinxupquote{"b"}},
but the the first character that we add is \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}}, and we would not be going
through all the characters in our loop.  It is better to go all the way
back to the beginning:  If we use the general form with the first letter in the
reversed sequence,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then the result of the initial \sphinxcode{\sphinxupquote{rev}} +  \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}} should just be \sphinxcode{\sphinxupquote{"b"}}.
So what would \sphinxcode{\sphinxupquote{rev}} be?

\sphinxAtStartPar
Remember the empty string:  initialize \sphinxcode{\sphinxupquote{rev}} to be \sphinxcode{\sphinxupquote{""}}.

\sphinxAtStartPar
The result is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return s in reverse order.}
\PYG{c+c1}{/// If s is \PYGZdq{}drab\PYGZdq{}, return \PYGZdq{}bard\PYGZdq{}.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{Reverse}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{rev}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{rev}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We used our new operator \sphinxcode{\sphinxupquote{+=}} to be more concise.

\sphinxAtStartPar
This function and a \sphinxcode{\sphinxupquote{Main}} used to demonstrate it are in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/reversed\_string/reversed\_string.cs}{reversed\_string/reversed\_string.cs}.


\subsection{Exercises}
\label{\detokenize{for/forexamples:exercises}}
\index{Random@\spxentry{Random}!static variable@\spxentry{static variable}}\ignorespaces 
\index{Random@\spxentry{Random}!heads or tails exercise@\spxentry{heads or tails exercise}}\index{exercise@\spxentry{exercise}!heads or tails@\spxentry{heads or tails}}\index{heads or tails exercise@\spxentry{heads or tails exercise}}\ignorespaces 

\subsubsection{Head or Tails Exercise}
\label{\detokenize{for/forexamples:head-or-tails-exercise}}\label{\detokenize{for/forexamples:head-tails-exercise}}\label{\detokenize{for/forexamples:index-7}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{heads\_tails.cs}}. It should include a function \sphinxcode{\sphinxupquote{Flip()}},
that will just randomly print \sphinxcode{\sphinxupquote{Heads}} or \sphinxcode{\sphinxupquote{Tails}} \sphinxstyleemphasis{once}.
Accomplish this by choosing 0 or 1 arbitrarily with a random
number generator.  More details follow.

\sphinxAtStartPar
Use a \sphinxcode{\sphinxupquote{Random}} object, as in {\hyperref[\detokenize{while/lab-number-game:lab-number-game}]{\sphinxcrossref{\DUrole{std,std-ref}{Number Guessing Game Lab}}}}, \sphinxstyleemphasis{except} this time it is
important \sphinxstyleemphasis{not} to make the \sphinxcode{\sphinxupquote{Random}} object be a local variable inside
the \sphinxcode{\sphinxupquote{Flip}} function:  A new \sphinxcode{\sphinxupquote{Random}} object in likely
initialized using the current time.  The \sphinxcode{\sphinxupquote{Flip}} function has no interaction
with the user,
so it can be repeated very quickly, and new \sphinxcode{\sphinxupquote{Random}} objects
may not register a new value
through several reruns of \sphinxcode{\sphinxupquote{Flip}}.  This would give the same answer,
and be completely contrary to the idea of random results!

\sphinxAtStartPar
Hence it is generally a good idea to only create a single \sphinxcode{\sphinxupquote{Random}} object
that stays in scope for the whole program.
One way to do that is to make it \sphinxstyleemphasis{static}.  Place the declaration

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Random}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
inside your class but outside of any function, positioned like
the static constants discussed in {\hyperref[\detokenize{functions/staticvariables:static-variables}]{\sphinxcrossref{\DUrole{std,std-ref}{Static Variables}}}}.

\sphinxAtStartPar
Then you can use \sphinxcode{\sphinxupquote{r}} in any function in your class.
For \sphinxcode{\sphinxupquote{int}} variables \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{higher}}, with \sphinxcode{\sphinxupquote{low \textless{} higher}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{n}{low}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{higher}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
returns a (pseudo) random \sphinxcode{\sphinxupquote{int}}, satisfying \sphinxcode{\sphinxupquote{low \textless{}= n \textless{} higher}}.
If you select \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{higher}} as 0 and 2,
so there are only two possible values for n,
then you can choose to print \sphinxcode{\sphinxupquote{Heads}} or \sphinxcode{\sphinxupquote{Tails}} with an
\sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} statement based on the result.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
We have discovered some problems with the \sphinxcode{\sphinxupquote{Next()}} implementation
when running on Mono that sometimes results in random values not
being generated. This is likely a bug that will be fixed. If you
experience any problems with \sphinxcode{\sphinxupquote{Next()}}, the following is for you!
\end{sphinxadmonition}

\sphinxAtStartPar
An alternative to generating random 0 and 1 values for heads and tails
is to generate random double\sphinxhyphen{}precision values. Using the same
variable, \sphinxcode{\sphinxupquote{r}}, you can call \sphinxcode{\sphinxupquote{r.NextDouble()}} to get a random value
between 0 and 1. You can consider any generated value \(n < 0.5\) to
be heads; \(n >= 0.5\) represents tails:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{NextDouble}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0.5}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{c+c1}{// heads}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{c+c1}{// tails}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In your \sphinxcode{\sphinxupquote{Main}} method have a \sphinxcode{\sphinxupquote{for}} loop calling  \sphinxcode{\sphinxupquote{Flip()}}
10 times to test it, so you generate a random sequence of
10 heads and/or tails.  With these 10 rapid calls, it is important
that a new Random object is only created once.  The suggested static
variable declaration ensures that.

\index{exercise@\spxentry{exercise}!GroupFlips@\spxentry{GroupFlips}}\ignorespaces 

\subsubsection{Group Flips Exercise}
\label{\detokenize{for/forexamples:group-flips-exercise}}\label{\detokenize{for/forexamples:index-8}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{format\_flips.cs}}. It should include the function \sphinxcode{\sphinxupquote{Flip()}}
and the \sphinxcode{\sphinxupquote{static}} \sphinxcode{\sphinxupquote{Random}} declaration
from the last exercise.  Also include another function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print out the results from the total number of random flips of a coin.}
\PYG{c+c1}{/// Group them groupSize per line, each followed by a space.}
\PYG{c+c1}{/// The last line may contain fewer than groupSize flips}
\PYG{c+c1}{/// if total is not a multiple of groupSize.  The last line}
\PYG{c+c1}{/// should be followed by exactly one newline in all cases.}
\PYG{c+c1}{/// For example, GroupFlips(10, 4) *could* produce:}
\PYG{c+c1}{///   Heads Heads Tails Heads}
\PYG{c+c1}{///   Heads Tails Heads Tails}
\PYG{c+c1}{///   Tails Tails}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{GroupFlips}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{total}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{groupSize}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Complete this function definition and test
with a variety of calls to \sphinxcode{\sphinxupquote{GroupFlips}} in \sphinxcode{\sphinxupquote{Main}}.
The output from the previous exercise would be produced by the call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GroupFlips}\PYG{p}{(}\PYG{l+m}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!reverse string foreach@\spxentry{reverse string foreach}}\ignorespaces 

\subsubsection{Reverse String \sphinxstyleliteralintitle{\sphinxupquote{foreach}} Exercise}
\label{\detokenize{for/forexamples:reverse-string-foreach-exercise}}\label{\detokenize{for/forexamples:reverse-string-foreach}}\label{\detokenize{for/forexamples:index-9}}
\sphinxAtStartPar
We already have discussed {\hyperref[\detokenize{for/forexamples:reverse-string-returned}]{\sphinxcrossref{\DUrole{std,std-ref}{Reversed String Returned}}}}.
It used a \sphinxcode{\sphinxupquote{for}} loop to go through the characters in
reverse order.  Write a version with the only loop heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{ch}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and no reference to indices in s.

\index{exercise@\spxentry{exercise}!only letters@\spxentry{only letters}}\index{only letters exercise;@\spxentry{only letters exercise;}}\ignorespaces 

\subsubsection{Only Letters Exercise}
\label{\detokenize{for/forexamples:only-letters-exercise}}\label{\detokenize{for/forexamples:only-letters-ex}}\label{\detokenize{for/forexamples:index-10}}
\sphinxAtStartPar
Write a program that defines and tests a function with
description and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return s with all non\PYGZhy{}letters removed.}
\PYG{c+c1}{/// For example OnlyLetters(\PYGZdq{}Hello, World!\PYGZdq{}) returns \PYGZdq{}HelloWorld\PYGZdq{}.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{OnlyLetters}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Assume the English alphabet.

\index{exercise@\spxentry{exercise}!palindrome@\spxentry{palindrome}}\index{palindrome exercise;@\spxentry{palindrome exercise;}}\ignorespaces 

\subsubsection{Palindrome Exercise}
\label{\detokenize{for/forexamples:palindrome-exercise}}\label{\detokenize{for/forexamples:palindrome-ex}}\label{\detokenize{for/forexamples:index-11}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{palindrome.cs}} that defines and tests a function with
description and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return true when s is a palindrome.}
\PYG{c+c1}{/// For example IsPalindrome(\PYGZdq{}A Toyota!\PYGZdq{}) returns true.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsPalindrome}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
A palindrome is a string that contains the same sequence of letters,
ignoring capitalization, forward and backward.  Non\sphinxhyphen{}letters are ignored.
Examples are “Madam, I’m Adam.” and “Able was I ‘ere I saw Elba.”

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsPalindrome}} can be written very concisely by copying and using
functions from previous exercises.

\index{exercise@\spxentry{exercise}!nested play computer@\spxentry{nested play computer}}\ignorespaces 

\subsubsection{Nested Play Computer Exercise}
\label{\detokenize{for/forexamples:nested-play-computer-exercise}}\label{\detokenize{for/forexamples:index-12}}
\sphinxAtStartPar
Predict what these code fragments print.  Then check yourself in csharp:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}abcdef\PYGZdq{}}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!power table@\spxentry{power table}}\ignorespaces 

\subsubsection{Power Table Exercise}
\label{\detokenize{for/forexamples:power-table-exercise}}\label{\detokenize{for/forexamples:index-13}}\label{\detokenize{for/forexamples:id2}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{power\_table.cs}} that completes and tests
the function with this heading.  Be sure your program tests
with several values for each parameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print a table of powers of positive integers.}
\PYG{c+c1}{/// Assume 1 \PYGZlt{}= nMax \PYGZlt{}= 12, 1 \PYGZlt{}= powerMax \PYGZlt{}= 7.}
\PYG{c+c1}{/// Example: output of PowerTable(3, 4)}
\PYG{c+c1}{///       n\PYGZca{}1       n\PYGZca{}2      n\PYGZca{}3      n\PYGZca{}4}
\PYG{c+c1}{///         1         1        1        1}
\PYG{c+c1}{///         2         4        8       16}
\PYG{c+c1}{///         3         9       27       81}
\PYG{c+c1}{///}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PowerTable}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nMax}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{powerMax}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Make sure the table always ends up with right\sphinxhyphen{}justified columns.

\item {} 
\sphinxAtStartPar
Make the table have columns all the same width, but
make the width be as small as possible for the parameters
provided, leaving a minimal one space (but not less!) between columns
somewhere in the table. Consider heading widths, too.

\end{enumerate}

\sphinxstepscope

\index{labs@\spxentry{labs}!loops@\spxentry{loops}}\ignorespaces 

\section{Lab: Loops}
\label{\detokenize{for/lab-nested-loops:lab-loops}}\label{\detokenize{for/lab-nested-loops:index-0}}\label{\detokenize{for/lab-nested-loops:id1}}\label{\detokenize{for/lab-nested-loops::doc}}
\sphinxAtStartPar
Goals for this lab:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Practice with loops.  You are encouraged to use a \sphinxcode{\sphinxupquote{for}} loop where appropriate.

\item {} 
\sphinxAtStartPar
Use nested loops where appropriate.

\end{itemize}

\sphinxAtStartPar
Copy example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/loop\_lab\_stub/loop\_lab.cs}{loop\_lab\_stub/loop\_lab.cs} to a new project of yours,
and fill in function bodies for each part below:

\index{PrintReps@\spxentry{PrintReps}}\ignorespaces \begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Complete

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print n copies of s, end to end.}
\PYG{c+c1}{/// For example PrintReps(\PYGZdq{}Ok\PYGZdq{}, 9) prints: OkOkOkOkOkOkOkOkOk}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintReps}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Hint:  How would you do something like the example
\sphinxcode{\sphinxupquote{PrintReps("Ok", 9)}} or with a higher count by hand?
Probably count under your breath as you write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 1 2 3 4 5 6 7 8 9
OkOkOkOkOkOkOkOkOk
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a counting loop.

\index{StringOfReps@\spxentry{StringOfReps}}\ignorespaces 
\item {} 
\sphinxAtStartPar
Complete

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a string containing n copies of s, end to end.}
\PYG{c+c1}{/// For example StringOfReps(\PYGZdq{}Ok\PYGZdq{}, 9) returns: \PYGZdq{}OkOkOkOkOkOkOkOkOk\PYGZdq{}}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{StringOfReps}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the distinction from the previous part:  Here the function prints nothing.
Its work is \sphinxstyleemphasis{returned} as a single string.  You have to build up the final
string.

\index{Factorial@\spxentry{Factorial}}\ignorespaces 
\item {} 
\sphinxAtStartPar
Complete \sphinxcode{\sphinxupquote{Factorial}}, in a format much like SumToN in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_to\_n\_test/sum\_to\_n\_test.cs}{sum\_to\_n\_test/sum\_to\_n\_test.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return n! (n factorial: 1*2*3 *...* n if n \PYGZgt{}=1;}
\PYG{c+c1}{/// 0! is 1.).  For example Factorial(4) returns 1*2*3*4 = 24.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Factorial}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is useful to think of the sequence of steps to calculate a
concrete example of a factorial, say 6!:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Start with 1
2 *1 = 2
3*2 = 6
4 * 6 = 24
5*24 = 120
6*120 = 720
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{ALSO} find the largest value of \sphinxcode{\sphinxupquote{n}} for which the function works.
(You might want to add a bit of code further testing Factorial,
to make this easier.)  Caution:  although a negative result from the
product of two positive numbers is clearly wrong, only half of the
allowed values are negative, so the first wrong answer could equally well
be positive.

\item {} 
\sphinxAtStartPar
Modify the function to return a \sphinxcode{\sphinxupquote{long}}.
Then what is the largest value of \sphinxcode{\sphinxupquote{n}} for which the function works?

\sphinxAtStartPar
\sphinxstyleemphasis{Remember the values from this part and the previous part}
\sphinxstyleemphasis{to tell the TA’s checking out your work.}

\index{PrintRectangle@\spxentry{PrintRectangle}}\ignorespaces 
\item {} 
\sphinxAtStartPar
Complete the method

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Print a filled rectange, where the filling is}
\PYG{c+c1}{// the specified number of columns and rows of the character inChar,}
\PYG{c+c1}{// surrounded by a border made of the character edgeChar.}
\PYG{c+c1}{// For example printRectangle(3, 2, \PYGZsq{}i\PYGZsq{}, \PYGZsq{}e\PYGZsq{}) prints}
\PYG{c+c1}{//    eeeee}
\PYG{c+c1}{//    eiiie}
\PYG{c+c1}{//    eiiie}
\PYG{c+c1}{//    eeeee}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintRectangle}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{columns}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{rows}\PYG{p}{,}
\PYG{+w}{                           }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{inChar}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{edgeChar}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are further examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PrintRectangle}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{} \PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}B\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PrintRectangle}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}+\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would print

\begin{sphinxVerbatim}[commandchars=\\\{\}]
BBBBBBB
B     B
BBBBBBB
++
++
++
++
\end{sphinxVerbatim}

\sphinxAtStartPar
Suggestion:  You are always encouraged to build up to a complicated solution
incrementally.
You might start by just creating the inner rectangle, without the border.

\item {} 
\sphinxAtStartPar
Complete the method below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print the borders of the cells of a table.}
\PYG{c+c1}{/// The borders divide the table into rows and columns.}
\PYG{c+c1}{/// The blank space within a cell is width characters wide}
\PYG{c+c1}{/// and continues down for height lines.}
\PYG{c+c1}{/// The horizontal borders are dashes \PYGZsq{}\PYGZhy{}\PYGZsq{} and the vertical borders}
\PYG{c+c1}{/// are vertical bars, \PYGZsq{}|\PYGZsq{}, except that all intersections are \PYGZsq{}+\PYGZsq{}.}
\PYG{c+c1}{/// For example PrintTableBorders(3, 2, 4, 1) prints}
\PYG{c+c1}{///    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{///    |    |    |    |}
\PYG{c+c1}{///    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{///    |    |    |    |}
\PYG{c+c1}{///    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintTableBorders}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{columns}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{rows}\PYG{p}{,}
\PYG{+w}{                              }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is further example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PrintTableBorders}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would print (with actual vertical bars)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|      |      |
|      |      |
|      |      |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}

\sphinxAtStartPar
You can do this with lots of nested loops,
or much more simply you can use \sphinxcode{\sphinxupquote{StringOfReps}}, possibly six times
in several assignment statements,
and print a single string.  Think of larger and larger building blocks.

\sphinxAtStartPar
The source of this book is plain text where some of the tables are laid out
in a format similar to the output of this function.  The Emacs editor
has a mode that maintains
a fancier related setup on the screen, on the fly,
as content is added inside the cells!

\end{enumerate}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{for/reviewfor:chapter-review-questions}}\label{\detokenize{for/reviewfor::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
When might you prefer a \sphinxcode{\sphinxupquote{for}} loop in place of a \sphinxcode{\sphinxupquote{while}} loop?
What do you gain?

\item {} 
\sphinxAtStartPar
When might you prefer a \sphinxcode{\sphinxupquote{while}} loop or a \sphinxcode{\sphinxupquote{foreach}} instead of
a \sphinxcode{\sphinxupquote{for}} loop?

\item {} 
\sphinxAtStartPar
When you have nested \sphinxcode{\sphinxupquote{for}} loops, and you reach the bottom of the \sphinxstyleemphasis{body} of the
\sphinxstyleemphasis{inner} loop, where does execution go next?

\item {} 
\sphinxAtStartPar
May you legally omit the initialization part of a \sphinxcode{\sphinxupquote{for}} loop?

\item {} 
\sphinxAtStartPar
What happens when you omit the condition in a \sphinxcode{\sphinxupquote{for}} loop?

\item {} 
\sphinxAtStartPar
In the heading of a \sphinxcode{\sphinxupquote{for}} loop, how do you initialize or update
several variables?

\item {} 
\sphinxAtStartPar
Rewrite

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{/=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
equivalently without the operand \sphinxcode{\sphinxupquote{/=}}.

\item {} 
\sphinxAtStartPar
Rewrite

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bigName}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{bigName}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
with a statement that only includes \sphinxcode{\sphinxupquote{bigName}} once.

\item {} 
\sphinxAtStartPar
Distinguish the effects of these two statements:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{o}{\PYGZhy{}=}\PYG{l+m}{2}\PYG{p}{;}

\PYG{n}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}12345678\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{p}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{formatStr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZob{}0:F\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZcb{}\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{formatStr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1.2345678}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed?  (Just “,4” has been inserted.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}12345678\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{p}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{formatStr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZob{}0,4:F\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZcb{}\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{formatStr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1.2345678}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}123456\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{6}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{\PYGZhy{}=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{formatStr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZob{}0,\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZcb{}|\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{formatStr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}here\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{file@\spxentry{file}}\ignorespaces 

\chapter{Files, Paths, and Directories}
\label{\detokenize{files/files:files-paths-and-directories}}\label{\detokenize{files/files:files}}\label{\detokenize{files/files:index-0}}\label{\detokenize{files/files::doc}}
\sphinxstepscope

\index{file (StreamWriter)@\spxentry{file}\spxextra{StreamWriter}!stream abstraction@\spxentry{stream abstraction}}\index{stream@\spxentry{stream}}\ignorespaces 

\section{Files As Streams}
\label{\detokenize{files/fileabstraction:files-as-streams}}\label{\detokenize{files/fileabstraction:fileabstraction}}\label{\detokenize{files/fileabstraction:index-0}}\label{\detokenize{files/fileabstraction::doc}}
\sphinxAtStartPar
Thus far you have been able to save programs, but anything produced
during the execution of a program has been lost when the program
ends. Data has not \sphinxstyleemphasis{persisted} past the end of execution. Just as
programs live on in files, you can generate and read data files in
C\# that persist after your program has finished running.

\sphinxAtStartPar
As far as C\# is concerned, a file is just a string (often very
large!) stored on your file system, that you can read or write,
gradually, line by line, or all together.

\sphinxAtStartPar
C\# has the abstraction of a \sphinxstyleemphasis{stream},
as a sequence of characters to be processed sequentially.
A stream can either be written sequentially or read sequentially.
You have already read and written streams of
characters to the Console.  Most of the syntax that we use for files will be very similar,
using methods \sphinxcode{\sphinxupquote{ReadLine}}, \sphinxcode{\sphinxupquote{WriteLine}}, and \sphinxcode{\sphinxupquote{Write}} in the same way you
used them for the \sphinxcode{\sphinxupquote{Console}}.

\sphinxAtStartPar
Files can be handled very differently by different operating systems, but
C\# abstracts away the differences and provides stream interfaces between
a C\# program and files.

\sphinxstepscope

\index{file (StreamWriter)@\spxentry{file}\spxextra{StreamWriter}!write and close@\spxentry{write and close}}\index{StreamWriter@\spxentry{StreamWriter}!WriteLine@\spxentry{WriteLine}}\index{WriteLine@\spxentry{WriteLine}!StreamWriter@\spxentry{StreamWriter}}\index{class@\spxentry{class}!StreamWriter@\spxentry{StreamWriter}}\index{close file@\spxentry{close file}}\ignorespaces 

\section{Writing Files}
\label{\detokenize{files/filewrite:writing-files}}\label{\detokenize{files/filewrite:filewrite}}\label{\detokenize{files/filewrite:index-0}}\label{\detokenize{files/filewrite::doc}}
\sphinxAtStartPar
Thus far we have only used the Console class for input and output,
so we have neither read nor written data from/to files.

\sphinxAtStartPar
By default Xamarin Studio places data files in a place that makes sense for advanced
projects, but not for our usage.  Thus far it has not mattered, and we
have left the default directory structure alone.  Now, however, it matters,
and will be a lot simpler if we make a small change to the setup of all our projets using
data files. This will also simplify command\sphinxhyphen{}line usage when we get to it.

\sphinxAtStartPar
Try the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In Xamarin Studio go to the example project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/first\_file}{first\_file}.  Double click
on the project line in the Solution pad to open the Options dialog.
(If this does not work for some
reason you can also open the drop\sphinxhyphen{}down project menu and select Options.)

\item {} 
\sphinxAtStartPar
In the left column of the dialog under Build, the last entry should be Output.  Click on it.
The output path entry should end with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
examples/first\PYGZus{}file
\end{sphinxVerbatim}

\sphinxAtStartPar
This is \sphinxstyleemphasis{not} the way Xamarin sets it up by default.
Originally Output Path ended with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
examples/first\PYGZus{}file/bin/\PYGZdl{}(Configuration)
\end{sphinxVerbatim}

\sphinxAtStartPar
This version has the extra \sphinxcode{\sphinxupquote{/bin/\$(Configuration)}}.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
When you create a new project to
use data files, make sure the  \sphinxcode{\sphinxupquote{/bin/\$(Configuration)}} is \sphinxstyleemphasis{removed}
from the end of this Output Path field.
\end{sphinxadmonition}

\sphinxAtStartPar
Now let us examine the files here.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In the dropdown menu for the \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/first\_file}{first\_file} project, select
“Open Containing Folder” on Windows
or “Reveal in Finder” on a Mac.  In any event the selection opens the project folder
in the operating system, showing all the files, not just the ones you see listed in
Xamarin in the project.

\item {} 
\sphinxAtStartPar
Look at the folder. You should \sphinxstyleemphasis{not} see a file \sphinxcode{\sphinxupquote{sample.txt}}.   Keep the folder handy.

\item {} 
\sphinxAtStartPar
Now build (not run yet ) the first\_file project.

\item {} 
\sphinxAtStartPar
Look at the operating system folder again.  You should now see build products,
\sphinxcode{\sphinxupquote{first\_file.exe}}, the executable file, and \sphinxcode{\sphinxupquote{first\_file.exe.mdb}},
extra debugging information if there are errors in execution.

\item {} 
\sphinxAtStartPar
Now run the program.  This program does \sphinxstyleemphasis{not} produce output to the screen,
so just close the execution window.

\item {} 
\sphinxAtStartPar
The program did do something:  Look at the operating system folder again.
Now you \sphinxstyleemphasis{should} see a file \sphinxcode{\sphinxupquote{sample.txt}}.
This is a file created by the program you ran.

\end{enumerate}

\sphinxAtStartPar
Here is the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.IO}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{FirstFile}\PYG{+w}{  }\PYG{c+c1}{// basics of file writing}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{StreamWriter}\PYG{+w}{ }\PYG{n}{writer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamWriter}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}sample.txt\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{writer}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}This program is writing\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{writer}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}our first file.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{writer}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{.@\spxentry{.}!part of namespace@\spxentry{part of namespace}}\index{System.IO namespace@\spxentry{System.IO namespace}}\ignorespaces 
\sphinxAtStartPar
Look at the code.  Note the extra namespace being used at the top.  You will
always need to be using \sphinxcode{\sphinxupquote{System.IO}} when working with files.  Here is a slightly
different use of a dot, \sphinxcode{\sphinxupquote{.}}, to indicate a \sphinxstyleemphasis{subsidiary} namespace.

\sphinxAtStartPar
The first line of \sphinxcode{\sphinxupquote{Main}} creates a \sphinxcode{\sphinxupquote{StreamWriter}} object assigned to the
variable  \sphinxcode{\sphinxupquote{writer}}.  A \sphinxcode{\sphinxupquote{StreamWriter}}
links C\# to your
computer’s file system for writing, not reading.
Files are objects, like a Random, and use the \sphinxcode{\sphinxupquote{new}} syntax to create a new one.
The parameter in the constructor
gives the name of the file to connect to the program, \sphinxcode{\sphinxupquote{sample.txt}} \sphinxhyphen{} the same
as the file name we saw created by the program.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
If the file already existed,  the old contents are
\sphinxstyleemphasis{destroyed} silently by creating a \sphinxcode{\sphinxupquote{StreamWriter}}.
\end{sphinxadmonition}

\sphinxAtStartPar
If you do not use
any operating system directory separators in the name (\sphinxcode{\sphinxupquote{\textquotesingle{}\textbackslash{}\textquotesingle{}}} or \sphinxcode{\sphinxupquote{\textquotesingle{}/\textquotesingle{}}},
depending on your operating system), then the file will lie in the
\sphinxstyleemphasis{current directory}, discussed more shortly.  The Xamarin Studio default is for this
current directory to be the bin/Debug subdirectory.  Our change to the output path
converts it so the \sphinxstyleemphasis{current directory} is the main project folder.

\sphinxAtStartPar
The second and third lines of \sphinxcode{\sphinxupquote{Main}} write the specified strings to lines in the file.
Note that the \sphinxcode{\sphinxupquote{StreamWriter}} object \sphinxcode{\sphinxupquote{writer}}, not \sphinxcode{\sphinxupquote{Console}},
comes before the dot and \sphinxcode{\sphinxupquote{WriteLine}}.
This is yet another variation on the use of a dot, \sphinxcode{\sphinxupquote{.}}:  between an object and
a function tied to this object.  In this situation the function tied to an object
is more specifically called a \sphinxstyleemphasis{method}, in object\sphinxhyphen{}oriented terminology.  All the
uses of a dot (except for a numerical literal value) share a common idea, indicating
a named part or attribute of a larger thing.

\sphinxAtStartPar
The last line of \sphinxcode{\sphinxupquote{Main}} is important for cleaning up. Until this line, this
C\# program controls the file, and nothing may be actually
written to the operating system file yet:  Since initiating a file operation
is thousands of times
slower than memory operations, C\# \sphinxstyleemphasis{buffers} data, saving small
amounts and writing a larger chunk all at once.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The call to the \sphinxcode{\sphinxupquote{Close}} method
is essential for C\# to make sure everything is really
written, and to relinquish control of the file for use by
other programs.
\end{sphinxadmonition}

\sphinxAtStartPar
It is a common bug
to write a program where you have the code to add all the data you
want to a file, but the program does not end up creating a file.
Usually this means you forgot to close the file!

\sphinxAtStartPar
If you were to run the program from the command line instead of from Xamarin Studio,
the file would appear in the current directory.

\index{StreamWriter@\spxentry{StreamWriter}!format string@\spxentry{format string}}\index{StreamWriter@\spxentry{StreamWriter}!Write@\spxentry{Write}}\ignorespaces 
\sphinxAtStartPar
Just as you can use a {\hyperref[\detokenize{data/writeline-substitution:format-strings}]{\sphinxcrossref{\DUrole{std,std-ref}{String Format Operation}}}} with
functions \sphinxcode{\sphinxupquote{Write}} and \sphinxcode{\sphinxupquote{WriteLine}} of the \sphinxcode{\sphinxupquote{Console}} class,
you can also use a format string with the corresponding methods of a
\sphinxcode{\sphinxupquote{StreamWriter}}, and embed fields by using braces in
the format string.

\sphinxstepscope

\index{file (StreamWriter)@\spxentry{file}\spxextra{StreamWriter}!read and close@\spxentry{read and close}}\index{StreamReader@\spxentry{StreamReader}!ReadLine@\spxentry{ReadLine}}\index{close file@\spxentry{close file}}\ignorespaces 

\section{Reading Files}
\label{\detokenize{files/fileread:reading-files}}\label{\detokenize{files/fileread:fileread}}\label{\detokenize{files/fileread:index-0}}\label{\detokenize{files/fileread::doc}}
\sphinxAtStartPar
In Xamarin Studio, go to project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_first\_file}{print\_first\_file}.  Note that we have added a copy of
\sphinxcode{\sphinxupquote{sample.txt}} as a project file, so it is an existing file in the project folder.
You can open it and see that it is a copy of the file created in the last section.

\sphinxAtStartPar
It will be true of most all the programs for this chapter, but you might check that we have
modified the project Output Path to refer to the project folder,
in this case with the path ending
\sphinxcode{\sphinxupquote{examples/print\_first\_file}}.  This means \sphinxcode{\sphinxupquote{sample.txt}} will be in the
current directory when the program runs.

\sphinxAtStartPar
Run the example program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_first\_file/print\_first\_file.cs}{print\_first\_file/print\_first\_file.cs}, shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.IO}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{PrintFirstFile}\PYG{+w}{  }\PYG{c+c1}{// basics of reading file lines}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}sample.txt\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// first line}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{// second line}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you have read a file and used it in a program.

\sphinxAtStartPar
In the first line of \sphinxcode{\sphinxupquote{Main}} the operating system file (\sphinxcode{\sphinxupquote{sample.txt}}) is
associated again with a C\# variable name (\sphinxcode{\sphinxupquote{reader}}),
this time for reading as a \sphinxcode{\sphinxupquote{StreamReader}} object.
A \sphinxcode{\sphinxupquote{StreamReader}} can only open an existing file, so
\sphinxcode{\sphinxupquote{sample.txt}} must already exist.

\sphinxAtStartPar
Again we have parallel names to those used with \sphinxcode{\sphinxupquote{Console}},
but in this case the \sphinxcode{\sphinxupquote{ReadLine}} method returns the next line from the file.
Here the string from the file line is assigned to
the variable \sphinxcode{\sphinxupquote{line}}. Each call the ReadLine reads the
next line of the file.

\sphinxAtStartPar
Using the \sphinxcode{\sphinxupquote{Close}} method is
generally optional with files being read. There is nothing to lose
if a program ends without closing a file that was being read. %
\begin{footnote}[1]\sphinxAtStartFootnote
If, for some reason, you want to reread this same file while the
same program is running, you need to close it and reopen it.
%
\end{footnote}

\index{StreamReader@\spxentry{StreamReader}!EndOfStream@\spxentry{EndOfStream}}\index{EndOfStream@\spxentry{EndOfStream}}\ignorespaces 

\subsection{Reading to End of Stream}
\label{\detokenize{files/fileread:reading-to-end-of-stream}}\label{\detokenize{files/fileread:endofstream}}\label{\detokenize{files/fileread:index-1}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{first\_file.cs}}, we explicitly coded reading two lines.  You will often
want to process each line in a file, without knowing the total number of
lines at the time when you were programming.
This means that files provide us with our
second kind of a sequence:  the sequence of lines in the file!
To process all of them will require a loop and a new test to make sure that you
have not yet come to the end of the file’s stream: You can use the \sphinxcode{\sphinxupquote{EndOfStream}}
property. It has the wrong sense (true at the end of the file), so we negate it,
testing for \sphinxcode{\sphinxupquote{!reader.EndOfStream}} to \sphinxstyleemphasis{continue} reading.
The example program \sphinxcode{\sphinxupquote{print\_file\_lines.cs}}
reads and prints the contents of a file specified by the
user, one line at a time:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.IO}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{PrintFileLines}\PYG{+w}{  }\PYG{c+c1}{// demo of using EndOfStream test}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{userFileName}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter name of file to print: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{n}{userFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{reader}\PYG{p}{.}\PYG{n}{EndOfStream}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{var@\spxentry{var}}\index{type@\spxentry{type}!var@\spxentry{var}}\ignorespaces \begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{var}}}
\sphinxAtStartPar
For conciseness (and variety) we declared \sphinxcode{\sphinxupquote{reader}}
using the more compact syntax with \sphinxcode{\sphinxupquote{var}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{n}{userFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can use \sphinxcode{\sphinxupquote{var}} in place of a declared type to shorten your code
with a couple of restrictions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use an initializer, from which the type of the variable can be inferred.

\item {} 
\sphinxAtStartPar
Declare a local variable inside a method body or in a loop heading.

\item {} 
\sphinxAtStartPar
Declare only a single variable in the statement.

\end{itemize}

\sphinxAtStartPar
We could have used this syntax long ago, but as the type names become longer,
it is more useful!

\end{description}

\sphinxAtStartPar
You can run this program. You need an existing file to read.  An obvious file is
the source file itself:  \sphinxcode{\sphinxupquote{print\_file\_lines.cs}}.

\sphinxAtStartPar
Things to note about reading from files:

\index{StreamReader@\spxentry{StreamReader}!null from ReadLine@\spxentry{null from ReadLine}}\index{ReadLine@\spxentry{ReadLine}!null with StreamReader@\spxentry{null with StreamReader}}\ignorespaces \begin{itemize}
\item {} 
\sphinxAtStartPar
Reading from a file returns the part read, of course.  Never forget the
\sphinxstyleemphasis{side effect}:  The location in the file advances past the part just read.
The next read does \sphinxstyleemphasis{not} return the \sphinxstyleemphasis{same} thing as last time.  It returns
the \sphinxstyleemphasis{next} part of the file.

\item {} 
\sphinxAtStartPar
Our \sphinxcode{\sphinxupquote{while}} test conditions so far have been in a sense “backward looking”:
We have tested a variable that has \sphinxstyleemphasis{already been set}.
The test with \sphinxcode{\sphinxupquote{EndOfStream}} is
\sphinxstyleemphasis{forward looking}:  looking at what has not been processed yet.  Other than
making sure the file is opened, there is no variable that needs to be set
before a \sphinxcode{\sphinxupquote{while}} loop testing for \sphinxcode{\sphinxupquote{EndOfStream}}.

\item {} 
\sphinxAtStartPar
If you use ReadLine at the end of the file, the special value \sphinxcode{\sphinxupquote{null}} (no object)
is returned.  \sphinxstyleemphasis{This} is not an error, but if you try to apply any string methods
to the \sphinxcode{\sphinxupquote{null}} value returned, \sphinxstyleemphasis{then} you get an error!

\end{itemize}

\index{file (StreamWriter)@\spxentry{file}\spxextra{StreamWriter}!ReadToEnd@\spxentry{ReadToEnd}}\index{StreamReader@\spxentry{StreamReader}!ReadToEnd@\spxentry{ReadToEnd}}\index{ReadToEnd@\spxentry{ReadToEnd}}\ignorespaces \phantomsection\label{\detokenize{files/fileread:readtoend}}
\sphinxAtStartPar
Though \sphinxcode{\sphinxupquote{print\_file\_lines.cs}} was a nice simple illustration of a loop reading
lines, it was very verbose considering the final effect of the program,
just to print the whole file.
You can read the entire remaining contents of a file
as a single (multiline) string, using the
\sphinxcode{\sphinxupquote{StreamReader}} method \sphinxcode{\sphinxupquote{ReadToEnd}}.  In place of the reading and printing
loop we could have just had:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{wholeFile}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadToEnd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{wholeFile}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ReadToEnd}} does not strip off a newline, unlike \sphinxcode{\sphinxupquote{ReadLine}},
so we do not want to add an extra newline
when writing.  We use the \sphinxcode{\sphinxupquote{Write}} method instead of \sphinxcode{\sphinxupquote{WriteLine}}.

\index{example@\spxentry{example}!sum\_files.cs@\spxentry{sum\_files.cs}}\index{sum\_files.cs example@\spxentry{sum\_files.cs example}}\ignorespaces 

\subsection{Example: Sum Numbers in File}
\label{\detokenize{files/fileread:example-sum-numbers-in-file}}\label{\detokenize{files/fileread:index-5}}
\sphinxAtStartPar
We have summed the numbers from 1 to \sphinxcode{\sphinxupquote{n}}.  In that case we generated
the next number \sphinxcode{\sphinxupquote{i}} automatically using \sphinxcode{\sphinxupquote{i++}}.  We could also read numbers
from a file containing one number per line (plus possible white space):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CalcSum}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{reader}\PYG{p}{.}\PYG{n}{EndOfStream}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sVal}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{sVal}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{File class@\spxentry{File class}!Exists@\spxentry{Exists}}\index{Exists \sphinxhyphen{} File class method@\spxentry{Exists \sphinxhyphen{} File class method}}\ignorespaces 
\sphinxAtStartPar
Below and in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_file/sum\_file.cs}{sum\_file/sum\_file.cs} is a more elaborate, complete example,
that also exits gracefully if you give a bad file name.
If you give a good file name, it skips lines that contain only whitespace.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.IO}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{SumFile}\PYG{+w}{  }\PYG{c+c1}{// sum a file integers, one per line}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}
\PYG{+w}{                              }\PYG{l+s}{\PYGZdq{}Enter the name of a file of integers: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{File}\PYG{p}{.}\PYG{n}{Exists}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The sum is \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{CalcSum}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Bad file name \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Open, read and close the named file and}
\PYG{+w}{      }\PYG{c+c1}{/// return the sum of an int from}
\PYG{+w}{      }\PYG{c+c1}{/// each line that is not just white space.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CalcSum}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{reader}\PYG{p}{.}\PYG{n}{EndOfStream}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sVal}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sVal}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{sVal}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A useful function used in \sphinxcode{\sphinxupquote{Main}} for avoiding filename typo errors
is \sphinxcode{\sphinxupquote{File.Exists}} in the \sphinxcode{\sphinxupquote{System.IO}} namespace

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{File}\PYG{p}{.}\PYG{n}{Exists}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filenamePath}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is true if the named files exists in the operating system’s file structure.

\sphinxAtStartPar
You should see the files \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_file/numbers.txt}{sum\_file/numbers.txt} and
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sum\_file/numbers2.txt}{sum\_file/numbers2.txt} in the Xamarin Studio project.  You can test
with them.  It is important to test all paths through the program: also do
put in a bad name and see that the program exits gracefully, as intended.

\sphinxAtStartPar
For files in the current folder, you can just use the plain file name.
For other folders see {\hyperref[\detokenize{files/paths:path-strings}]{\sphinxcrossref{\DUrole{std,std-ref}{Path Strings}}}}.

\index{exercise@\spxentry{exercise}!safe sum@\spxentry{safe sum}}\index{safe sum exercise@\spxentry{safe sum exercise}}\ignorespaces 

\subsubsection{Safe Sum File Exercise}
\label{\detokenize{files/fileread:safe-sum-file-exercise}}\label{\detokenize{files/fileread:safe-sum-file-ex}}\label{\detokenize{files/fileread:index-7}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Copy \sphinxcode{\sphinxupquote{sum\_file.cs}} to a file \sphinxcode{\sphinxupquote{safe\_sum\_file.cs}} in a new project of yours.
\sphinxstyleemphasis{Be sure to modify the Output path option to just refer to the project folder!}
Modify the program: Write
a new function with the heading below.  Use it in \sphinxcode{\sphinxupquote{Main}}, in place of the \sphinxcode{\sphinxupquote{if}}
statement that checks (only once) for a legal file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Prompt the user to enter a file name to open for reading.}
\PYG{c+c1}{// Repeat until the name of an existing file is given.}
\PYG{c+c1}{// Open and return the file.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n+nf}{PromptFile}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
A user who completely forgot the file name could be stuck in an infinite loop!
Elaborate the function and program, so that an empty line entered means
“give up”, and \sphinxcode{\sphinxupquote{null}} (no object) should be returned.  The main program needs to
test for this and quit gracefully in that case.

\end{enumerate}


\subsection{Example Copy to Upper Case}
\label{\detokenize{files/fileread:example-copy-to-upper-case}}
\sphinxAtStartPar
Here is a simple fragment from example file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/copy\_upper/copy\_upper.cs}{copy\_upper/copy\_upper.cs}.
It copies a file line by line to a new file in upper case:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{reader}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}text.txt\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{writer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{StreamWriter}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}upper\PYGZus{}text.txt\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{reader}\PYG{p}{.}\PYG{n}{EndOfStream}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{writer}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{line}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{reader}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{writer}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You may test this in the Xamarin Studio example project copy\_upper:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Expand the copy\_upper project in the Solution pad.  The project
includes the input file.  You may not see it at first.  You need to expand the folder
for \sphinxcode{\sphinxupquote{bin}} and then \sphinxcode{\sphinxupquote{Debug}}.  You see \sphinxcode{\sphinxupquote{text.txt}}.

\item {} 
\sphinxAtStartPar
To see
what else is in the project directory,
select
“Open Containing Folder” or “Open in Finder” on a Mac.
You should see project file \sphinxcode{\sphinxupquote{text.txt}} but not \sphinxcode{\sphinxupquote{upper\_text.txt}}.
Leave that operating system file folder open.

\item {} 
\sphinxAtStartPar
Go back to Xamarin Studio and run the project.  Now look at the
operating system folder again.  You should see \sphinxcode{\sphinxupquote{upper\_text.txt}}.
You can open it and see that it holds an upper case version of the contents
of \sphinxcode{\sphinxupquote{text.txt}}.

\end{enumerate}

\sphinxAtStartPar
This is another case where the \sphinxcode{\sphinxupquote{ReadToEnd}} function could have eliminated the loop.
%
\begin{footnote}[2]\sphinxAtStartFootnote
Besides the speed and efficiency of this second approach,
there is also a technical improvement:  There may or may not be
a newline at the end of the very last line of the file.  The \sphinxcode{\sphinxupquote{ReadLine}}
method works either way, but does not let you know the difference.
In the line\sphinxhyphen{}by\sphinxhyphen{}line version, there is always a newline after the
final line written with \sphinxcode{\sphinxupquote{WriteLine}}.
The \sphinxcode{\sphinxupquote{ReadToEnd}} version will have newlines exactly matching the input.
%
\end{footnote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{contents}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{.}\PYG{n}{ReadToEnd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{writer}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{contents}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstepscope

\index{path@\spxentry{path}}\ignorespaces 

\section{Path Strings}
\label{\detokenize{files/paths:path-strings}}\label{\detokenize{files/paths:index-0}}\label{\detokenize{files/paths:id1}}\label{\detokenize{files/paths::doc}}
\sphinxAtStartPar
When a program is running, there is alway a \sphinxstyleemphasis{current working directory}.
Files in the current working directory can to referred to by their simple names,
e.g., \sphinxstyleemphasis{sample.txt}, so with our conventions, project files can be referred to by their simple names.

\sphinxAtStartPar
Referring to files not in the current directory is more complicated.
You should be aware from using the Windows Explorer or the Finder that
files and  directories are located in a hierarchy of directories in the
file system.  On a Mac, the file system is unified in
one hierarchy. On Windows, each drive has its own hierarchy.

\index{/@\spxentry{/}!path separator@\spxentry{path separator}}\index{\textbackslash{}@\spxentry{\textbackslash{}}!path separator@\spxentry{path separator}}\ignorespaces 
\sphinxAtStartPar
Files are generally referred to by a chain of directories before
the final name of the file desired.  A \sphinxstyleemphasis{path string} is used
to represent such a sequence of names.  Elements of the directory chain are separated
by operating system specific punctuation:  In Windows the separator is backslash, \textbackslash{},
and on a Mac it is (forward) slash, /.  For example on a Mac the path

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/anh
\end{sphinxVerbatim}

\sphinxAtStartPar
starts with a /, meaning the \sphinxstyleemphasis{root} or top directory in the hierarchy, and Users is
a subdirectory, and anh is a subdirectory of Users (in this case the home directory
for the user with login anh).
It is similar with Windows, except there may be a drive in the beginning,
and the separator is a \textbackslash{}, so

\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Windows\PYGZbs{}System32
\end{sphinxVerbatim}

\sphinxAtStartPar
is on C: drive; Windows is a subdirectory of the root directory \textbackslash{}, and System32 is
a subdirectory of Windows.
Each drive in Windows has a separate file hierarchy underneath it.

\index{path@\spxentry{path}!absolute@\spxentry{absolute}}\ignorespaces 
\sphinxAtStartPar
Paths starting from the root of a file system, with \sphinxcode{\sphinxupquote{\textbackslash{}}} or \sphinxcode{\sphinxupquote{/}} are called
\sphinxstyleemphasis{absolute paths}.
Since there is always a current directory, it makes sense to allow a path to be \sphinxstyleemphasis{relative}
to the current directory.  In that case do \sphinxstyleemphasis{not} start with the slash that would
indicate the root directory.  For example, if the current directory is
your home directory, you likely have a subdirectory \sphinxcode{\sphinxupquote{Downloads}}, and the
\sphinxcode{\sphinxupquote{Downloads}}
directory might contain \sphinxcode{\sphinxupquote{examples.zip}}.  From the home directory, this file could
be referred to as \sphinxcode{\sphinxupquote{Downloads\textbackslash{}examples.zip}} or  \sphinxcode{\sphinxupquote{Downloads/examples.zip}} on a Mac.

\sphinxAtStartPar
When you run a project through Xamarin Studio with the default setup, the current directory is the directory
two levels below the project directory, in a folder created by the system,
\sphinxcode{\sphinxupquote{bin\textbackslash{}Debug}} or  \sphinxcode{\sphinxupquote{bin/Debug}} on a Mac.
We choose to modify and simplify this in our projects working with files, so the Output Folder
is just the project folder.

\sphinxAtStartPar
Referring to files in the current directory just by their plain file name is
actually an example of using relative paths.

\index{.. parent folder@\spxentry{.. parent folder}}\ignorespaces 
\sphinxAtStartPar
With relative paths, you sometimes want to move up the directory hierarchy:  \sphinxcode{\sphinxupquote{..}}
(two periods) refers to the directory one level up the chain.

\sphinxAtStartPar
For example, suppose you solve {\hyperref[\detokenize{files/fileread:safe-sum-file-ex}]{\sphinxcrossref{\DUrole{std,std-ref}{Safe Sum File Exercise}}}} by puting your new project
safe\_sum\_file in the \sphinxstyleemphasis{same} solution as the original sum\_file.  That means the parent folder
for both projects is the solution folder.  If you want to run your new \sphinxcode{\sphinxupquote{safe\_sum\_file.cs}}
program (assuming you made the Output Path be the project folder)
and want tp open the \sphinxcode{\sphinxupquote{numbers.txt}}
file in the sum\_file project, then, when prompted in the program, you would refer to the
file to read as \sphinxcode{\sphinxupquote{..\textbackslash{}sum\_file\textbackslash{}numbers.txt}} in Windows or
\sphinxcode{\sphinxupquote{../sum\_file/numbers.txt}} on a Mac.  Follow this one step at a time:
Starting from the \sphinxcode{\sphinxupquote{safe\_sum\_file}} project folder, where the program is running,
go up one folder (\sphinxcode{\sphinxupquote{..}}) to the solution folder, then down into the \sphinxcode{\sphinxupquote{sum\_file}} project folder,
and refer to the \sphinxcode{\sphinxupquote{numbers.txt}} file in that folder.

\index{.@\spxentry{.}!current folder@\spxentry{current folder}}\ignorespaces 
\sphinxAtStartPar
Occasionally you need to
refer explicitly to the current directory:  It is referred to as \sphinxcode{\sphinxupquote{.}}. (a single
period).

\index{Path class@\spxentry{Path class}}\ignorespaces 

\subsection{Paths in C\#}
\label{\detokenize{files/paths:paths-in-c}}\label{\detokenize{files/paths:index-5}}
\sphinxAtStartPar
The differing versions of paths for Windows and a Mac are a pain to deal with. Luckily C\#
abstracts away the differences.  It has a \sphinxcode{\sphinxupquote{Path}} class in the \sphinxcode{\sphinxupquote{System.IO}}
namespace that provides many handy functions for dealing with paths in
an operating system independent way:

\sphinxAtStartPar
For one thing, C\# knows the path separator character for your operating system,
\sphinxcode{\sphinxupquote{Path.DirectorySeparatorChar}}.

\sphinxAtStartPar
More useful is the function \sphinxcode{\sphinxupquote{Path.Combine}}, which takes any number of string parameters
for sequential parts of a path, and creates a single string appropriate for the
current operating system.  For example,
\sphinxcode{\sphinxupquote{Path.Combine("bin", "Debug")}} will return \sphinxcode{\sphinxupquote{"bin\textbackslash{}Debug"}} or \sphinxcode{\sphinxupquote{"bin/debug"}}
as appropriate.
\sphinxcode{\sphinxupquote{Path.Combine("..", "sum\_file", "numbers.txt")}} will return a string with characters
\sphinxcode{\sphinxupquote{..\textbackslash{}sum\_file\textbackslash{}numbers.txt}} or \sphinxcode{\sphinxupquote{../sum\_file/numbers.txt}}.

\sphinxAtStartPar
Even if you know you are going to be on Windows, file paths are a problem because
\sphinxcode{\sphinxupquote{\textbackslash{}}} is the string escape character.  To enter the Windows path above explicitly
you would need to have \sphinxcode{\sphinxupquote{"..\textbackslash{}\textbackslash{}sum\_file\textbackslash{}\textbackslash{}numbers.txt"}}, or the raw string prefix,
\sphinxcode{\sphinxupquote{@}} can come to the rescue:  \sphinxcode{\sphinxupquote{@"..\textbackslash{}sum\_file\textbackslash{}numbers.txt"}}.

\sphinxAtStartPar
You can look at the \sphinxcode{\sphinxupquote{Path}} class in the MSDN documentation
for many other operations with path strings.

\sphinxAtStartPar
Path strings are used by the {\hyperref[\detokenize{files/dir-file:directory-class}]{\sphinxcrossref{\DUrole{std,std-ref}{Directory Class}}}} and by the {\hyperref[\detokenize{files/dir-file:file-class}]{\sphinxcrossref{\DUrole{std,std-ref}{File Class}}}}.


\subsubsection{Path String Exercise}
\label{\detokenize{files/paths:path-string-exercise}}
\sphinxAtStartPar
In the path string illustration above to open \sphinxcode{\sphinxupquote{numbers.txt}},
we assumed for simplicity that the sum\_file and safe\_sum\_file
projects were in the same Xamarin solution.
Imagine the following alternate assumptions, more like the way
we suggested you actually set up your projects:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You have your own solution including the
safe\_sum\_file project.

\item {} 
\sphinxAtStartPar
Your solution’s folder and the examples solution folder are both
subfolder of the
same parent folder.

\item {} 
\sphinxAtStartPar
You are running the safe\_sum\_file.cs program from your safe\_sum\_file project folder.

\item {} 
\sphinxAtStartPar
You want the user to reference the \sphinxcode{\sphinxupquote{numbers.txt}} in the sum\_file project inside
our examples project.

\end{itemize}

\sphinxAtStartPar
What path string would you enter to be able to open that file?


\subsubsection{File Line Removal Exercise}
\label{\detokenize{files/paths:file-line-removal-exercise}}
\sphinxAtStartPar
Complete the function described below, and make a Main program and
sample file to test it.  Modify the Xamarin defaults so the Output Path
is the project folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Take all lines from reader that do not start with startToRemove}
\PYG{c+c1}{/// and copy them to writer.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{FileLineRemoval}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StreamWriter}\PYG{+w}{ }\PYG{n}{writer}
\PYG{+w}{                            }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{startToRemove}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example, in Unix/Mac scripts lines starting with \sphinxcode{\sphinxupquote{\textquotesingle{}\#\textquotesingle{}}} are
comment lines.  Making \sphinxcode{\sphinxupquote{startToRemove}} be \sphinxcode{\sphinxupquote{\textquotesingle{}\#\textquotesingle{}}} would write only non\sphinxhyphen{}comment lines
to the writer.

\sphinxstepscope

\index{Directory class@\spxentry{Directory class}}\ignorespaces 

\section{Directory Class}
\label{\detokenize{files/dir-file:directory-class}}\label{\detokenize{files/dir-file:index-0}}\label{\detokenize{files/dir-file:id1}}\label{\detokenize{files/dir-file::doc}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Directory}} class is in the \sphinxcode{\sphinxupquote{System.IO}} namespace.
Directories in the file system are referenced by {\hyperref[\detokenize{files/paths:path-strings}]{\sphinxcrossref{\DUrole{std,std-ref}{Path Strings}}}}.
You can look at the MSDN documentation for a wide variety of functions in the
\sphinxcode{\sphinxupquote{Directory}} class including ones to list all the files in a directory
or to check if a path string represents an actual directory.

\index{File class@\spxentry{File class}}\ignorespaces 

\section{File Class}
\label{\detokenize{files/dir-file:file-class}}\label{\detokenize{files/dir-file:index-1}}\label{\detokenize{files/dir-file:id2}}
\sphinxAtStartPar
We will generally access operating system files using the \sphinxcode{\sphinxupquote{Stream}} abstraction,
discussed earlier in this chapter.
There is also a \sphinxcode{\sphinxupquote{File}} class in the \sphinxcode{\sphinxupquote{System.IO}} namespace, with a number
of specialized and convenience functions.
We already used the \sphinxcode{\sphinxupquote{File.Exists}} function.

\sphinxAtStartPar
You can look at the MSDN documentation for other uses of the \sphinxcode{\sphinxupquote{File}} class.

\sphinxstepscope

\index{command line@\spxentry{command line}!execution@\spxentry{execution}}\index{execution on command line@\spxentry{execution on command line}}\ignorespaces 

\section{Command Line Execution}
\label{\detokenize{files/cmdline-execution:command-line-execution}}\label{\detokenize{files/cmdline-execution:cmdline-execution}}\label{\detokenize{files/cmdline-execution:index-0}}\label{\detokenize{files/cmdline-execution::doc}}
\sphinxAtStartPar
C\# shields you from the differences
between operating systems
with its \sphinxcode{\sphinxupquote{File}}, \sphinxcode{\sphinxupquote{Path}}, and \sphinxcode{\sphinxupquote{Directory}} classes.

\sphinxAtStartPar
If you leave Xamarin Studio and go to the command line as described in
{\hyperref[\detokenize{appendix/cmdline:commandline}]{\sphinxcrossref{\DUrole{std,std-ref}{Command Line Introduction}}}}, then you are exposed to the differences
between the operating systems.  \sphinxstyleemphasis{Look over that section.}

\sphinxAtStartPar
Thus far we have let Xamarin Studio hide what actually is happening when
you execute a program.  The natural environment for the text\sphinxhyphen{}based programs
that we are writing is the command line.
We need to get outside of Xamarin Studio.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
To show off the transition, first run the \sphinxcode{\sphinxupquote{addition1}} example project
from inside Xamarin Studio.

\item {} 
\sphinxAtStartPar
Open a terminal on a Mac or a Mono Command Prompt console in Windows.

\item {} 
\sphinxAtStartPar
Following the
{\hyperref[\detokenize{appendix/cmdline:commandline}]{\sphinxcrossref{\DUrole{std,std-ref}{Command Line Introduction}}}},
change the current directory to the addition1 example project directory.

\item {} 
\sphinxAtStartPar
Enter the command to list the directory (\sphinxcode{\sphinxupquote{dir}} in Windows; \sphinxcode{\sphinxupquote{ls}} on a Mac).

\item {} 
\sphinxAtStartPar
You should see \sphinxcode{\sphinxupquote{addition1.cs}} but
\sphinxstyleemphasis{not} see \sphinxcode{\sphinxupquote{addition1.exe}}.  The file \sphinxcode{\sphinxupquote{addition1.exe}} is the compiled program
that Xamarin Studio creates for this project, however,
with the default configuration that we kept
for this project, this file ends up two directories down in \sphinxcode{\sphinxupquote{bin/Debug}}.

\end{enumerate}

\index{mcs@\spxentry{mcs}}\index{command line@\spxentry{command line}!compile with mcs@\spxentry{compile with mcs}}\index{compile on command line@\spxentry{compile on command line}}\ignorespaces 
\sphinxAtStartPar
Let us now create \sphinxcode{\sphinxupquote{addition1.exe}} in the main project directory
without using Xamarin Studio.
Continue with the same terminal/console window:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Try the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono addition1.exe
\end{sphinxVerbatim}

\sphinxAtStartPar
You should get an error message, because \sphinxcode{\sphinxupquote{addition1.exe}} is not in the current
directory.

\item {} 
\sphinxAtStartPar
Enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mcs addition1.cs
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the Mono system compiler, building from the source code.

\item {} 
\sphinxAtStartPar
Print a listing of the directory.  You should now see
\sphinxcode{\sphinxupquote{addition1.exe}}, created by the compiler.

\item {} 
\sphinxAtStartPar
Try the command again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono addition1.exe
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that no new terminal window popped up and later disappeared \sphinxhyphen{}
output appears in and stays in the current terminal window.

\item {} 
\sphinxAtStartPar
Windows only:  On Windows, Xamarin Studio creates a regular Windows executable file.
For consistency you can use the command above, but you no longer need Mono.
You can just enter the command \sphinxcode{\sphinxupquote{addition1.exe}} or the shorter \sphinxcode{\sphinxupquote{addition1}}.

\end{enumerate}

\sphinxAtStartPar
Now try a program that had multiple files.  The project version addition3
uses the library class UIF.  Continue with the same terminal/console window:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Enter the commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd ../addition3
mcs addition3.cs
\end{sphinxVerbatim}

\sphinxAtStartPar
to get to the addition3 project folder, and attempt to compile its program.
You should get an error about missing the UIF class. The mcs program
does not know about the information Xamarin Studio keeps in its references.

\item {} 
\sphinxAtStartPar
Extend the command to also give the location of the library file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mcs addition3.cs ../ui/uif.cs
\end{sphinxVerbatim}

\sphinxAtStartPar
That should work, now referring to both needed files.

\item {} 
\sphinxAtStartPar
Enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono addition3.exe
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Now let us try a project where we read a file.  Enter command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd ../sum\PYGZus{}file
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
List the contents of this directory. (\sphinxcode{\sphinxupquote{dir}} on Windows; \sphinxcode{\sphinxupquote{ls}} on a mac).

\item {} 
\sphinxAtStartPar
If you have run the sum\_file.cs program before, you should see
\sphinxcode{\sphinxupquote{sum\_file.exe}} listed,
since the Xamarin options for this project were set to place the output in this
main project directory.  Erase \sphinxcode{\sphinxupquote{sum\_file.exe}} with
\sphinxcode{\sphinxupquote{erase sum\_file.exe}} on Windows or \sphinxcode{\sphinxupquote{rm sum\_file.exe}} on a Mac.
You can list the directory again to check that you did it.

\item {} 
\sphinxAtStartPar
Now enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mcs sum\PYGZus{}file.cs
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
List the directory again \sphinxhyphen{} \sphinxcode{\sphinxupquote{sum\_file.exe}} has been created again.

\item {} 
\sphinxAtStartPar
Now enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono sum\PYGZus{}file.exe
\end{sphinxVerbatim}

\sphinxAtStartPar
As the program runs, remember the file
\sphinxcode{\sphinxupquote{numbers.txt}} is in the same folder. To use it,
just enter the simple file name, \sphinxcode{\sphinxupquote{numbers.txt}}.

\item {} 
\sphinxAtStartPar
For a little more command\sphinxhyphen{}line experience enter
\sphinxcode{\sphinxupquote{type numbers.txt}} on Windows, or \sphinxcode{\sphinxupquote{cat numbers.txt}} on a Mac.
You should see that the the numbers in the file
do add to the program’s result: 16.

\end{enumerate}

\sphinxAtStartPar
By default mcs and mono read from and write to the current directory of the
terminal/console.
This is unlike the Xamarin Studio default, where the current directory for execution
is not the project directory.
Under the hood, Xamarin Studio uses mcs also, with a bunch of further options
in the parameters, changing the execution directory and also arranging
for better debugging information when you get a runtime error.

\index{NAnt build tool@\spxentry{NAnt build tool}}\ignorespaces 
\sphinxAtStartPar
Xamarin Studio keeps track of all of the parts of your projects, and recompiles only
as needed.  There are
also many command\sphinxhyphen{}line tools that manage multi\sphinxhyphen{}file projects neatly, remembering
the parts, and compiling only as necessary.
One example is NAnt, which comes with Mono.

\sphinxstepscope

\index{FIO file I/O@\spxentry{FIO file I/O}}\index{library@\spxentry{library}!FIO@\spxentry{FIO}}\ignorespaces 

\section{FIO Helper Class}
\label{\detokenize{files/fio:fio-helper-class}}\label{\detokenize{files/fio:fio}}\label{\detokenize{files/fio:index-0}}\label{\detokenize{files/fio::doc}}
\sphinxAtStartPar
This is an \sphinxstylestrong{optional} section.  It was much more important before we realized how
easily we much
simplified file manipulating projects by changing the Output Path setting.

\sphinxAtStartPar
Still there are a variety of situations where a program may want to access
resources in the file system, without know ahead of time exactly which folder contains
the file resource.  The \sphinxcode{\sphinxupquote{FIO}} library class that we display here illustrates how
a program can search for the directory in which a file resides, given a list
of folder options.  This section also illustrates use of methods from the \sphinxcode{\sphinxupquote{Path}} and
\sphinxcode{\sphinxupquote{File}} classes.

\sphinxAtStartPar
In this case we are specifically thinking of two possible uses of
program source files:  When executing, the project folder may
be the current directory or, in the default setup for Xamarain, the current directory
may be two folders down in \sphinxcode{\sphinxupquote{bin/Debug}}.

\sphinxAtStartPar
We use one idea that is discussed more in the next chapter:  We need a sequence
of directory strings to look through.  At this point we have only discussed
sequences of individual characters.   The variable \sphinxcode{\sphinxupquote{paths}}
contains a sequence of directory paths to check.
(More on the syntax comes up shortly in {\hyperref[\detokenize{arrays/arrays:array}]{\sphinxcrossref{\DUrole{std,std-ref}{Arrays}}}}.)
In our case we make the
sequence contain
\sphinxcode{\sphinxupquote{"."}}, the current directory, \sphinxcode{\sphinxupquote{".."}}, the parent directory, and
\sphinxcode{\sphinxupquote{Path.Combine("..", "..")}}, the parent’s parent.
We make \sphinxcode{\sphinxupquote{paths}} a static variable, so
it is visible in all the functions in the class.

\sphinxAtStartPar
Then the sequence \sphinxcode{\sphinxupquote{paths}}
can be used in the \sphinxcode{\sphinxupquote{foreach}} loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Find a directory containing the filename}
\PYG{c+c1}{/// and return the full file path, if it exists.}
\PYG{c+c1}{/// Otherwise return null.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetPath}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{dir}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{paths}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filePath}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Path}\PYG{p}{.}\PYG{n}{Combine}\PYG{p}{(}\PYG{n}{dir}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{File}\PYG{p}{.}\PYG{n}{Exists}\PYG{p}{(}\PYG{n}{filePath}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{filePath}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{null}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
For each directory path in \sphinxcode{\sphinxupquote{paths}}, we create a \sphinxcode{\sphinxupquote{filePath}} as if the
file were in that directory.  We return the first path that actually exists.
We allow for the file to not be in any of the directories in \sphinxcode{\sphinxupquote{paths}}.  If
we do not find it, we return \sphinxcode{\sphinxupquote{null}} (no object).

\sphinxAtStartPar
For convenience, we have an elaboration, using \sphinxcode{\sphinxupquote{GetPath}},
that directly opens the file to read:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Find a directory containing filename;}
\PYG{c+c1}{/// return a new StreamReader to the file}
\PYG{c+c1}{/// or null if the file does not exist.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n+nf}{OpenReader}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filePath}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GetPath}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{filePath}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{k}{null}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{null}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{else}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{StreamReader}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{filePath}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have a variation on \sphinxcode{\sphinxupquote{GetPath}} that just return the path to the
directory containing the file.  Here is the heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a directory conaining the filename, if it exists.}
\PYG{c+c1}{/// Otherwise return null.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetLocation}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is useful in case you want to later write into the same directory
that you read from.  You can get a location from \sphinxcode{\sphinxupquote{GetLocation}} and then
write to the same directory, creating a \sphinxcode{\sphinxupquote{StreamWriter}}.
You can use the convenience function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Join the location directory and filename;}
\PYG{c+c1}{/// open and return a StreamWriter to the file.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{StreamWriter}\PYG{+w}{ }\PYG{n+nf}{OpenWriter}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{location}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{filePath}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Path}\PYG{p}{.}\PYG{n}{Combine}\PYG{p}{(}\PYG{n}{location}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{StreamWriter}\PYG{p}{(}\PYG{n}{filePath}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The entire \sphinxcode{\sphinxupquote{FIO}} class is in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/fio/fio.cs}{fio/fio.cs}

\sphinxAtStartPar
We illustrate the use of \sphinxcode{\sphinxupquote{FIO}} functions in example file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/fio\_usage/fio\_usage.cs}{fio\_usage/fio\_usage.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.IO}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{FIOTest}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sample}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}sample.txt\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{output}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}output.txt\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Directory of \PYGZob{}0\PYGZcb{}: \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                           }\PYG{n}{sample}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{GetLocation}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Path to  \PYGZob{}0\PYGZcb{}: \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                           }\PYG{n}{sample}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{GetPath}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{OpenReader}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{reader1}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{k}{null}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{reader1}\PYG{p}{.}\PYG{n}{ReadToEnd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}First reader test passed.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{reader1}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}

\PYG{+w}{         }\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{OpenReader}\PYG{p}{(}\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{GetLocation}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                                               }\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{reader2}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{k}{null}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Second reader test passed.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{reader2}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}

\PYG{+w}{         }\PYG{n}{StreamWriter}\PYG{+w}{ }\PYG{n}{writer1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{OpenWriter}\PYG{p}{(}\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{GetLocation}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                                               }\PYG{n}{output}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{writer1}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}File in the same directory as \PYGZob{}0\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{writer1}\PYG{p}{.}\PYG{n}{Close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Writer test passed; file written at \PYGZbs{}n \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                           }\PYG{n}{FIO}\PYG{p}{.}\PYG{n}{GetPath}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you look at the fio\_usage project in our examples solution, you see that
\sphinxcode{\sphinxupquote{sample.txt}} is a file in the project folder.  The program
ends up writing to a new file in the same (project) directory.  Remember that even
though the new file \sphinxcode{\sphinxupquote{output.txt}}
appears in the project directory, it does not appear in the
Solution pad unless you add it to the project.  You can see it in the file system,
and open it if you like.

\sphinxAtStartPar
This project was created with the default set up:  Output path
two folders down.  If you change to Output path to the main project folder,
it should still work.  If you open a terminal/console and go to the project directory, you can compile
and run this program, and it will also work.

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{files/reviewfiles:chapter-review-questions}}\label{\detokenize{files/reviewfiles::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
After writing everything you want to a file through a \sphinxcode{\sphinxupquote{StreamWriter}},
what do you still need to remember to do?

\item {} 
\sphinxAtStartPar
If you want to create a file path in an operating system independent way for
file f.txt in directory d2, which is a subdirectory of d1, which is a
subdirectory of the current directory, how would you do it?

\item {} 
\sphinxAtStartPar
Windows uses \sphinxcode{\sphinxupquote{\textbackslash{}}} as a path separator.  If you want to write a literal
directly for a Windows path, what issue is there in C\#?

\item {} 
\sphinxAtStartPar
In a file path, how do you refer to the parent directory of the
current directory, without using the actual name of the parent directory?

\item {} 
\sphinxAtStartPar
If you are reading from a \sphinxcode{\sphinxupquote{StreamReader}} \sphinxcode{\sphinxupquote{inFile}}, what is logically
wrong with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{inFile}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}!\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{inFile}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZbs{}n contains the symbol !\PYGZdq{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope

\index{array@\spxentry{array}}\index{type@\spxentry{type}!array@\spxentry{array}}\ignorespaces 

\chapter{Arrays}
\label{\detokenize{arrays/arrays:arrays}}\label{\detokenize{arrays/arrays:array}}\label{\detokenize{arrays/arrays:index-0}}\label{\detokenize{arrays/arrays::doc}}
\sphinxstepscope

\index{array@\spxentry{array}!one dimensional@\spxentry{one dimensional}}\ignorespaces 

\section{One Dimensional Arrays}
\label{\detokenize{arrays/onedim:one-dimensional-arrays}}\label{\detokenize{arrays/onedim:one-dim-arrays}}\label{\detokenize{arrays/onedim:index-0}}\label{\detokenize{arrays/onedim::doc}}
\index{array@\spxentry{array}!{[} {]} declaration@\spxentry{{[} {]} declaration}}\ignorespaces 

\subsection{Basic Syntax}
\label{\detokenize{arrays/onedim:basic-syntax}}\label{\detokenize{arrays/onedim:index-1}}
\sphinxAtStartPar
A string is an immutable sequence of characters.  Arrays provide more general sequences,
with the same indexing notation, but with free choice of the type of the items in the
sequence, and the ability to change the elements in the sequence.

\sphinxAtStartPar
For example, if we want the type for an array with \sphinxcode{\sphinxupquote{int}} elements, it is \sphinxcode{\sphinxupquote{int{[}{]}}}.
In general for any element type, the type for an array of the element type is
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type}\sphinxcode{\sphinxupquote{{[}{]}}}
\end{quote}

\sphinxAtStartPar
so

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
declares \sphinxcode{\sphinxupquote{a}} to refer to an array containing \sphinxcode{\sphinxupquote{int}} elements.  You do \sphinxstyleemphasis{not}
know how many elements will be allowed in this array from this declaration.
We must give further information to create the corresponding array object.
A new object can be created using the \sphinxcode{\sphinxupquote{new}} syntax.  An array must get a definite
length, which can be a literal integer or any integer expression.  For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or combined with the declaration,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
creates an array that holds 4 integers.  The elements of the array must get initial values.
Numerical arrays get initialized to all 0’s with this syntax.

\sphinxAtStartPar
For a variety of reasons, including bookkeeping by the compiler, the actual data for
an array is \sphinxstyleemphasis{not} stored directly in the memory location allocated by the declaration.
The array could have any number of items, and hence the memory requirements are not known
at compile time.  Like all other object (as opposed to primitive) types,
what is actually stored at the memory location declared for \sphinxcode{\sphinxupquote{a}} is a \sphinxstyleemphasis{reference} to the
actual place where the data for the array is stored.
In actual compiler implementation this reference is an address in memory.
In diagrams we will illustrate object references with an arrow \sphinxstyleemphasis{pointing} to the actual
location for the object’s data.  For example after \sphinxcode{\sphinxupquote{a}} is initialized:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300bp]{{newArray1}.png}\hspace*{\fill}}

\sphinxAtStartPar
The small box beside \sphinxcode{\sphinxupquote{a}} is meant to indicate the memory space allocated when \sphinxcode{\sphinxupquote{a}} is
declared.  As you can see that space does not actually contain the array, but only a
\sphinxstyleemphasis{reference} to the array, pointing to the actual sequence of data for the array.
To make it easy to refer to the elements in the diagram, we also label the indices
associated with each element, though they are not actual a part of what is stored in memory.

\sphinxAtStartPar
The general syntax to create a  new array is
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{new}} \sphinxstylestrong{type}\sphinxcode{\sphinxupquote{{[}}} \sphinxstyleemphasis{length} \sphinxcode{\sphinxupquote{{]}}}
\end{quote}

\sphinxAtStartPar
After the type, there are square brackets enclosing an expression for the length
of the array \sphinxhyphen{} this length is unchangeable after creation.

\index{{[} {]}@\spxentry{{[} {]}}!array indexing@\spxentry{array indexing}}\index{array@\spxentry{array}!indexing {[} {]}@\spxentry{indexing {[} {]}}}\index{index@\spxentry{index}!array@\spxentry{array}}\ignorespaces 
\sphinxAtStartPar
The elements inside an array can to referenced with the same index notation used
earlier for strings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
refers to the element at index 2 (third element because of 0 based indexing).

\sphinxAtStartPar
Unlike with strings, this element can not only be read, but also be assigned to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
These four assignment statements
would replace the original 0 values for each element in the array.

\sphinxAtStartPar
This is a verbose way to specify all array values. An array with the
same final data could be created with the single declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300bp]{{newArray2}.png}\hspace*{\fill}}

\sphinxAtStartPar
The list in braces ONLY is allowed as an initialization of a variable
in a \sphinxstyleemphasis{declaration}, not in a later assignment statement.
Technically it is an initializer, not an array literal.

\sphinxAtStartPar
Individual array elements can \sphinxstyleemphasis{both} be used in expressions, and be assigned to.
Continuing with the
earlier example code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{o}{*}\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{3}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a{[}2{]}}} now equals 4*5 \sphinxhyphen{} 6 = 14.

\sphinxAtStartPar
Arrays, like strings, have a \sphinxcode{\sphinxupquote{Length}} property:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{b}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints 4}
\end{sphinxVerbatim}

\sphinxAtStartPar
Just as we saw that using a variable for an index was useful with
strings, in practice array elements are almost always referred to with an index
variable.  A very common pattern is to deal with each element in sequence,
and the syntax is the same as for a string.  Print all elements of array \sphinxcode{\sphinxupquote{b}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You could also use \sphinxcode{\sphinxupquote{while}} syntax.  The \sphinxcode{\sphinxupquote{foreach}} syntax would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{foreach}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{int}} type for \sphinxcode{\sphinxupquote{x}} matches the element type of the array \sphinxcode{\sphinxupquote{b}}.

\sphinxAtStartPar
The shorter \sphinxcode{\sphinxupquote{foreach}} syntax is not as general as the \sphinxcode{\sphinxupquote{for}} syntax.
For example, to print only the first \sphinxstyleemphasis{3} elements of b:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
but the \sphinxcode{\sphinxupquote{foreach}} syntax would not work, since it must process \sphinxstyleemphasis{all} elements.

\sphinxAtStartPar
Also use the \sphinxcode{\sphinxupquote{for}} syntax to assign new values to the array elements,
rather than just use the values in expressions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{o}{*}\PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the array \sphinxcode{\sphinxupquote{b}} of our earlier examples (of length 4) would contain 0, 5,
10, and 15.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
There is no analog of \sphinxstyleemphasis{changing} the value of \sphinxcode{\sphinxupquote{b{[}i{]}}} with a
\sphinxcode{\sphinxupquote{foreach}} loop.  To change values in an array, we must
assign to each location in the array by \sphinxstyleemphasis{index}.
A \sphinxcode{\sphinxupquote{foreach}} loop only provides the \sphinxstyleemphasis{value} of each sequence element
for us to read.
\end{sphinxadmonition}

\sphinxAtStartPar
We have had the array indices so far be given by a single symbol,
which is the most common case in practice, but in fact what appears
inside the square braces can be any \sphinxcode{\sphinxupquote{int}} \sphinxstyleemphasis{expression}.
Like parentheses, square brackets \sphinxstyleemphasis{delimit}
the inside expression, which gets evaluated first, before the array value is
looked up.  Consider this csharp sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int[] a = \PYGZob{}5, 9, 15, \PYGZhy{}4\PYGZcb{};
csharp\PYGZgt{} int i = 2;
csharp\PYGZgt{} a[i];
15
\end{sphinxVerbatim}

\sphinxAtStartPar
This should be clear.  Now think first, what should \sphinxcode{\sphinxupquote{a{[}i+1{]}}} be?

\sphinxAtStartPar
…

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} a[i+1];
\PYGZhy{}4
\end{sphinxVerbatim}

\sphinxAtStartPar
In steps:  \sphinxcode{\sphinxupquote{a{[}i+1{]}}} is \sphinxcode{\sphinxupquote{a{[}2+1{]}}} is \sphinxcode{\sphinxupquote{a{[}3{]}}} is \sphinxhyphen{}4. Be careful,
\sphinxcode{\sphinxupquote{a{[}i+1{]}}} is \sphinxstyleemphasis{NOT} \sphinxcode{\sphinxupquote{a{[}i{]} + 1}} (which would be 16).

\index{array@\spxentry{array}!as parameter@\spxentry{as parameter}}\index{example@\spxentry{example}!PrintStrings@\spxentry{PrintStrings}}\ignorespaces \phantomsection\label{\detokenize{arrays/onedim:printstrings}}
\sphinxAtStartPar
The code above to print each element of an array performs a
unified and possibly useful operation, so it would make sense to
encapsulate it into a function.  A function can take any type as a
parameter, so an array type is perfectly reasonable!  Above we
printed each element of an array of integers.  This time let’s choose strings,
so the formal parameter is an array of strings:  \sphinxcode{\sphinxupquote{string{[}{]}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Print the strings in data, one per line.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintStrings}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
With this definition, the code fragment

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{hamlet}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}To be\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}or not\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}to be!\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{PrintStrings}\PYG{p}{(}\PYG{n}{hamlet}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
To be
or not
to be!
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we are just reading the data from the array parameter.
We will see that there are more wrinkles to array parameters in {\hyperref[\detokenize{arrays/onedim:alias}]{\sphinxcrossref{\DUrole{std,std-ref}{References and Aliases}}}}.

\index{function@\spxentry{function}!return array@\spxentry{return array}}\index{array@\spxentry{array}!returned by method@\spxentry{returned by method}}\ignorespaces 
\sphinxAtStartPar
An array type can also be
returned like any other type.  Examine the function definition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return an array with string data obtained from the user.}
\PYG{c+c1}{/// The length of the array and the number of entries to}
\PYG{c+c1}{///   prompt the user for is n.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{InputNStrings}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{lines}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter \PYGZob{}0\PYGZcb{} string(s).\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{lines}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}next string: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{lines}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code follows a standard pattern for functions returning an array:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In order to return an array, we must \sphinxstyleemphasis{first create} a new array
with the \sphinxcode{\sphinxupquote{new}} syntax.  We must set the proper length (\sphinxcode{\sphinxupquote{n}} here).

\item {} 
\sphinxAtStartPar
And we are not done with one line of creation:  Since the array has
multiple parts, we need a loop to assign all the values.  We have a simple
\sphinxcode{\sphinxupquote{for}} loop to assign to each element in turn.

\item {} 
\sphinxAtStartPar
Finally we must return the array that we created!

\end{itemize}


\subsubsection{Follow Array Loop Exercise/Example}
\label{\detokenize{arrays/onedim:follow-array-loop-exercise-example}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What is printed by this program?  Play computer first
to figure out.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ArrayLoop1}
\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//Play computer on this code and then test}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{foo}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{k}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then you can run example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop1/array\_loop1.cs}{array\_loop1/array\_loop1.cs} to check the results and see our
table from playing computer included in the project,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop1/play\_computer1.txt}{array\_loop1/play\_computer1.txt}.

\item {} 
\sphinxAtStartPar
What is printed by this program?  Play computer first
to figure out.  Be careful to keep the data current!

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ArrayLoop2}
\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//Play computer on this code first and then test}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{  }\PYG{p}{\PYGZob{}}\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then you can run example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop2/array\_loop2.cs}{array\_loop2/array\_loop2.cs} to check the results and see our
table from playing computer included in the project,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop2/play\_computer2.txt}{array\_loop2/play\_computer2.txt}.

\item {} 
\sphinxAtStartPar
What is printed by this program?  Play computer first
to figure out.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ArrayLoop3}
\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//Play computer on this code first and then test}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{strArray}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}abcdefgh\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}wxyz\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{strArray}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{o}{/}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then you can run example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop3/array\_loop3.cs}{array\_loop3/array\_loop3.cs} to check the results and see our
table from playing computer included in the project,
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_loop3/play\_computer3.txt}{array\_loop3/play\_computer3.txt}.

\end{enumerate}


\subsubsection{Sign Array Exercise/Example}
\label{\detokenize{arrays/onedim:sign-array-exercise-example}}\label{\detokenize{arrays/onedim:sign-array-exercise}}
\sphinxAtStartPar
Complete the code for this function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return an array contqining the sign (1, \PYGZhy{}1 or 0)}
\PYG{c+c1}{/// of each element of x.}
\PYG{c+c1}{/// For example if x contains elements 2, \PYGZhy{}5, 0, 7,}
\PYG{c+c1}{/// then return a new array containing 1, \PYGZhy{}1, 0, 1.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{Signs1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and place it in a program with a main function that demonstrates it.

\sphinxAtStartPar
You can compare your solution with ours in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sign\_array1/sign\_array1.cs}{sign\_array1/sign\_array1.cs}.

\index{command line@\spxentry{command line}!parameter@\spxentry{parameter}}\index{parameter@\spxentry{parameter}!command line to Main@\spxentry{command line to Main}}\index{Main@\spxentry{Main}!parameters@\spxentry{parameters}}\ignorespaces 

\subsection{Parameters to Main}
\label{\detokenize{arrays/onedim:parameters-to-main}}\label{\detokenize{arrays/onedim:command-line-param}}\label{\detokenize{arrays/onedim:index-5}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Main}} function may take an array of strings as parameter, as in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_param/print\_param.cs}{print\_param/print\_param.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Demonstrate the use of command line parameters.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}There are \PYGZob{}0\PYGZcb{} command line parameters.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
By convention, the formal parameter for \sphinxcode{\sphinxupquote{Main}} is called \sphinxcode{\sphinxupquote{args}},
short for arguments.

\sphinxAtStartPar
Compile and run the program from the command line.
Run it again with some things at the end of the line like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono print\PYGZus{}param.exe hi there 123
\end{sphinxVerbatim}

\sphinxAtStartPar
This should print for you:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
There are 3 command line parameters.
hi
there
123
\end{sphinxVerbatim}

\sphinxAtStartPar
See what quoted strings do.  Use command line parameters (with the quotes)
\sphinxcode{\sphinxupquote{"hi there" 123}}.
This should print for you:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{There}\PYG{+w}{ }\PYG{n}{are}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{n}{command}\PYG{+w}{ }\PYG{n}{line}\PYG{+w}{ }\PYG{n}{parameters}\PYG{p}{.}
\PYG{n}{hi}\PYG{+w}{ }\PYG{n}{there}
\PYG{l+m}{123}
\end{sphinxVerbatim}

\index{Xamarin Studio@\spxentry{Xamarin Studio}!command line parameters@\spxentry{command line parameters}}\index{command line@\spxentry{command line}!parameters in Xamarin Studio@\spxentry{parameters in Xamarin Studio}}\ignorespaces 
\sphinxAtStartPar
You can simulate command line parameters inside Xamarin Studio:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open the local popup menu for the project you are using.

\item {} 
\sphinxAtStartPar
Select Run With \textgreater{}

\item {} 
\sphinxAtStartPar
In the submenu select Custom Parameters.

\item {} 
\sphinxAtStartPar
That brings up a dialog where you can enter the
desired command line parameters.

\item {} 
\sphinxAtStartPar
Optionally you can remember this setup by clicking on
box in front of “Save this configuration as a custom execution mode”.
If you check it, you get a place to enter a Custom Mode Name.

\item {} 
\sphinxAtStartPar
End up clicking the Execute button.

\item {} 
\sphinxAtStartPar
If you set a Custom Mode, later when you get to the submenu after
“Run With \textgreater{}”, you will see your custom mode name to select!

\end{enumerate}

\sphinxAtStartPar
Try it!

\index{Xamarin Studio@\spxentry{Xamarin Studio}!combined with command line execution@\spxentry{combined with command line execution}}\index{command line@\spxentry{command line}!execution combined with Xamarin Studio editing@\spxentry{execution combined with Xamarin Studio editing}}\ignorespaces 
\sphinxAtStartPar
An alternative when you want to use command line parameters repeatedly is
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use Xamarin Studio for editing and compiling.
To compile but not run, the command is \sphinxstylestrong{Build} rather than \sphinxstylestrong{Run}.

\item {} 
\sphinxAtStartPar
Meanwhile keep a console/terminal
window open in the \sphinxcode{\sphinxupquote{Debug}} directory, and enter execution
commands there, including the command line parameters
actually on the command line!
Even if you have a long set of parameters, you can easily run your
program multiple times with the same parameters by just pressing
the up arrow key in the terminal when you see the next command line prompt,
taking you back to the previous command
(or keep going back several commands).  This is also
convenient if you want to slightly edit the parameters: you can
edit a line that you redisplay from your command history.

\item {} 
\sphinxAtStartPar
Do not close this window until you are done with your session of executing
from the command line.  By using the same terminal window, you also
save the history of all your runs.  You can scroll the window up
to see past executions.

\end{enumerate}

\sphinxAtStartPar
If one run leads you to go back and fix a bug, go back to step one to
build the program again, and continue executing in the same terminal window.


\subsubsection{Modified Parameter Print Exercise}
\label{\detokenize{arrays/onedim:modified-parameter-print-exercise}}
\sphinxAtStartPar
Modify a copy of \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_param/print\_param.cs}{print\_param/print\_param.cs} to contain the earlier
example function {\hyperref[\detokenize{arrays/onedim:printstrings}]{\sphinxcrossref{\DUrole{std,std-ref}{PrintStrings}}}}, and call it.

\index{exercise@\spxentry{exercise}!command line adder@\spxentry{command line adder}}\index{command line adder exercise@\spxentry{command line adder exercise}}\index{Main@\spxentry{Main}!parameter exercise@\spxentry{parameter exercise}}\index{parameter@\spxentry{parameter}!for Main exercise@\spxentry{for Main exercise}}\ignorespaces 

\subsubsection{Command Line Adder Exercise}
\label{\detokenize{arrays/onedim:command-line-adder-exercise}}\label{\detokenize{arrays/onedim:index-8}}\label{\detokenize{arrays/onedim:id1}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{adder.cs}} that calculates and prints the sum of
command line parameters, so if you make the command line parameters
in Xamarin Studio be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2 5 22
\end{sphinxVerbatim}

\sphinxAtStartPar
then the program prints 29.

\sphinxAtStartPar
Do try running from the command line:  If you compiled with
Xamarin Studio, that means going down to the bin/Debug directory.
Recall Xamarin Studio for Windows produces a Windows executable,
not a Mono file, so you can run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
adder 2 5 22
\end{sphinxVerbatim}

\sphinxAtStartPar
but on a Mac you need to run with mono:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mono adder.exe 2 5 22
\end{sphinxVerbatim}

\index{string@\spxentry{string}!Split@\spxentry{Split}}\index{Split method for strings@\spxentry{Split method for strings}}\ignorespaces 

\subsection{String Method Split}
\label{\detokenize{arrays/onedim:string-method-split}}\label{\detokenize{arrays/onedim:split}}\label{\detokenize{arrays/onedim:index-9}}
\sphinxAtStartPar
A string method producing an array:
\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{string{[}{]} Split(char}} \sphinxstylestrong{separator} \sphinxcode{\sphinxupquote{)}}}
\sphinxAtStartPar
Returns an array of substrings from \sphinxstyleemphasis{this} string.  They are the pieces left
after chopping out the separator character from the string.
A piece may be the empty string.
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} var fruitString = \PYGZdq{}apple pear banana\PYGZdq{};
csharp\PYGZgt{} string[] fruit = fruitString.Split(\PYGZsq{} \PYGZsq{});
csharp\PYGZgt{} fruit;
\PYGZob{} \PYGZdq{}apple\PYGZdq{}, \PYGZdq{}pear\PYGZdq{}, \PYGZdq{}banana\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} fruit[1];
\PYGZdq{}pear\PYGZdq{}
csharp\PYGZgt{} var s = \PYGZdq{}  extra   spaces \PYGZdq{};
csharp\PYGZgt{} s.Split(\PYGZsq{} \PYGZsq{});
\PYGZob{} \PYGZdq{}\PYGZdq{}, \PYGZdq{}\PYGZdq{}, \PYGZdq{}extra\PYGZdq{}, \PYGZdq{}\PYGZdq{}, \PYGZdq{}\PYGZdq{}, \PYGZdq{}spaces\PYGZdq{}, \PYGZdq{}\PYGZdq{} \PYGZcb{}
\end{sphinxVerbatim}

\end{description}

\sphinxAtStartPar
Note: The response with the list in braces is a purely \sphinxstyleemphasis{csharp} convention for displaying
sequences for the user.  There is no corresponding string displayed by C\# Write commands.
Also see that the string is split at \sphinxstyleemphasis{each} \sphinxcode{\sphinxupquote{separator}},
even if that produces empty strings.

\index{IntsFromString1@\spxentry{IntsFromString1}}\index{index@\spxentry{index}!parallel arrays@\spxentry{parallel arrays}}\ignorespaces \phantomsection\label{\detokenize{arrays/onedim:ints-from-string1}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Split}} is useful for parsing a line with several parts.  You might get a group of
integers on a line of text, for instance from:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}
\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}Please enter some integers, separated by single spaces: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To extract the numbers, you want to the separate the entries in the string
with \sphinxcode{\sphinxupquote{Split}}, \sphinxstyleemphasis{and} you probably want further processing:
If you want them as integers, not strings, you must convert each one separately.

\sphinxAtStartPar
It is useful to put this idea in a function.
See the type returned.  It is an array \sphinxcode{\sphinxupquote{int{[}{]}}} for the int results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return ints taken from space separated integers in a string.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{IntsFromString1}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{input}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{integers}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{input}\PYG{p}{.}\PYG{n}{Split}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{} \PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{integers}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{integers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In a call to \sphinxcode{\sphinxupquote{IntsFromString1("2 5 22")}},  \sphinxcode{\sphinxupquote{integers}} would be
an array containing strings \sphinxcode{\sphinxupquote{"2"}}, \sphinxcode{\sphinxupquote{"5"}}, and \sphinxcode{\sphinxupquote{"22"}}.
We need the conversions to \sphinxcode{\sphinxupquote{int}} to go in a new array that we call \sphinxcode{\sphinxupquote{data}}.
We must set its length, which will clearly be the same as for \sphinxcode{\sphinxupquote{integers}},
\sphinxcode{\sphinxupquote{integers.Length}}.
To assign elements into \sphinxcode{\sphinxupquote{data}} we need a loop providing indices,
like the \sphinxcode{\sphinxupquote{for}} loop provided.  Then for each index, we parse a
string in \sphinxcode{\sphinxupquote{integers}} into an \sphinxcode{\sphinxupquote{int}},
and place the \sphinxcode{\sphinxupquote{int}} in the corresponding location in \sphinxcode{\sphinxupquote{data}}.  We need to return
\sphinxcode{\sphinxupquote{data}} at the end to make it accessible to the caller.

\sphinxAtStartPar
Again we use the basic pattern for returning an array.

\sphinxAtStartPar
Dealing with arrays is hard for many students for several reasons:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You have new array declaration and creation syntax.

\item {} 
\sphinxAtStartPar
Array are compound objects, so there is a lot to think about.

\item {} 
\sphinxAtStartPar
Loops are hard for many people, and you almost always deal with loops.

\item {} 
\sphinxAtStartPar
You usually must deal with index variables, and there are many
patterns.

\end{itemize}

\sphinxAtStartPar
The last point is significant,
so it is important to note the special pattern in the example above:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The use of the same index variable for more than one array is
a standard way to have
\sphinxstyleemphasis{related} entries in \sphinxstyleemphasis{corresponding} positions in the arrays.
\end{sphinxadmonition}

\sphinxAtStartPar
We will introduce a refinement of this function in the
{\hyperref[\detokenize{arrays/onedim:intsfromstring-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{IntsFromString Exercise}}}}.  It will rely on a more complicated
index\sphinxhyphen{}handling pattern.


\subsubsection{NewUpper Exercise}
\label{\detokenize{arrays/onedim:newupper-exercise}}\label{\detokenize{arrays/onedim:new-upper}}
\sphinxAtStartPar
Complete the definition for

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return an array that is the same as data}
\PYG{c+c1}{/// except all strings are in upper case.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{NewUpper}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and write a \sphinxcode{\sphinxupquote{Main}} driver to demonstrate it.  Use the example function
{\hyperref[\detokenize{arrays/onedim:printstrings}]{\sphinxcrossref{\DUrole{std,std-ref}{PrintStrings}}}} in your demonstration.

\index{alias@\spxentry{alias}}\ignorespaces 

\subsection{References and Aliases}
\label{\detokenize{arrays/onedim:references-and-aliases}}\label{\detokenize{arrays/onedim:alias}}\label{\detokenize{arrays/onedim:index-11}}
\sphinxAtStartPar
Object variables, like arrays, are references,
and this has important implications for
assignment.

\sphinxAtStartPar
With a primitive type like an \sphinxcode{\sphinxupquote{int}}, an assignment copies the data:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=90bp]{{intCopy}.png}\hspace*{\fill}}

\sphinxAtStartPar
In the diagram, the contents of the memory box labeled \sphinxcode{\sphinxupquote{b}} is copied to the
memory box labeled \sphinxcode{\sphinxupquote{d}}. The value of \sphinxcode{\sphinxupquote{d}} starts off equal to the value of \sphinxcode{\sphinxupquote{b}},
but can later be changed independently.

\sphinxAtStartPar
Contrast an assignment with arrays.  The value that is copied is the \sphinxstyleemphasis{reference},
not the array data itself, so both end up pointing at the \sphinxstyleemphasis{same}  actual array:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300bp]{{arrayAlias}.png}\hspace*{\fill}}

\sphinxAtStartPar
Hereafter, array assignments like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{10}\PYG{p}{;}
\PYG{n}{d}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{55}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would both change the \sphinxstyleemphasis{same} array.  Now \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{d}} are essentially
names for the same thing (the actual array).  The technical term matches English:
The names are \sphinxstyleemphasis{aliases}.

\sphinxAtStartPar
This may seem like a pretty silly discussion.   Why bother to give two different
names to the same object?  Isn’t one enough?  In fact it is very important
in function/method calls.  An array reference can be passed as an actual value,
and it is the array \sphinxstyleemphasis{reference} that is copied to the formal parameter, so
the formal parameter name is an \sphinxstylestrong{alias} for the actual parameter name.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If an array passed as a parameter to a method has elements changed in the
method, then the change affects the actual parameter array.
The change \sphinxstyleemphasis{remains} in the actual parameter array \sphinxstyleemphasis{after}
the method has terminated.
\end{sphinxadmonition}

\index{example@\spxentry{example}!Scale@\spxentry{Scale}}\index{Scale example@\spxentry{Scale example}}\index{array@\spxentry{array}!parameter@\spxentry{parameter}}\ignorespaces 
\sphinxAtStartPar
For example, consider the following function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Modify a by multiplying all elements by multiplier.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Scale}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{multiplier}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*=}\PYG{+w}{ }\PYG{n}{multiplier}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// or:  a[i] = a[i] * multiplier}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fragment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Scale}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would \sphinxstyleemphasis{change} nums, so it ends up containing elements 10, 20, and 5.


\subsubsection{AllToUpper Exercise}
\label{\detokenize{arrays/onedim:alltoupper-exercise}}\label{\detokenize{arrays/onedim:all-to-upper}}
\sphinxAtStartPar
Complete the function with this heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Modifiy the array data so}
\PYG{c+c1}{///   all strings are in upper case.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{AllToUpper}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Write a \sphinxcode{\sphinxupquote{Main}} method to demonstrate it.  Use the example function
{\hyperref[\detokenize{arrays/onedim:printstrings}]{\sphinxcrossref{\DUrole{std,std-ref}{PrintStrings}}}} to show off your result.


\subsubsection{Sign Array II Exercise/Example}
\label{\detokenize{arrays/onedim:sign-array-ii-exercise-example}}
\sphinxAtStartPar
Create a variation on {\hyperref[\detokenize{arrays/onedim:sign-array-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Sign Array Exercise/Example}}}} with a function
with heading

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Mutate array x, replacing each element by}
\PYG{c+c1}{/// its sign (1, \PYGZhy{}1 or 0)}
\PYG{c+c1}{/// For example if array a contains elements  2, \PYGZhy{}5, 0, 7,}
\PYG{c+c1}{/// then after the call Signs2(a), a contains 1, \PYGZhy{}1, 0, 1.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Signs2}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and a main function to demonstrate it.

\sphinxAtStartPar
You can compare your solution with ours in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sign\_array2/sign\_array2.cs}{sign\_array2/sign\_array2.cs}.

\index{array@\spxentry{array}!anonymous initialization@\spxentry{anonymous initialization}}\ignorespaces 

\subsection{Anonymous Array Initialization}
\label{\detokenize{arrays/onedim:anonymous-array-initialization}}\label{\detokenize{arrays/onedim:index-13}}\label{\detokenize{arrays/onedim:id2}}
\sphinxAtStartPar
Sometimes you only want to use an array with specific values
as a parameter to a function.  You could write something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{SomeFunc}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
but if \sphinxcode{\sphinxupquote{temp}} is never going to be referenced again, you can
do this without using a name:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SomeFunc}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Like with the use of \sphinxcode{\sphinxupquote{var}}, the compiler can infer the type of the array, and the
last example could be shortened to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SomeFunc}\PYG{p}{(}\PYG{k}{new}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is essential to include the \sphinxcode{\sphinxupquote{new int{[}{]}}} or \sphinxcode{\sphinxupquote{new{[}{]}}}
\sphinxstyleemphasis{in addition to}  the \sphinxcode{\sphinxupquote{\{3, 1, 7\}}}.

\sphinxAtStartPar
Such an approach could also be used if you want to return a fixed
length array, where you have values for each parts, as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{minVal}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxVal}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+c1}{// ...}
\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{n}{minVal}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{maxVal}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Testing NewUpper Exercise/Example}
\label{\detokenize{arrays/onedim:testing-newupper-exercise-example}}
\sphinxAtStartPar
Elaborate {\hyperref[\detokenize{arrays/onedim:new-upper}]{\sphinxcrossref{\DUrole{std,std-ref}{NewUpper Exercise}}}} so your \sphinxcode{\sphinxupquote{Main}} method calls
\sphinxcode{\sphinxupquote{NewUpper}} with an anonymous array as part of the demonstration.

\sphinxAtStartPar
You can see our code for all the string array exercises in example project
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/string\_array/string\_array.cs}{string\_array/string\_array.cs}, and with the \sphinxcode{\sphinxupquote{Main}}
demonstration method in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/string\_array/string\_array\_demo.cs}{string\_array/string\_array\_demo.cs}.

\index{OOP@\spxentry{OOP}!default value@\spxentry{default value}}\index{default value in instance@\spxentry{default value in instance}}\ignorespaces 

\subsection{Default Initializations}
\label{\detokenize{arrays/onedim:default-initializations}}\label{\detokenize{arrays/onedim:default-fields}}\label{\detokenize{arrays/onedim:index-14}}
\sphinxAtStartPar
Did you notice that when the first example array of integers was created,
it was filled with zeros?  It is a safety feature of C\# that the internal fields
of objects always get a specific value, not random data.  Here are the defaults:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Default Values}\label{\detokenize{arrays/onedim:id7}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{30}{40}|\X{10}{40}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
\\
\hline
\sphinxAtStartPar
primitive numeric types
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
all object types
&
\sphinxAtStartPar
null
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
An array with elements of object type, like \sphinxcode{\sphinxupquote{string{[}{]}}},
without a specific initializer,
gets initialized to  all \sphinxcode{\sphinxupquote{null}} values.  The creation is totally
legal, but if you try to use the created value, like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{l+m}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// run time error here}
\end{sphinxVerbatim}

\sphinxAtStartPar
The error is because \sphinxcode{\sphinxupquote{null}} is not an object \sphinxhyphen{} it does not have a \sphinxcode{\sphinxupquote{Length}}
property.  If, for example,
you want an array of empty strings you would need to initialize it with
a loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{l+m}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Array Examples and Exercises}
\label{\detokenize{arrays/onedim:array-examples-and-exercises}}
\index{index@\spxentry{index}!variable not in loop heading@\spxentry{variable not in loop heading}}\index{example@\spxentry{example}!remove\_zeros.cs@\spxentry{remove\_zeros.cs}}\ignorespaces 
\sphinxAtStartPar
We have been using array index variables all though this chapter.
We have been getting you started in situations where
they all just advanced continually in a
\sphinxcode{\sphinxupquote{for}} loop heading.  The fanciest situations have been where the same index
is used to reference more than one array in parallel.

\sphinxAtStartPar
Now that you have some experience,
this section will include a variety of exercises where array index
variables need to be manipulated in fancier ways.  Consider this heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a new array with all the 0\PYGZsq{}s that are in}
\PYG{+w}{      }\PYG{c+c1}{/// data removed.  If data contains 0, 3, 0, 0, 5, 9}
\PYG{+w}{      }\PYG{c+c1}{/// then an array containing 3, 5, 9 is returned.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{NoZeros}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have a starting array \sphinxcode{\sphinxupquote{data}} and we need to create an ending array,
but the corresponding nonzero data is \sphinxstyleemphasis{not}
at corresponding index values in \sphinxcode{\sphinxupquote{data}}!

\sphinxAtStartPar
Since we are returning a new array, we need to create it, and for that
we need a length.  How would you do that by hand?
Go through the original array, look at individual elements, and count the nonzero
ones.  We can do a counting loop Say we put our count into the variable
\sphinxcode{\sphinxupquote{countNonZero}}. Then create a new \sphinxcode{\sphinxupquote{int}} array, say \sphinxcode{\sphinxupquote{notzero}},  with the
proper length.

\sphinxAtStartPar
The next part is new.  Clearly we need to get non\sphinxhyphen{}zero values from the original array
\sphinxcode{\sphinxupquote{data}} and put them in the other array, \sphinxcode{\sphinxupquote{notzero}}.
As we said, the array indices are
not in sync.  That means we are going to need to deal with their indices
separately: The index in \sphinxcode{\sphinxupquote{data}} is not going to relate directly to the
index in \sphinxcode{\sphinxupquote{notzero}}.

\sphinxAtStartPar
We could just have a separate index variable for each array.
Think about \sphinxcode{\sphinxupquote{data}}:
We do want to go through it sequentially, and we are only \sphinxstyleemphasis{reading} the
sequential values, so we can actually use a \sphinxcode{\sphinxupquote{foreach}} loop and not
keep track of that index directly at all!

\sphinxAtStartPar
On the other hand we need to assign values \sphinxstyleemphasis{into} \sphinxcode{\sphinxupquote{notzero}}, and hence we will
need to refer to an index variable for \sphinxcode{\sphinxupquote{notzero}},
say \sphinxcode{\sphinxupquote{i}}.

\sphinxAtStartPar
However, we cannot just assign the index values in a
\sphinxcode{\sphinxupquote{for}} loop heading as we have been before!
We have to be more careful and think when and how does \sphinxcode{\sphinxupquote{i}} change?

\sphinxAtStartPar
This might be a good place to do this by hand, for instance with the sample
data in the function documentation.  Keep track of what \sphinxcode{\sphinxupquote{i}}
should be as you iterate through the elements of \sphinxcode{\sphinxupquote{data}}, one step at a time:
How do you change
\sphinxcode{\sphinxupquote{i}} and when?  You are \sphinxstyleemphasis{encouraged} to stop and actually do this manually,
on paper, and think before going on….

\sphinxAtStartPar
You should see that:
\begin{itemize}
\item {} 
\sphinxAtStartPar
We start by being ready to fill the place at index 0 in \sphinxcode{\sphinxupquote{notzero}}.

\item {} 
\sphinxAtStartPar
We only copy a non\sphinxhyphen{}zero element of \sphinxcode{\sphinxupquote{data}}, so we need an \sphinxcode{\sphinxupquote{if}}
statement in the body again.

\item {} 
\sphinxAtStartPar
Each such non\sphinxhyphen{}zero number
is placed after the last number we copied into \sphinxcode{\sphinxupquote{notzero}}.

\item {} 
\sphinxAtStartPar
This means that each time we copy an element to \sphinxcode{\sphinxupquote{notzero}} we advance \sphinxcode{\sphinxupquote{i}}!

\end{itemize}

\sphinxAtStartPar
If you get those ideas together, hopefully you can write the needed code.
Our version is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Return a new array with all the 0\PYGZsq{}s that are in}
\PYG{c+c1}{/// data removed.  If data contains 0, 3, 0, 0, 5, 9}
\PYG{c+c1}{/// then an array containing 3, 5, 9 is returned.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{NoZeros}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{countNonZero}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//find new length}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{countNonZero}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{notzero}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{countNonZero}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// index where to put the next value}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// copy non\PYGZhy{}zero elements}
\PYG{+w}{         }\PYG{n}{notzero}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{notzero}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Adding a \sphinxcode{\sphinxupquote{Main}} demostration method, you get our full example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/remove\_zeros/remove\_zeros.cs}{remove\_zeros/remove\_zeros.cs}.


\subsubsection{Initialization Exercise}
\label{\detokenize{arrays/onedim:initialization-exercise}}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{NoZeros}} function above,
what are the values in the array \sphinxcode{\sphinxupquote{notzero}} just after
line 12 is executed?

\item {} 
\sphinxAtStartPar
In the {\hyperref[\detokenize{arrays/onedim:new-upper}]{\sphinxcrossref{\DUrole{std,std-ref}{NewUpper Exercise}}}}  or our version of \sphinxcode{\sphinxupquote{NewUpper}} in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/string\_array/string\_array\_demo.cs}{string\_array/string\_array\_demo.cs}
consider the execution of the \sphinxcode{\sphinxupquote{NewUpper}} function
immediately after you first create
the string array that you are going to later return.
Right then, what are the element values in that array?

\end{enumerate}

\index{exercise@\spxentry{exercise}!ExtractItems@\spxentry{ExtractItems}}\index{ExtractItems exercise@\spxentry{ExtractItems exercise}}\ignorespaces 

\subsubsection{ExtractItems Exercise}
\label{\detokenize{arrays/onedim:extractitems-exercise}}\label{\detokenize{arrays/onedim:index-16}}
\sphinxAtStartPar
A string intended to indicate a sequence of items could be like in the
discussion  above of {\hyperref[\detokenize{arrays/onedim:ints-from-string1}]{\sphinxcrossref{\DUrole{std,std-ref}{IntsFromString1}}}}.
As illustrated there, individual items
are separated out neatly with \sphinxcode{\sphinxupquote{Split}}.  If you want to act on a user\sphinxhyphen{}generated
string, it is probably better to allow more leeway:
Commas are often used to separate items or comma with blank, or several blanks.

\sphinxAtStartPar
In this exercise write a version that will accept all those variations
and return an array of non\sphinxhyphen{}empty strings, without the commas or blanks.
Complete this function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return an array of non\PYGZhy{}empty strings that are separated}
\PYG{c+c1}{/// in the original string by any combination of commas and blanks.}
\PYG{c+c1}{/// Example:  ExtractItems(\PYGZdq{}  extra  spaces,plus,  more, \PYGZdq{}) returns an}
\PYG{c+c1}{/// array containing \PYGZob{}\PYGZdq{}extra\PYGZdq{}, \PYGZdq{}spaces\PYGZdq{}, \PYGZdq{}plus\PYGZdq{}, \PYGZdq{}more\PYGZdq{}\PYGZcb{}}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{ExtractItems}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Hints: It is possible to deal with more than one separator character, but
the simplest thing likely is to use string method \sphinxcode{\sphinxupquote{Replace}}
and just replace all the
commas by spaces.  If you then \sphinxcode{\sphinxupquote{Split}} on each space you get all the non\sphinxhyphen{}empty
strings that you want \sphinxstyleemphasis{and} maybe a number of
empty strings.  You need to create a final array with just the nonempty
strings from the split.  When you create the array to be returned,
you need know its size.  Then populate it
with just the nonempty string pieces.
Handling the indices for the new array also adds complication.


\subsubsection{IntsFromString Exercise}
\label{\detokenize{arrays/onedim:intsfromstring-exercise}}\label{\detokenize{arrays/onedim:id3}}
\sphinxAtStartPar
Write a function
\sphinxcode{\sphinxupquote{IntsFromString}} with a corresponding signature and intent
like {\hyperref[\detokenize{arrays/onedim:ints-from-string1}]{\sphinxcrossref{\DUrole{std,std-ref}{IntsFromString1}}}}, but make it
more robust by allowing all the separator combinations of
\sphinxcode{\sphinxupquote{ExtractItems}} from the last exercise, so
\sphinxcode{\sphinxupquote{IntsFromString(" 2, 33  4,55 6 77  ")}} returns an array containing \sphinxcode{\sphinxupquote{int}}
values 2, 33, 4, 55, 6, 77.  (Don’t reinvent the wheel: call \sphinxcode{\sphinxupquote{ExtractItems}}.)
Also write a \sphinxcode{\sphinxupquote{Main}} function so you can demonstrate the use of
\sphinxcode{\sphinxupquote{IntsFromString}}.

\index{exercise@\spxentry{exercise}!TrimAll for arrays@\spxentry{TrimAll for arrays}}\index{TrimAll exercise@\spxentry{TrimAll exercise}}\ignorespaces 

\subsubsection{Trim All Exercise}
\label{\detokenize{arrays/onedim:trim-all-exercise}}\label{\detokenize{arrays/onedim:index-17}}\label{\detokenize{arrays/onedim:id4}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{trimmer.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Trim all elements of a and replace them in the array.}
\PYG{c+c1}{//  Example: If a contains \PYGZob{}\PYGZdq{} is  \PYGZdq{}, \PYGZdq{} it\PYGZdq{}, \PYGZdq{}trimmed?   \PYGZdq{}\PYGZcb{}}
\PYG{c+c1}{//  then after the function call the array contains}
\PYG{c+c1}{//  \PYGZob{}\PYGZdq{}is\PYGZdq{}, \PYGZdq{}it\PYGZdq{}, \PYGZdq{}trimmed?\PYGZdq{}\PYGZcb{}.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{TrimAll}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!Dups@\spxentry{Dups}}\index{Dups exercise for arrays@\spxentry{Dups exercise for arrays}}\ignorespaces 

\subsubsection{Count Duplicates Exercise}
\label{\detokenize{arrays/onedim:count-duplicates-exercise}}\label{\detokenize{arrays/onedim:dups-exercise}}\label{\detokenize{arrays/onedim:index-18}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{count\_dups.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Return the number of duplicate pairs in an array a.}
\PYG{c+c1}{// Example: for elements 2, 5, 1, 5, 2, 5}
\PYG{c+c1}{// the return value would be 4 (one pair of 2\PYGZsq{}s three pairs of 5\PYGZsq{}s.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{dups}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!Mirror@\spxentry{Mirror}}\index{Mirror exercise for arrays@\spxentry{Mirror exercise for arrays}}\ignorespaces 

\subsubsection{Mirror Array Exercise}
\label{\detokenize{arrays/onedim:mirror-array-exercise}}\label{\detokenize{arrays/onedim:mirror-exercise}}\label{\detokenize{arrays/onedim:index-19}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{make\_mirror.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create a new array with the elements of a in the opposite order.}
\PYG{c+c1}{// \PYGZob{}\PYGZdq{}aA\PYGZdq{}, \PYGZdq{}bB\PYGZdq{}, \PYGZdq{}cC\PYGZdq{}\PYGZcb{} produces a new array \PYGZob{}\PYGZdq{}cC\PYGZdq{}, \PYGZdq{}bB\PYGZdq{}, \PYGZdq{}aA\PYGZdq{}\PYGZcb{}}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{Mirror}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!Reverse for arrays@\spxentry{Reverse for arrays}}\index{Reverse exercise for arrays@\spxentry{Reverse exercise for arrays}}\ignorespaces 

\subsubsection{Reverse Array Exercise}
\label{\detokenize{arrays/onedim:reverse-array-exercise}}\label{\detokenize{arrays/onedim:reverse-exercise}}\label{\detokenize{arrays/onedim:index-20}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{reverse\_array.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Reverse the order of array elements}
\PYG{c+c1}{// If array a first contains \PYGZdq{}aA\PYGZdq{}, \PYGZdq{}bB\PYGZdq{}, \PYGZdq{}cC\PYGZdq{},}
\PYG{c+c1}{// than it ends up containing \PYGZdq{}cC\PYGZdq{}, \PYGZdq{}bB\PYGZdq{}, \PYGZdq{}aA\PYGZdq{}.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Reverse}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Do this \sphinxstyleemphasis{without} creating a second array.  (There is a
trick here.)

\index{exercise@\spxentry{exercise}!Histogram@\spxentry{Histogram}}\index{Histogram exercise@\spxentry{Histogram exercise}}\ignorespaces 

\subsubsection{Histogram Exercise}
\label{\detokenize{arrays/onedim:histogram-exercise}}\label{\detokenize{arrays/onedim:index-21}}\label{\detokenize{arrays/onedim:id5}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{make\_histogram.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Return a histogram array counting repetitions of values}
\PYG{c+c1}{// start through end in array a.  The count for value start+i}
\PYG{c+c1}{// is at index i of the returned array, starting at i == 0.}
\PYG{c+c1}{// For example:}
\PYG{c+c1}{// Histogram(new int[]\PYGZob{}2, 0, 3, 5, 3, 5\PYGZcb{}, 2, 5) counts how}
\PYG{c+c1}{// many times the numbers 2 through 5, inclusive, occur in}
\PYG{c+c1}{// the original array, and returns a new array containing}
\PYG{c+c1}{// \PYGZob{}1, 2, 0, 2\PYGZcb{}, that is, 1 2, 2 3\PYGZsq{}s, 0 4\PYGZsq{}s, and 2 5\PYGZsq{}s. The}
\PYG{c+c1}{// count of 2\PYGZsq{}s appears as the first (0th) element of the}
\PYG{c+c1}{// returned array, the count of 3\PYGZsq{}s as the second, etc.}
\PYG{c+c1}{// Similarly, Histogram(new int[]\PYGZob{}2, 0, 3, 5, 3, 5\PYGZcb{}, \PYGZhy{}1, 1)}
\PYG{c+c1}{// returns the new array \PYGZob{}0, 1, 0\PYGZcb{},}
\PYG{c+c1}{// that is, 0 \PYGZhy{}1\PYGZsq{}s, 1 0, and 0 1\PYGZsq{}s.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{Histogram}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This problem clearly requires you to loop through all the elements of
array \sphinxcode{\sphinxupquote{a}}.  You should \sphinxstyleemphasis{not} need any further nested loop.


\subsubsection{Histogram Interval Exercise}
\label{\detokenize{arrays/onedim:histogram-interval-exercise}}\label{\detokenize{arrays/onedim:id6}}
\sphinxAtStartPar
This is a slight elaboration of the previous problem, where
you count entries in intervals, not just of width 1.

\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{make\_histogram2.cs}} that includes and tests a
function with heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Return a histogram array counting repetitions of values}
\PYG{c+c1}{// in array a in the n half\PYGZhy{}open intervals [start, start + width),}
\PYG{c+c1}{// [start+width, start+2*width), ... [}
\PYG{c+c1}{// [start + (n\PYGZhy{}1)*width, start + n*width) .  The counts for}
\PYG{c+c1}{// each of the n intervals, in order, goes in the returned array}
\PYG{c+c1}{// of length n.  For example}
\PYG{c+c1}{// Histogram(new[]\PYGZob{}89, 69, 100, 83, 99, 81\PYGZcb{}, 60, 10, 5)}
\PYG{c+c1}{// would return an array containing counts 1, 0, 3, 1, 1,}
\PYG{c+c1}{// for 1 in sixties, 0 in seventies, 3 in eighties, 1 in nineties,}
\PYG{c+c1}{// and 1 in range 100 through 109.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{HistogramIntervals}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{,}
\PYG{+w}{                                       }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The previous exercise version \sphinxcode{\sphinxupquote{Histogram(a, start, end)}}
would return the same
result as \sphinxcode{\sphinxupquote{HistogramIntervals(a, start, 1, end\sphinxhyphen{}start+1)}}.

\sphinxAtStartPar
Again, the only loop needed should be to process each element of \sphinxcode{\sphinxupquote{a}}.

\index{exercise@\spxentry{exercise}!power table 2@\spxentry{power table 2}}\ignorespaces 

\subsubsection{Power Table Exercise 2}
\label{\detokenize{arrays/onedim:power-table-exercise-2}}\label{\detokenize{arrays/onedim:power-table-exercise2}}\label{\detokenize{arrays/onedim:index-22}}
\sphinxAtStartPar
Write a program \sphinxcode{\sphinxupquote{power\_table2.cs\textasciigrave{}}} producing a table much
like {\hyperref[\detokenize{for/forexamples:power-table-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Power Table Exercise}}}}, with right\sphinxhyphen{}justified columns,
but this time make each separate column have the minimum width
necessary \sphinxhyphen{} so there is a single space (and no less)
in front of some entry in
\sphinxstyleemphasis{each} column, except the first.
Be careful: take the heading widths into account; the
parameter limits are important, too; test them:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Print a table of powers of positive integers.}
\PYG{c+c1}{/// Assume 1 \PYGZlt{}= nMax \PYGZlt{}= 14, 1 \PYGZlt{}= powerMax \PYGZlt{}= 10}
\PYG{c+c1}{/// Example: output of PowerTable(4, 5)}
\PYG{c+c1}{/// n\PYGZca{}1 n\PYGZca{}2 n\PYGZca{}3 n\PYGZca{}4  n\PYGZca{}5}
\PYG{c+c1}{///   1   1   1   1    1}
\PYG{c+c1}{///   2   4   8  16   32}
\PYG{c+c1}{///   3   9  27  81  243}
\PYG{c+c1}{///   4  16  64 256 1024}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PowerTable}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nMax}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{powerMax}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Musical Scales and Arrays}
\label{\detokenize{arrays/music:musical-scales-and-arrays}}\label{\detokenize{arrays/music::doc}}
\sphinxAtStartPar
Music in the western classical tradition uses a twelve\sphinxhyphen{}tone \sphinxstyleemphasis{chromatic}
scale. Any of the tones in this scale can be the basis of a major scale.
Most musicians (especially pianists) learn the C\sphinxhyphen{}major scale in the early
days of study, owing to the ability to play this scale entirely with the
ivory (white) keys.

\sphinxAtStartPar
The following declaration shows how to initialize an array consisting
of the twelve tones of the chromatic scale, starting from the C note.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{tones}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}C\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}C\PYGZsh{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}D\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}D\PYGZsh{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}E\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}F\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                          }\PYG{l+s}{\PYGZdq{}F\PYGZsh{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}G\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}G\PYGZsh{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}A\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}A\PYGZsh{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}B\PYGZdq{}}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Even if you’re not a musician, learning the basic principles is fairly
straightforward.

\sphinxAtStartPar
The well\sphinxhyphen{}known C\sphinxhyphen{}major scale, which is often sung as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Do}\PYG{+w}{ }\PYG{n}{Re}\PYG{+w}{ }\PYG{n}{Mi}\PYG{+w}{ }\PYG{n}{Fa}\PYG{+w}{ }\PYG{n}{So}\PYG{+w}{ }\PYG{n}{La}\PYG{+w}{ }\PYG{n}{Ti}\PYG{+w}{ }\PYG{n}{Do}
\end{sphinxVerbatim}

\sphinxAtStartPar
has the following progression:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{C}\PYG{+w}{  }\PYG{n}{D}\PYG{+w}{  }\PYG{n}{E}\PYG{+w}{  }\PYG{n}{F}\PYG{+w}{  }\PYG{n}{G}\PYG{+w}{  }\PYG{n}{A}\PYG{+w}{  }\PYG{n}{B}\PYG{+w}{  }\PYG{n}{C}
\end{sphinxVerbatim}

\sphinxAtStartPar
This progression is known as the \sphinxstyleemphasis{diatonic major} scale. If you look at
the \sphinxcode{\sphinxupquote{tones}} array, you can actually figure out the intervals associated
with this array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
C + 2 = D
D + 2 = E
E + 1 = F
F + 2 = G
G + 2 = A
A + 2 = B
B + 1 = C
\end{sphinxVerbatim}

\sphinxAtStartPar
So given any starting note, the major scale can be \sphinxstyleemphasis{generated} from the
intervals (represented as an array).

\sphinxAtStartPar
So, for example, if you want the F\sphinxhyphen{}major scale, you can get it by starting
at F and applying the steps of 2, 2, 1, 2, 2, 2, 1:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
F + 2 = G
G + 2 = A
A + 1 = B\PYGZsq{} (flat) a.k.a. A\PYGZsh{})
B\PYGZsq{}+ 2 = C
C + 2 = D
D + 2 = E
E + 1 = F
\end{sphinxVerbatim}

\sphinxAtStartPar
So this is the F\sphinxhyphen{}major scale:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{none}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
F G A B’ C D E F
\end{quote}

\sphinxAtStartPar
We begin by creating a helper function, \sphinxcode{\sphinxupquote{FindTone()}}, which does a
linear search to find the key of the scale we want to compute. The
aim is to make it easy for the user to just specify the key of interest.
Then we can use this position to compute the scale given the major
(or minor, covered shortly) interval array.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{FindTone}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{key}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{tones}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{key}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{tones}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To see what this function does, pick your favorite key (C and G are very
common for beginners).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FindTone("C")}} gives 0, the first position in the \sphinxcode{\sphinxupquote{tones}} array.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FindTone("G")}} gives 8.

\end{itemize}

\sphinxAtStartPar
For example,
C is the first note in the array of tones, so \sphinxcode{\sphinxupquote{FindTone("C")}} would give
us 0. \sphinxcode{\sphinxupquote{FindTone("F")}} would give us 6.

\sphinxAtStartPar
So let’s take a look at \sphinxcode{\sphinxupquote{ComputeScale()}} which does the work of
computing a scale, given a key and an array of steps. The scale array
is allocated by the \sphinxcode{\sphinxupquote{Main()}} method, primarily to allow the same
array to be used repeatedly for calculating other scales.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ComputeScale}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{key}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{steps}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{tonePosition}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{startTone}\PYG{p}{;}

\PYG{+w}{   }\PYG{n}{startTone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{FindTone}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{startTone}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{steps}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{o}{+}\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{return}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{tonePosition}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{startTone}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{steps}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{scale}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{tonePosition}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{tones}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{tonePosition}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{steps}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The first thing to note is the \sphinxstyleemphasis{setup} of this code. We’re going to
keep the \sphinxcode{\sphinxupquote{startTone}} (obtained by calling \sphinxcode{\sphinxupquote{FindTone()}}) and
\sphinxcode{\sphinxupquote{tonePosition}}, which is the note we are presently visiting in
the \sphinxcode{\sphinxupquote{tones}} array.

\item {} 
\sphinxAtStartPar
Remember that every scale (e.g. C, D, F\#, etc.) can always be
obtained by looking at \sphinxcode{\sphinxupquote{tones}} and using the appropriate
intervals (the \sphinxcode{\sphinxupquote{steps}} parameter) to compute the next note, given
a current note.

\item {} 
\sphinxAtStartPar
We do some simple checks in line 6 (to ensure that a valid key
was specified by the caller) and in line 8 to ensure that the
number of steps + 1 is the length of the scale\textendash{}and the length
of the scale is 8. (We technically don’t have to limit the scale
to 8, because scales can keep going until you run out of playable
notes on the instrument.)

\item {} 
\sphinxAtStartPar
We’ll now start at the initial position (where we found the base
note of the key) and enter a for loop to compute all of the notes
in the scale. This loop iterates over the entries in the \sphinxcode{\sphinxupquote{steps}}
array to decide what the next note is.

\item {} 
\sphinxAtStartPar
The next note in the scale, \sphinxcode{\sphinxupquote{scale{[}i{]}}} is computed by taking
\sphinxcode{\sphinxupquote{tonePosition \% tones.GetLength(0)}}. We need to do this, because
in most scales, you will eventually end up “falling off the end”
of the \sphinxcode{\sphinxupquote{tones}} array, which mens that you need to continue
computing notes from the \sphinxstyleemphasis{beginning} of the array. You can inspect
this for yourself by picking a scale (say, B) that is starting at
the end of the \sphinxcode{\sphinxupquote{tones}} array. This means you will need to go
to the beginning of the array to get C\# (which is 2 tones away
from B).

\item {} 
\sphinxAtStartPar
The next note is found by adding \sphinxcode{\sphinxupquote{steps{[}i{]}}} to \sphinxcode{\sphinxupquote{tonePosition}}.

\end{enumerate}

\sphinxAtStartPar
The following function writes the scale out (rather naively) by just
printing the notes from our existing \sphinxcode{\sphinxupquote{tones}} array.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{WriteScale}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{tones}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We say that the output is \sphinxstyleemphasis{naive} because any musician will tell you
that a scale should be printed in a normalized way. For example, the F\sphinxhyphen{}major
scale (shown above in our earlier explanation) is never written with A\# as
one of its notes. It is written as B\sphinxhyphen{}flat. It’s easy to manage the various
cases by consulting the circle of fifths, which gives us guidance on the
number of flats/sharps each scale has.

\sphinxAtStartPar
Lastly, we put this all together.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{scale}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{8}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{major}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{minor}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// need command line tone name}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} major scale\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{ComputeScale}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{major}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{WriteScale}\PYG{p}{(}\PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} minor scale\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{ComputeScale}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minor}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{WriteScale}\PYG{p}{(}\PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This \sphinxcode{\sphinxupquote{Main()}} method shows how to set up the steps for both major
and minor scales. We’ve already explained how to express the steps of
a major scale. The minor scale basically drops the 3rd and 7th by a
semitone (a single step), which gives us a different pattern.

\sphinxAtStartPar
You can run this program to see the major and minor scales.

\sphinxstepscope


\section{Linear Searching}
\label{\detokenize{arrays/searching:linear-searching}}\label{\detokenize{arrays/searching:searching}}\label{\detokenize{arrays/searching::doc}}
\sphinxAtStartPar
In this section, we’ll take a look at how to search for a value in an
array.  Although a fairly straightforward topic, it is one that comes
up repeatedly in programming.

\index{algorithms@\spxentry{algorithms}!linear search@\spxentry{linear search}}\index{search@\spxentry{search}!linear@\spxentry{linear}}\index{linear search@\spxentry{linear search}}\ignorespaces 

\subsection{Linear Search}
\label{\detokenize{arrays/searching:linear-search}}\label{\detokenize{arrays/searching:index-0}}
\sphinxAtStartPar
By far, one of the most common searches you will see in typical
programs. It also happens to be one of the more \sphinxstyleemphasis{misused} searches,
which is another reason we want you to know about it.

\sphinxAtStartPar
Here is the code from example \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/searching/searching.cs}{searching/searching.cs}
to perform a linear search for an integer in an
array:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Return the index of the first position in data}
\PYG{c+c1}{/// where item appears, or \PYGZhy{}1 if item does not appear.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{IntArrayLinearSearch}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{=}\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here’s what it does:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In lines 5\sphinxhyphen{}6 we set up a loop to go from 0 to N\sphinxhyphen{}1. We often use N
to indicate the size of the array (and it’s much easier to type
than \sphinxcode{\sphinxupquote{data.Length}}.

\item {} 
\sphinxAtStartPar
In line 7, we see whether we found a match for the item we are searching.
If we find the match, we immediately leave the loop by returning the
position where it was found.

\item {} 
\sphinxAtStartPar
It is worth noting here that the array, \sphinxcode{\sphinxupquote{data}}, may or my not
be in sorted order. So our search reports the first location where
we found the value. It is entirely possible that the more than
one position in the array contains the matching value. If you
wanted to find the next one, you could modify the \sphinxcode{\sphinxupquote{IntArrayLinearSearch()}}
method to have a third parameter, \sphinxcode{\sphinxupquote{start}}, that allows us
to continue searching from where we left off. It might look
something like the following:

\end{itemize}

\sphinxAtStartPar
The following code in \sphinxcode{\sphinxupquote{Main}} of \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/searching/searching\_demo.cs}{searching/searching\_demo.cs}
demonstrates how to use the linear search:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}
\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}Please enter integers, separated by spaces and/or comma: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ExtractFromString}\PYG{p}{.}\PYG{n}{IntsFromString}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}data[\PYGZob{}0\PYGZcb{}]=\PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}Please enter a number to find (blank line to end): \PYGZdq{}}\PYG{p}{;}
\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{input}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{searchItem}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{searchPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptIntInRange}\PYG{p}{(}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}At what position should the search start? \PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{foundPos}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{      }\PYG{n}{Searching}\PYG{p}{.}\PYG{n}{IntArrayLinearSearch}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{searchItem}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{searchPos}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{foundPos}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Item \PYGZob{}0\PYGZcb{} not found\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{searchItem}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Item \PYGZob{}0\PYGZcb{} found at position \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                        }\PYG{n}{searchItem}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{foundPos}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, we ask the user to enter all the data for the array
on one line. To convert the string to an int array we
use the result of the {\hyperref[\detokenize{arrays/onedim:intsfromstring-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{IntsFromString Exercise}}}} that we put in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/searching/extract\_from\_string.cs}{searching/extract\_from\_string.cs}.

\sphinxAtStartPar
To allow easy termination of the testing loop, we do not use \sphinxcode{\sphinxupquote{PromptInt}}
for \sphinxcode{\sphinxupquote{searchItem}}, because any
\sphinxcode{\sphinxupquote{int}} could be the search target.  By using \sphinxcode{\sphinxupquote{PromptLine}}, we can allow an empty
string as the response, and we test for that to terminate the loop.

\sphinxAtStartPar
The rest is mostly self\sphinxhyphen{}explanatory.

\sphinxstepscope

\index{PF4@\spxentry{PF4}}\index{recursion@\spxentry{recursion}}\index{SP1@\spxentry{SP1}}\index{history@\spxentry{history}}\index{sorting@\spxentry{sorting}}\ignorespaces 

\section{Sorting Algorithms}
\label{\detokenize{arrays/sorting:sorting-algorithms}}\label{\detokenize{arrays/sorting:sorting}}\label{\detokenize{arrays/sorting:index-0}}\label{\detokenize{arrays/sorting::doc}}
\sphinxAtStartPar
Sorting algorithms represent foundational knowledge that every computer scientist and
IT professional should at least know at a basic level. And it turns out to be a great
way of learning about why arrays are important.

\sphinxAtStartPar
In this section, we’re going to take a look at a number of well\sphinxhyphen{}known sorting algorithms
with the hope of sensitizing you to the notion of \sphinxstyleemphasis{performance}\textendash{}a topic that is covered
in greater detail in courses such as algorithms and data structures.

\sphinxAtStartPar
This is not intended to be a comprehensive reference at all. The idea is to learn how
these classic algorithms are coded in the teaching language for this course, C\#, and to
understand the essentials of analyzing their performance, both theoretically and
experimentally. For a full theoretical treatment, we recommend the outstanding textbook
by Niklaus Wirth \sphinxcite{arrays/sorting:wirthadp}, who invented the Pascal language. (We have also adapted
some examples from Thomas W. Christopher’s \sphinxcite{arrays/sorting:tcsortingjava} animated sorting algorithms
page.

\sphinxAtStartPar
The sorts and supporting functions are all in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting.cs}{sorting/sorting.cs}, but we start one bit at a time:

\index{exchanging array elements@\spxentry{exchanging array elements}}\index{array@\spxentry{array}!exchange elements@\spxentry{exchange elements}}\ignorespaces 

\subsection{Exchanging Array Elements}
\label{\detokenize{arrays/sorting:exchanging-array-elements}}\label{\detokenize{arrays/sorting:index-1}}
\sphinxAtStartPar
We’ll begin by introducing you to a simple method, whose only purpose in life is to
swap two data values at positions \sphinxcode{\sphinxupquote{m}} and \sphinxcode{\sphinxupquote{n}} in a given integer array:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Exchange the elements of data at indices m and n.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Exchange}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{temporary}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{data}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{data}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temporary}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example if we have an array nums, shown with indices:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 nums: \PYGZhy{}1  8 11 22  9 \PYGZhy{}5  2
index:  0  1  2  3  4  5  6
\end{sphinxVerbatim}

\sphinxAtStartPar
Then after \sphinxcode{\sphinxupquote{Exchange(nums, 2, 5)}} the array would look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 nums: \PYGZhy{}1  8 \PYGZhy{}5 22  9 11  2
index:  0  1  2  3  4  5  6
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, swapping two values in an array is
no different than swapping any two integers.
Suppose we have the following integers \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}

\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{25}\PYG{p}{;}
\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{35}\PYG{p}{;}
\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
After this code does its job, the value of \sphinxcode{\sphinxupquote{a}} would be 35
and the value of \sphinxcode{\sphinxupquote{b}} would be 25.

\sphinxAtStartPar
So in the \sphinxcode{\sphinxupquote{Exchange()}} function above,
if we have two different array elements at positions \sphinxcode{\sphinxupquote{m}} and \sphinxcode{\sphinxupquote{n}},
we are basically getting each value at these positions,
e.g. \sphinxcode{\sphinxupquote{data{[}m{]}}} and \sphinxcode{\sphinxupquote{data{[}n{]}}} and treating them
as if they were \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} in the above code.

\sphinxAtStartPar
You might find it helpful at this time to verify that
the above code does what we’re saying it does, and a
good way is to type it directly into the C\# interpreter (csharp)
so you can see it for yourself.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Exchange()}} function is vital to all of the sorting algorithms in the following way.
It is used whenever two items are found to be out of order.
When this occurs, they will be \sphinxstyleemphasis{swapped}. This doesn’t mean
that the item comes to its final resting place in the array.
It just means that for the moment, the items
have been reordered so we’ll get closer to having a sorted array.

\sphinxAtStartPar
Let’s now take a look at the various sorting algorithms.

\index{sorting@\spxentry{sorting}!bubble sort@\spxentry{bubble sort}}\index{algorithms@\spxentry{algorithms}!bubble sort@\spxentry{bubble sort}}\index{array@\spxentry{array}!nested loop@\spxentry{nested loop}}\index{bubble sort@\spxentry{bubble sort}}\ignorespaces 

\subsection{Bubble Sort}
\label{\detokenize{arrays/sorting:bubble-sort}}\label{\detokenize{arrays/sorting:index-2}}
\sphinxAtStartPar
The Bubble Sort algorithm works by repeatedly scanning
through the array exchanging adjacent elements that are out of order.  Watching
this work with a strategically\sphinxhyphen{}placed \sphinxcode{\sphinxupquote{Console.WriteLine()}} in the outer
loop, you will see that the sorted array grows right to left. Each
sweep picks up the largest remaining element and moves to the right as
far as it can go. It is therefore not necessary to scan through the
entire array each sweep, but only to the beginning of the sorted
portion.

\sphinxAtStartPar
We define the number of \sphinxstyleemphasis{inversions} as the number of element pairs that
are out of order. They needn’t be adjacent. If \sphinxcode{\sphinxupquote{data{[}7{]} \textgreater{} data{[}16{]}}},
that’s an inversion. Every time an inversion is required,
we also say that there is corresponding data \sphinxstyleemphasis{movement}. If you look at the
\sphinxcode{\sphinxupquote{Exchange()}} code, you’ll observe that a swap requires three movements
to take place, which happens very quickly on most processors but still amounts
to a significant cost.

\sphinxAtStartPar
There can be at most \(N \cdot \frac{N-1}{2}\) inversions in the
array of length \(N\). The maximum
number of inversions occurs when the array is sorted in reverse order
and has no equal elements.

\sphinxAtStartPar
Bubble Sort exchanges only adjacent elements.
Each such exchange removes precisely one inversion; therefore,
Bubble Sort requires \(O(N^2)\) exchanges.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayBubbleSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{=}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZgt{}}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Exchange}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{sorting@\spxentry{sorting}!selection sort@\spxentry{selection sort}}\index{algorithms@\spxentry{algorithms}!selection sort@\spxentry{selection sort}}\index{nested loop@\spxentry{nested loop}}\index{selection sort@\spxentry{selection sort}}\ignorespaces 

\subsection{Selection Sort}
\label{\detokenize{arrays/sorting:selection-sort}}\label{\detokenize{arrays/sorting:index-3}}
\sphinxAtStartPar
The Selection Sort algorithm works to minimize the amount of data movement,
hence the number of \sphinxcode{\sphinxupquote{Exchange()}} calls.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Among the indices \PYGZgt{}= start for data,}
\PYG{c+c1}{/// return the index of the minimal element.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{IntArrayMin}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{pos}\PYG{o}{=}\PYG{n}{start}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{pos}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{pos}\PYG{o}{++}\PYG{p}{)}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{minPos}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{minPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pos}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{minPos}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArraySelectionSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{IntArrayMin}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Exchange}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It’s a remarkably simple algorithm to explain. As shown in the code, the
actual sorting is done by a function, \sphinxcode{\sphinxupquote{IntArraySelectionSort()}}, which
takes an array of data as its only parameter, like Bubble sort.
The way Selection Sort works is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
An outer loop visits each item in the array to find out whether it is the
minimum of all the elements after it.
If it is not the minimum, it is going to be swapped with whatever
item in the rest of the array is the minimum.

\item {} 
\sphinxAtStartPar
We use a helper function,
\sphinxcode{\sphinxupquote{IntArrayMin()}}
to find the position of the minimum value in the rest of the array.
This function has a parameter, \sphinxcode{\sphinxupquote{start}} to indicate where
we wish to begin the search.
So as you can see from the loop in \sphinxcode{\sphinxupquote{IntArraySelectionSort()}},
when we start with position \sphinxcode{\sphinxupquote{i}}, and we compare to the later elements
from position \sphinxcode{\sphinxupquote{i + 1}} to the end of the array, updating the position of the
smallest element so far.

\end{enumerate}

\sphinxAtStartPar
An illustration to accompany the discussion:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: 12  8 \PYGZhy{}5 22  9  2
index:  0  1  2  3  4  5
        i     k
\end{sphinxVerbatim}

\sphinxAtStartPar
The first time through the loop, \sphinxcode{\sphinxupquote{i}} is 0, and \sphinxcode{\sphinxupquote{k}} gets the value 2, since data{[}2{]}
is \sphinxhyphen{}5, the smallest element.  Those two positions get swapped.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: \PYGZhy{}5  8 12 22  9  2
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
The next
time through the loop i is 1 and k becomes 5:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: \PYGZhy{}5  8 12 22  9  2
index:  0  1  2  3  4  5
           i           k
\end{sphinxVerbatim}

\sphinxAtStartPar
After the swap:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: \PYGZhy{}5  2 12 22  9  8
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
and so on.  Here is the data after each of the last three swaps:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}5  2  8 22  9 12

\PYGZhy{}5  2  8  9 22 12

\PYGZhy{}5  2  8  9 12 22
\end{sphinxVerbatim}

\sphinxAtStartPar
Consider the first call to \sphinxcode{\sphinxupquote{IntArrayMin}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: 12  8 \PYGZhy{}5 22  9  2
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
Initially \sphinxcode{\sphinxupquote{minPos}} is 0.  Here are the
changes for each value of \sphinxcode{\sphinxupquote{pos}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pos=1:  8 = data[1] \PYGZlt{} data[0] = 12, so minPos becomes 1
pos=2: \PYGZhy{}5 = data[2] \PYGZlt{} data[1] = 8, so minPos becomes 2
pos=3: 22 = data[3] is not \PYGZlt{} data[2] = \PYGZhy{}5, so minPos still 2
pos=4:  9 = data[4] is not \PYGZlt{} data[2] = \PYGZhy{}5, so minPos still 2
pos=5:  2 = data[5] is not \PYGZlt{} data[2] = \PYGZhy{}5, so minPos still 2
\end{sphinxVerbatim}

\sphinxAtStartPar
and 2 gets returned, and we ge the swap

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 data: \PYGZhy{}5  8 12 22  9  2
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
The next call to \sphinxcode{\sphinxupquote{IntArrayMin}} has \sphinxcode{\sphinxupquote{start}} as 1, so \sphinxcode{\sphinxupquote{minPos}} is initially 1,
and we compare to the elements of data at index 2, 3, 4, and 5….

\sphinxAtStartPar
We won’t do the full algorithmic analysis here. Selection Sort is interesting because
it does most of its work through \sphinxstyleemphasis{comparisons}, with the same number of them no matter
how the data are ordered, exactly
\(N \cdot \frac{N-1}{2}\), which is
\(O(N^2)\) The
number of \sphinxstyleemphasis{exchanges} is O(N). The comparisons are a non\sphinxhyphen{}trivial cost,
however, and do show
in our own performance experiments with randomly\sphinxhyphen{}generated data.

\index{Shuffle exercise@\spxentry{Shuffle exercise}}\index{exercise@\spxentry{exercise}!Shuffle@\spxentry{Shuffle}}\ignorespaces 

\subsubsection{Shuffle Exercise}
\label{\detokenize{arrays/sorting:shuffle-exercise}}\label{\detokenize{arrays/sorting:index-4}}
\sphinxAtStartPar
Complete the \sphinxcode{\sphinxupquote{Shuffle}} function and add a \sphinxcode{\sphinxupquote{Main}} method to test it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Shuffle the elements of an array into random positions,}
\PYG{c+c1}{/// changing the array.  An array containing}
\PYG{c+c1}{/// 2, 5, 7, 7, 7, 9 *might* end up in the order}
\PYG{c+c1}{/// 7, 7, 2, 9, 7, 5.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Shuffle}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Use a Random and do something close to a reverse of selection sort, using
\sphinxcode{\sphinxupquote{Exchange}} with a random position.

\index{sorting@\spxentry{sorting}!insertion sort@\spxentry{insertion sort}}\index{algorithms@\spxentry{algorithms}!insertion sort@\spxentry{insertion sort}}\index{nested loop@\spxentry{nested loop}}\index{insertion sort@\spxentry{insertion sort}}\ignorespaces 

\subsection{Insertion Sort}
\label{\detokenize{arrays/sorting:insertion-sort}}\label{\detokenize{arrays/sorting:index-5}}
\sphinxAtStartPar
In the Insertion Sort algorithm, we build up a longer and longer sorted
list from the bottom of the array. We repeatedly insert the next element
into the sorted part of the array by sliding it down (using our familiar
\sphinxcode{\sphinxupquote{Exchange()}} method) to its proper position.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayInsertionSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{=}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZgt{}}\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Exchange}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Consider the earlier example array as we illustrate some of the steps.
I use the symbol ‘\sphinxhyphen{}’ for an element that we know to
be in the sorted list at the beginning of the array,
and ‘@’ over the next one we are trying to insert \sphinxstyleemphasis{at} the right position.
We start with a one\sphinxhyphen{}element sorted list and try to position the second element:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYGZhy{}  @
 data: 12  8 \PYGZhy{}5 22  9  2
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
After each outer loop in sequence we end up with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYGZhy{}  \PYGZhy{}  @
 data:  8 12 \PYGZhy{}5 22  9  2
index:  0  1  2  3  4  5

        \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  @
 data: \PYGZhy{}5  8 12 22  9  2
index:  0  1  2  3  4  5

        \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  @
 data: \PYGZhy{}5  8 12 22  9  2
index:  0  1  2  3  4  5

        \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  @
 data: \PYGZhy{}5  8  9 12 22  2
index:  0  1  2  3  4  5

        \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}  \PYGZhy{}
 data: \PYGZhy{}5  2  8  9 12 22
index:  0  1  2  3  4  5
\end{sphinxVerbatim}

\sphinxAtStartPar
Let us illustrate several times just through the inner loop, the first time,
when the 8 is moved into
position from index \sphinxcode{\sphinxupquote{j}} = 1, so \sphinxcode{\sphinxupquote{i}} starts at 1.  We show the letter i
over the data at index \sphinxcode{\sphinxupquote{i}}, and show the comparison test to be done with a \sphinxtitleref{\textgreater{}}
with a ‘?’ over it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          ? i
 data: 12 \PYGZgt{} 8  \PYGZhy{}5  22   9   2   1\PYGZgt{}0 and 12\PYGZgt{}8: true, so swap, loop
index:  0   1   2   3   4   5

        i
 data:  8  12  \PYGZhy{}5  22   9   2   0\PYGZgt{}0 false, skip comparison of data, end loop
index:  0   1   2   3   4   5
\end{sphinxVerbatim}

\sphinxAtStartPar
Let us also illustrate at a later time through the inner loop, when the 9 is moved into
position from index \sphinxcode{\sphinxupquote{j}} = 4, so \sphinxcode{\sphinxupquote{i}} starts at 4.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                      ? i
 data: \PYGZhy{}5   8  12  22 \PYGZgt{} 9   2  4\PYGZgt{}0 and 22\PYGZgt{}9: true, so swap, loop
index:  0   1   2   3   4   5

                  ? i
 data: \PYGZhy{}5   8  12 \PYGZgt{} 9  22   2  3\PYGZgt{}0 and 12\PYGZgt{}9: true, so swap, loop
index:  0   1   2   3   4   5

              ? i
 data: \PYGZhy{}5   8 \PYGZgt{} 9  12  22   2  2\PYGZgt{}0 and 8\PYGZgt{}9: false, end inner loop
index:  0   1   2   3   4   5
\end{sphinxVerbatim}

\sphinxAtStartPar
The 9 started at index \sphinxcode{\sphinxupquote{j}} = 4, and now the list is sorted up through index 4.

\sphinxAtStartPar
This will require as many exchanges as Bubble Sort,
since only one inversion is removed per exchange. So Insertion Sort also
requires \(O(N^2)\) exchanges. On average Insertion Sort requires
only half as many comparisons as Bubble Sort, since the average distance an
element must move for random input is one\sphinxhyphen{}half the length of the sorted
portion.

\index{sorting@\spxentry{sorting}!Shell sort@\spxentry{Shell sort}}\index{nested loop@\spxentry{nested loop}}\index{Shell sort@\spxentry{Shell sort}}\index{algorithms@\spxentry{algorithms}!Shell sort@\spxentry{Shell sort}}\ignorespaces 

\subsection{Shell Sort}
\label{\detokenize{arrays/sorting:shell-sort}}\label{\detokenize{arrays/sorting:index-6}}
\sphinxAtStartPar
Shell Sort is basically a trick to make Insertion Sort run faster. If
you take a quick glance at the code and look beyond the presence of
two additional \sphinxstyleemphasis{outer loops}, you’ll notice that the code looks very similar.

\sphinxAtStartPar
Since Insertion Sort removes one inversion per exchange, it cannot run
faster than the number of inversions in the data, which in worst case is
\(O(N^2)\). Of course, it can’t run faster than N, either, because
it must look at each element, whether or not the element is out of
position. We can’t do any thing about the lower bound O(N), but we can
do something about the number of steps to remove inversions.

\sphinxAtStartPar
The trick in Shell Sort is to start off swapping elements that are
further apart.  While this may remove only one inversion sometimes,
often many more inversions are removed with intervening elements.
Shell Sort considers the subsequences of elements spaced k
elements apart. There are k such sequences starting at positions 0
through k\sphinxhyphen{}1 in the array. In these sorts, elements k positions apart are
exchanged, removing between 1 and 2(k\sphinxhyphen{}1)+1 inversions.

\sphinxAtStartPar
Swapping elements far apart is not sufficient, generally, so
a Shell Sort will do several
passes with decreasing values of k, ending with k=1.
The following examples experiment
with different series of values of k.

\sphinxAtStartPar
In this first example, we sort all subsequences of elements 8 apart,
then 4, 2, and 1. Please note that these intervals are to show how the
method works\textendash{}not how the method works \sphinxstyleemphasis{best}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Shell sort of data using specified swapping intervals.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayShellSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// The intervals for the shell sort must be sorted, ascending}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{=}\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{Length}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{\PYGZgt{}=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{interval}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{\PYGZlt{}}\PYG{n}{interval}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{m}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{=}\PYG{n}{m}\PYG{o}{+}\PYG{n}{interval}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+=}\PYG{n}{interval}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZgt{}=}\PYG{n}{interval}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{interval}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{                  }\PYG{n}{i}\PYG{o}{\PYGZhy{}=}\PYG{n}{interval}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Exchange}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{interval}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayShellSortNaive}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{intervals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{8}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{IntArrayShellSort}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, shell sort with sequences of jump sizes that
are powers of one another doesn’t
do as well as one where most jump sizes are not multiples of others,
mixing up the data more.
In  addition, the number of intervals must be increased as the size of the array to
be sorted increases, which explains why we allow an \sphinxstyleemphasis{arbitrary} array of intervals
to be specified.

\sphinxAtStartPar
Without too much explanation, we show how you can choose the intervals differently
in an \sphinxstyleemphasis{improved} shell sort, where the intervals have been chosen so as not to be
multiples of one another.

\sphinxAtStartPar
Donald Knuth has suggested a couple of methods for computing the intervals:
\begin{align*}\!\begin{aligned}
h_0 = 1\\
h_{k+1} = 3 h_k + 1\\
t = \lfloor log_3 n \rfloor - 1\\
\end{aligned}\end{align*}
\sphinxAtStartPar
Here we are using notation for the \sphinxstyleemphasis{floor} function
\(\lfloor x \rfloor\) means the largest integer \(\le x\).

\sphinxAtStartPar
This results in a sequence 1, 4, 13, 40, 121…. You stop computing values in the
sequence when \(t = log_3 n - 1\). (So for n=50,000, you should have about 9\sphinxhyphen{}10
intervals.)

\sphinxAtStartPar
For completeness, we note that \(log_3 n\) must be sufficiently large (and \textgreater{} 2)
for this method to work. Our code ensures this by taking the \sphinxstyleemphasis{maximum} of
\(log_3 n\) and 1.

\sphinxAtStartPar
Knuth also suggests:
\begin{align*}\!\begin{aligned}
h_0 = 1\\
h_{k+1} = 2 h_k + 1\\
t = \lfloor log_2 n \rfloor - 1\\
\end{aligned}\end{align*}
\sphinxAtStartPar
This results in a sequence 1, 3, 7, 15, 31….

\sphinxAtStartPar
Here is the improvement to our naive method that dynamically calculates
the intervals based on the first suggestion of Knuth:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Generates the intervals for Shell sort on a}
\PYG{c+c1}{/// list of length n via an algorithm from Knuth.}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{GenerateIntervals}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// no sorting will be needed}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{t}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Max}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Log}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{intervals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{intervals}\PYG{+w}{ }\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{intervals}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{intervals}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayShellSortBetter}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{intervals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GenerateIntervals}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{IntArrayShellSort}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Shell sort is a complex sorting algorithm to make “work well”, which is why it is not
seen often in practice. It is, however, making a bit of a comeback in embedded systems.

\sphinxAtStartPar
We nevertheless think it is a very cool algorithm to have heard of as a computer science
student and think it has promise in a number of situations, especially in systems where
there are limits on available memory (e.g. embedded systems).

\index{sorting@\spxentry{sorting}!Quicksort@\spxentry{Quicksort}}\index{algorithms@\spxentry{algorithms}!Quicksort@\spxentry{Quicksort}}\index{recursion@\spxentry{recursion}!Quicksort@\spxentry{Quicksort}}\index{Quicksort@\spxentry{Quicksort}}\ignorespaces 

\subsection{Quicksort a.k.a. Partition Sort}
\label{\detokenize{arrays/sorting:quicksort-a-k-a-partition-sort}}\label{\detokenize{arrays/sorting:index-7}}
\sphinxAtStartPar
This sort is a more advanced example that uses \sphinxstyleemphasis{recursion}. We list it because it
is one of the best sorts for \sphinxstyleemphasis{random} data, having an \sphinxstyleemphasis{average} time behavior of
\(O(N  \log N)\).
Quicksort is a rather interesting case. While it has an excellent average
behavior, it has a worst case performance of \(O(N ^2)\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Sort elements of data in index range [lowI, highI].}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayQuickSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}
\PYG{+w}{                                      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lowI}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{highI}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{afterSmall}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{lowI}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{highI}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{pivot}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{p}{(}\PYG{n}{lowI}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{highI}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// in loop data[i] \PYGZlt{}= pivot if i \PYGZlt{} afterSmall}
\PYG{+w}{   }\PYG{c+c1}{//         data[i] \PYGZgt{}= pivot if i \PYGZgt{} beforeBig}
\PYG{+w}{   }\PYG{c+c1}{//         region with aftersmall \PYGZlt{}= i \PYGZlt{}= beforeBig}
\PYG{+w}{   }\PYG{c+c1}{//             shrinks to nothing.}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{afterSmall}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{afterSmall}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{pivot}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{afterSmall}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pivot}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{beforeBig}\PYG{p}{]}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{beforeBig}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{afterSmall}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Exchange}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{afterSmall}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{afterSmall}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{beforeBig}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}\PYG{+w}{  }\PYG{c+c1}{// after loop: beforeBig \PYGZlt{} afterSmall, and}
\PYG{+w}{   }\PYG{c+c1}{//      data[i] \PYGZlt{}= pivot for i \PYGZlt{}= beforeBig,}
\PYG{+w}{   }\PYG{c+c1}{//      data[i] == pivot for i if beforeBig \PYGZlt{} i \PYGZlt{} afterSmall,}
\PYG{+w}{   }\PYG{c+c1}{//      data[i] \PYGZgt{}= pivot for i \PYGZgt{}= afterSmall.}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{lowI}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{// at least two elements}
\PYG{+w}{      }\PYG{n}{IntArrayQuickSort}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{lowI}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{beforeBig}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{afterSmall}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{highI}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{// at least two elements}
\PYG{+w}{      }\PYG{n}{IntArrayQuickSort}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{afterSmall}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{highI}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayQuickSort}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{IntArrayQuickSort}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Though the initial call is to sort an entire array, this is accomplished by
dealing with sections, so the main work is done in the version with the
two extra parameters, giving the lowest and highest index considered.

\sphinxAtStartPar
It picks an arbitrary element as \sphinxstyleemphasis{pivot}, and then swaps
elements with values above and below the pivot until the part of the array
being processed is in three sections:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
elements \textless{}= pivot;

\item {} 
\sphinxAtStartPar
possibly an element equal to pivot

\item {} 
\sphinxAtStartPar
elements \textgreater{}= pivot.

\end{enumerate}

\sphinxAtStartPar
Though sections 1 and 3 are not sorted, there are no inversions \sphinxstyleemphasis{between} any two
separate sections, so only the smaller sections 1 and 3 need to be sorted \sphinxstyleemphasis{separately},
and only then if they have at least two elements.  They can be sorted
by calling the \sphinxstyleemphasis{same} function,
but with a smaller range of indices to deal with in each case.
These \sphinxstyleemphasis{recursive} calls stop when a part is reduced to one element.

\index{loop@\spxentry{loop}!invariant@\spxentry{invariant}}\ignorespaces 
\sphinxAtStartPar
Another optional glimpse at an advanced topic:  The outer \sphinxcode{\sphinxupquote{while}} loop
in lines 11\sphinxhyphen{}20 has fairly complicated logic.  To prove it is correct
overall, you can state and prove the simpler \sphinxstyleemphasis{loop invariant} expressed
in the comments above the loop, lines 7\sphinxhyphen{}10.  This allows the conclusion
after the loop in comment lines 21\sphinxhyphen{}24.

\index{Random@\spxentry{Random}}\index{seed@\spxentry{seed}}\index{regenerate random numbers@\spxentry{regenerate random numbers}}\ignorespaces 

\subsection{Random Data Generation}
\label{\detokenize{arrays/sorting:random-data-generation}}\label{\detokenize{arrays/sorting:index-9}}
\sphinxAtStartPar
Now it is time to talk about how we are going to check the performance in
a real\sphinxhyphen{}world situation. We’re going to start by modeling the situation when
the data are in random order.

\sphinxAtStartPar
The following code generates a random array:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Fill data with pseudo\PYGZhy{}random data seeded by randomSeed.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{IntArrayGenerate}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{randomSeed}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Random}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Random}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{randomSeed}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}
\PYG{+w}{      }\PYG{n}{data}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are a few things to note in this code:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
We use the random number generator option to include a \sphinxstyleemphasis{seed}. Random numbers
aren’t truly random. The particular sequence is just determined by a seed.
The simplest way to create a Random object uses a seed taken from the system clock.

\item {} 
\sphinxAtStartPar
In order to regenerate a particular example, we actually need the random sequence to be
consistent, so we know that each of the sorting algorithms is being tested
using the same random data.

\item {} 
\sphinxAtStartPar
Because the sorting algorithms \sphinxstyleemphasis{modify} the data that are passed to it, we
need to have a way of regenerating the sequence for the next test.
Hence we specify the same seed each time.
(We could also copy the data, but it is kind of a waste of memory.)

\end{enumerate}

\sphinxAtStartPar
This completes the discussion of the \sphinxcode{\sphinxupquote{Sorting}} class in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting.cs}{sorting/sorting.cs}.

\index{Stopwatch@\spxentry{Stopwatch}}\index{performance \sphinxhyphen{} Stopwatch and TimeSpan@\spxentry{performance \sphinxhyphen{} Stopwatch and TimeSpan}}\index{timing@\spxentry{timing}}\ignorespaces 

\subsection{Timing}
\label{\detokenize{arrays/sorting:timing}}\label{\detokenize{arrays/sorting:index-10}}
\sphinxAtStartPar
Separate from the basic sorts is the idea of checking their performance.
The rest of the code is in the driver class in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting\_demo.cs}{sorting/sorting\_demo.cs}.

\sphinxAtStartPar
We need the ability to time the various sorting algorithms. Luckily, the
.Net framework/library gives us a
way of doing so through its \sphinxcode{\sphinxupquote{Stopwatch}} class. This class supports methods that you
would expect if you’ve ever used a stopwatch (the kind found in sports):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Reset: Resets the elapsed time to zero. We need this so we can use the same Stopwatch
for each sorting algorithm.

\item {} 
\sphinxAtStartPar
Start: Starts the stopwatch. Will keep recording time until stopped.

\item {} 
\sphinxAtStartPar
Stop: Stops the stopwatch.

\item {} 
\sphinxAtStartPar
ElapsedMilliseconds: Not really a method but a property (like a variable). We’ll use this to
get the total time that has elapsed between pairs of Start/Stop events in milliseconds.

\end{itemize}

\sphinxAtStartPar
So let’s take a look at the \sphinxcode{\sphinxupquote{Main()}}
method’s code to see how we compare the sorting algorithms.
The \sphinxcode{\sphinxupquote{Main()}} method should be thought of as an \sphinxstyleemphasis{experiment} that tests the performance
of each of the sorting algorithms.
As all of the tests follow the same pattern,
we’re going to look at the basic variable setup first, and then one test.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arraySize}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{randomSeed}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{n}{watch}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The variables declared here are to set up the apparatus:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arraySize}}: The size of the array where we wish to test the performance. We will
use this to create an array with \sphinxcode{\sphinxupquote{arraySize}} random values.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{randomSeed}}: This allows the user to vary the seed that is used to create
the random array. We often want to do this to determine whether our performance
results are stable when run a large number of times with different distributions.
We won’t go into too much detail here but consider it an important part of building
good performance benchmarks.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{watch}}: The stopwatch object we’re using to do the timings of all experiments.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data}}:  The array to be sorted.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{args}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{arraySize}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Please enter desired array size: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{randomSeed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}
\PYG{+w}{                            }\PYG{l+s}{\PYGZdq{}Please enter an initial random seed value: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{arraySize}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{args}\PYG{+w}{ }\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{randomSeed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{args}\PYG{+w}{ }\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{arraySize}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code is designed so we can accept the parameters \sphinxcode{\sphinxupquote{arraySize}} and \sphinxcode{\sphinxupquote{randomSeed}}
from the command line or by prompting the user. When programmers design benchmarks, they
often try to make it possible to run them with minimal user interaction. For the purposes
of teaching, we wanted to make it possible to run it with or without command\sphinxhyphen{}line parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{n}{TimeSetup}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{randomSeed}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Sorting}\PYG{p}{.}\PYG{n}{IntArrayQuickSort}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//this line varies by experiment}
\PYG{+w}{   }\PYG{n}{TimeResult}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Quick Sort\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code fragment is one of the tests in \sphinxcode{\sphinxupquote{Main}}.  All of the tests set up
for timing first, run the desired sorting algorithm (bubble sort in this case),
and report the timing results.  Since the timing setup and reporting is
always done the same way, they actions are placed in helping methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Set up data and watch for sort timing}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{TimeSetup}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{randomSeed}\PYG{p}{,}
\PYG{+w}{                              }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Sorting}\PYG{p}{.}\PYG{n}{IntArrayGenerate}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{randomSeed}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Reset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{/// Report sort timing results from watch}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{TimeResult}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{sortType}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Stop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{elapsedTime}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{ElapsedMilliseconds}\PYG{o}{/}\PYG{l+m}{1000.0}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sortType}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}: \PYGZob{}0:F3\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{elapsedTime}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TimeSetup}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Creates the ‘random’ array of \sphinxcode{\sphinxupquote{data}}, based on \sphinxcode{\sphinxupquote{randomSeed}}.

\item {} 
\sphinxAtStartPar
Resets the \sphinxcode{\sphinxupquote{Stopwatch}} object to zero.

\item {} 
\sphinxAtStartPar
Starts the \sphinxcode{\sphinxupquote{Stopwatch}}.

\end{enumerate}

\sphinxAtStartPar
After the sort, \sphinxcode{\sphinxupquote{TimeResult}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Stops the \sphinxcode{\sphinxupquote{Stopwatch}} and get the elapsed time (\sphinxcode{\sphinxupquote{watch.ElapsedMilliseconds}}).
The value
is an integer (long) number of
milliseconds (thousandths of a second).

\item {} 
\sphinxAtStartPar
Prints the performance results in seconds.

\end{enumerate}

\sphinxAtStartPar
You can see all of the tests in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting\_demo.cs}{sorting/sorting\_demo.cs}.


\subsection{Running the Code}
\label{\detokenize{arrays/sorting:running-the-code}}
\sphinxAtStartPar
Here’s the output of a trial run on one of our computers. The results will vary
depending on your computer’s CPU, among other factors.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bin/Debug\PYGZdl{} mono Sorting.exe 1000 12
Quick Sort: 0.000
Naive Shell Sort: 0.000
Better Shell Sort: 0.000
Insertion Sort: 0.001
Selection Sort: 0.002
Bubble Sort: 0.003
bin/Debug\PYGZdl{} mono Sorting.exe 1000 55
Quick Sort: 0.000
Naive Shell Sort: 0.000
Better Shell Sort: 0.000
Insertion Sort: 0.001
Selection Sort: 0.002
Bubble Sort: 0.003
bin/Debug\PYGZdl{} mono Sorting.exe 10000 2
Quick Sort: 0.001
Naive Shell Sort: 0.019
Better Shell Sort: 0.002
Insertion Sort: 0.134
Selection Sort: 0.174
Bubble Sort: 0.321
bin/Debug\PYGZdl{} mono Sorting.exe 50000 2
Quick Sort: 0.006
Naive Shell Sort: 0.441
Better Shell Sort: 0.015
Insertion Sort: 3.239
Selection Sort: 4.172
Bubble Sort: 8.028
bin/Debug\PYGZdl{} mono Sorting.exe 100000 2
Quick Sort: 0.014
Naive Shell Sort: 1.794
Better Shell Sort: 0.034
Insertion Sort: 13.158
Selection Sort: 16.736
Bubble Sort: 31.334
\end{sphinxVerbatim}

\sphinxAtStartPar
At least based on randomly\sphinxhyphen{}generated arrays, the performance can be summarized
as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Bubble Sort is rather unimpressive as expected. In fact, this algorithm is never
used in practice but is of historical interest. Like the brute\sphinxhyphen{}force style of
searching, it does way too much work to come up with the right answer!

\item {} 
\sphinxAtStartPar
Selection Sort and Insertion Sort are also rather unimpressive on their own. Even though
Selection Sort can in theory do a lot less data movement, it must make a large
number of comparisons to find the minimum value to be moved. Again it is way too much work.
Insertion Sort, while unimpressive, fares a bit better and turns out to be a
nice building block (if modified) for the Shell Sort. Varying the interval size
drastically reduces the amount of data movement (and the distance it has to move).

\item {} 
\sphinxAtStartPar
Shell Sort does rather well, especially when we pick the right intervals.
In practice, the intervals also need to be adjusted based on the size of the
array, which is what we do as larger array sizes are considered. This is no trivial
task but a great deal of work has already been done in the past to determine
functions that generate good intervals.

\item {} 
\sphinxAtStartPar
The Quicksort is generally fastest on random data.  It is by far the
most commonly used sorting algorithm. Yet there are signs that Shell sort
is making a comeback in embedded systems, because it concise to code
and is still quite fast.  See
\sphinxcite{arrays/sorting:wikipediashellsort}, where it is mentioned that
the \sphinxcite{arrays/sorting:uclibc} library makes use of Shell sort in its \sphinxcode{\sphinxupquote{qsort()}} implementation,
rather than implementing the library sort with the more common quicksort.

\end{itemize}

\sphinxstepscope

\index{search@\spxentry{search}!binary@\spxentry{binary}}\index{binary search@\spxentry{binary search}}\index{algorithms@\spxentry{algorithms}!binary search@\spxentry{binary search}}\ignorespaces 

\section{Binary Searching}
\label{\detokenize{arrays/binarysearching:binary-searching}}\label{\detokenize{arrays/binarysearching:binarysearching}}\label{\detokenize{arrays/binarysearching:index-0}}\label{\detokenize{arrays/binarysearching::doc}}
\sphinxAtStartPar
Binary search is an improvement over linear searching that works only
if the data in the array are sorted beforehand.

\sphinxAtStartPar
Suppose we have the following array data shown under the array indices:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
10  20  30  40  50  60  70  80  90  100 115 125 135 145 155 178 198
\end{sphinxVerbatim}

\sphinxAtStartPar
Binary search works by keeping track of the midpoint (mid) and the minimum (min) and
maximum (max) index positions where the item \sphinxstyleemphasis{might be}.

\sphinxAtStartPar
If we are looking for a number, say, 115, here is a visual on how we might go about it.
We display the indices over the data being considered.
Here min and max are the smallest and largest index to still consider.
A textual explanation follows the visual:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
  10  20  30  40  50  60  70  80  90 100 115 125 135 145 155 178 198
min=0 max=16 mid=8
                                     100 115 125 135 145 155 178 198
min=9 max=16 mid=12
                                     100 115 125
min=9 max=11 mid=10
Item 115 found at position 10
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
We start by testing the data at position 8. 115 is greater than the value at position
8 (100), so we assume that the value must be somewhere between positions 9 and 16.

\item {} 
\sphinxAtStartPar
In the second pass, we test the data at position 12 (the midpoint between 9 and 16).
115 is less than the value at position 12, so we assume that the value must be somewhere
between positions 9 and 11.

\item {} 
\sphinxAtStartPar
In the last pass, we test the value at position 10. The value 115 is at this position,
so we’re done.

\end{itemize}

\sphinxAtStartPar
So binary search (as its name might suggest) works by dividing the interval to be searched
during each pass in half. If you think about how it’s working here with 17 items. Because
there is integer division here, the interval will not always be precisely half. it is the
floor of dividing by 2 (integer division, that is).

\sphinxAtStartPar
With the data above, you see that the algorithm determined the item within 3 steps.
To reduce to one element
to consider, it could be 4 or 5 steps.  Note that \(4 < log_2 17 < 5\).

\sphinxAtStartPar
Now that we’ve seen how the method works, here is the code
in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/binary\_searching/binary\_searching.cs}{binary\_searching/binary\_searching.cs} that does the work:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{/// Return the index of item in a non\PYGZhy{}empty sorted array data,}
\PYG{c+c1}{/// or return \PYGZhy{}1 if item is not in the array.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{IntArrayBinarySearch}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{min}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{max}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{.}\PYG{n}{Length}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{p}{(}\PYG{n}{min}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{mid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{min}\PYG{o}{+}\PYG{n}{max}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{mid}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{item}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{min}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mid}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{else}
\PYG{+w}{         }\PYG{n}{max}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mid}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here’s a quick explanation, because it largely follows from the above explanation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Line 5: Initially item could be anywhere in the array,
so minimum is at position 0 and maximum is at position
N\sphinxhyphen{}1 (data.Length \sphinxhyphen{} 1).

\item {} 
\sphinxAtStartPar
The loop to make repeated passes over the array begins on line 6.
We can only continue searching if there is some data left to consider
(\sphinxcode{\sphinxupquote{min \textless{}= max}}).

\item {} 
\sphinxAtStartPar
Line 7 does just what we expect:
It calculates the median position (mid).

\item {} 
\sphinxAtStartPar
It is always possible that we’ve found the item, which is what we test on line 8,
and return with our answer if we found it.

\item {} 
\sphinxAtStartPar
Lines 10\sphinxhyphen{}13: If not, we continue.  If the item is greater than the value
at this mid position, we know it is in the “upper half”.
Otherwise, it’s in the “lower half”.

\item {} 
\sphinxAtStartPar
Line 15: Otherwise the binary search loop terminates, and we
return \sphinxhyphen{}1 (to indicate not found).
The \sphinxhyphen{}1 value is a commonly\sphinxhyphen{}returned indicator of failure in search operations
(especially on arrays, lists, and strings),
so we use this mostly out of respect for tradition.
It makes particular sense,
because \sphinxhyphen{}1 is not within the \sphinxstyleemphasis{index set} of the array (which starts
at 0 in C\# and ends at \sphinxcode{\sphinxupquote{data.Length \sphinxhyphen{} 1}}.

\end{itemize}

\sphinxAtStartPar
Of course we generally would be searching in an array with multiple elements.
It is still important to check \sphinxstyleemphasis{edge cases}:  Check that the code correctly
returns \sphinxhyphen{}1 if the array has length 0 (a legal length).

\sphinxAtStartPar
Similar to linear searching, we provide a main program that tests it out.
in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/binary\_searching/binary\_searching\_demo.cs}{binary\_searching/binary\_searching\_demo.cs}.  It uses
an elaboration of binary search that prints
out the steps visually, as in the introduction to this section.
It also references previous example projects: functions from files
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/searching/extract\_from\_string.cs}{searching/extract\_from\_string.cs} and \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting.cs}{sorting/sorting.cs}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}
\PYG{+w}{      }\PYG{l+s}{\PYGZdq{}Please enter some comma/space separated integers: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ExtractFromString}\PYG{p}{.}\PYG{n}{IntsFromString}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Sorting}\PYG{p}{.}\PYG{n}{IntArrayShellSortBetter}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{      }\PYG{l+s}{\PYGZdq{}Please enter a number to find (empty line to end): \PYGZdq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{input}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{searchItem}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{foundPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{BinarySearching}\PYG{p}{.}\PYG{n}{IntArrayBinarySearchPrinted}\PYG{p}{(}
\PYG{+w}{                        }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{searchItem}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{foundPos}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Item \PYGZob{}0\PYGZcb{} not found\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{searchItem}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{else}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Item \PYGZob{}0\PYGZcb{} found at position \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                           }\PYG{n}{searchItem}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{foundPos}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{input}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Elaborated Binary Search Exercise}
\label{\detokenize{arrays/binarysearching:elaborated-binary-search-exercise}}
\sphinxAtStartPar
Even if you do not find \sphinxcode{\sphinxupquote{item}} in a binary search, it is sometimes useful to know
where \sphinxcode{\sphinxupquote{item}} lies in relation to the array elements.  It could be
before the first element, in between two elements, or after the last element.
Suppose \sphinxcode{\sphinxupquote{N}} is the (positive) array length.
Instead of just returning \sphinxhyphen{}1 if \sphinxcode{\sphinxupquote{item}} is not in the array, return
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}1 if \sphinxcode{\sphinxupquote{item \textless{} data{[}0{]}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}(k+1)}} if \sphinxcode{\sphinxupquote{data{[}k\sphinxhyphen{}1{]} \textless{} item \textless{} data{[}k{]}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}(N+1)}} if \sphinxcode{\sphinxupquote{data{[}N\sphinxhyphen{}1{]} \textless{} item}}

\end{itemize}

\sphinxAtStartPar
Modify \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/binary\_searching/binary\_searching.cs}{binary\_searching/binary\_searching.cs} into
\sphinxcode{\sphinxupquote{binary\_searching2.cs}} so this extra information is returned
(and indicated clearly in a main testing program derived from
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/binary\_searching/binary\_searching\_demo.cs}{binary\_searching/binary\_searching\_demo.cs}).
This should \sphinxstyleemphasis{not} require a change to the \sphinxcode{\sphinxupquote{while}} loop, \sphinxstyleemphasis{nor}
require any added loop.

\sphinxstepscope
\phantomsection\label{\detokenize{arrays/lab-array1d:lab-arrays1d}}
\index{labs@\spxentry{labs}!arrays@\spxentry{arrays}}\ignorespaces 

\section{Lab: Arrays}
\label{\detokenize{arrays/lab-array1d:lab-arrays}}\label{\detokenize{arrays/lab-array1d:index-0}}\label{\detokenize{arrays/lab-array1d::doc}}

\subsection{Overview}
\label{\detokenize{arrays/lab-array1d:overview}}
\sphinxAtStartPar
In this lab, we’ll practice working with arrays. Arrays are
fundamental to computer science, especially when it comes to
formulating various \sphinxstyleemphasis{algorithms}. We’ve already learned a bit about
arrays through the \sphinxcode{\sphinxupquote{string}} data type. In many ways, a character
string reveals the secrets of arrays:
\begin{itemize}
\item {} 
\sphinxAtStartPar
each element of a string is a common type (char)

\item {} 
\sphinxAtStartPar
we can use indexing to find any given character, e.g. \sphinxcode{\sphinxupquote{s{[}i{]}}} gives
us the character at position \sphinxcode{\sphinxupquote{i}}.

\item {} 
\sphinxAtStartPar
we know that the string has a finite length, e.g. \sphinxcode{\sphinxupquote{s.Length}}.

\end{itemize}

\sphinxAtStartPar
So you’ve already learned these \sphinxstyleemphasis{concepts}. But practice is useful
creating and manipulating arrays with different kinds of data.


\subsection{Goals}
\label{\detokenize{arrays/lab-array1d:goals}}
\sphinxAtStartPar
In this lab, we’re going to practice:
\begin{itemize}
\item {} 
\sphinxAtStartPar
creating arrays that hold numerical data

\item {} 
\sphinxAtStartPar
populating an array with data

\item {} 
\sphinxAtStartPar
using the tools of loops and decisions to do something interesting with the data

\item {} 
\sphinxAtStartPar
printing the data

\end{itemize}


\subsection{Tasks}
\label{\detokenize{arrays/lab-array1d:tasks}}
\sphinxAtStartPar
Copy the example file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/array\_lab\_stub/array\_lab.cs}{array\_lab\_stub/array\_lab.cs} to
a new project of yours.
Complete the body of a function
for each main part, and call each function in \sphinxcode{\sphinxupquote{Main}} several times with
actual parameters chosen to test it well.  To label your illustrations, make
liberal use of the first function, \sphinxcode{\sphinxupquote{PrintNums}}, to display and label inputs
and outputs.  Where several tests are appropriate for the same function,
you might want to write a separate testing function that prints
and labels inputs, passes the data on to the function being tested,
and prints results.

\sphinxAtStartPar
Recall that you can declare an array in two ways:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{myArray1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{myArray2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first declaration creates an array initialized to
all zeroes. The second creates an
array where the elements are taken from the bracketed list of
values. The second will be convenient to set up tests for this lab.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Print label and then each element preceeded by a space,}
\PYG{+w}{      }\PYG{c+c1}{///  all across one line.  Example:}
\PYG{+w}{      }\PYG{c+c1}{///  If a contains \PYGZob{}3, \PYGZhy{}1, 5\PYGZcb{} and label is \PYGZdq{}Nums:\PYGZdq{},}
\PYG{+w}{      }\PYG{c+c1}{///  print:   Nums: 3 \PYGZhy{}1 5}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintInts}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{label}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}

\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will be handy for labeling later tests.  Note that you end
on the same line, but a later label can start with \sphinxcode{\sphinxupquote{\textbackslash{}n}}
to advance to the next line.

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Prompt the user to enter n integers, and}
\PYG{+w}{      }\PYG{c+c1}{///  return an array containing them.}
\PYG{+w}{      }\PYG{c+c1}{///  Example:  ReadInts(\PYGZdq{}Enter values\PYGZdq{}, 3) could generate the}
\PYG{+w}{      }\PYG{c+c1}{///  Console sequence:}
\PYG{+w}{      }\PYG{c+c1}{///      Enter values (3)}
\PYG{+w}{      }\PYG{c+c1}{///      1: 5}
\PYG{+w}{      }\PYG{c+c1}{///      2: 7}
\PYG{+w}{      }\PYG{c+c1}{///      3: \PYGZhy{}1}
\PYG{+w}{      }\PYG{c+c1}{///  and the function would return an array containing \PYGZob{}5, 7, \PYGZhy{}1\PYGZcb{}.}
\PYG{+w}{      }\PYG{c+c1}{///  Note the format of the prompts for individual elements.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{ReadInts}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// so stub compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will allow user tests.  The earlier input utility functions
are included at the end of the class.

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Return the minimum value in a.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}5, 7, 4, 9\PYGZcb{}, return 4.}
\PYG{+w}{      }\PYG{c+c1}{///  Assume a contains at least one value.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Minimum}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// so stub compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Return the number of even values in a.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}\PYGZhy{}4, 7, 6, 12, 9\PYGZcb{}, return 3.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CountEven}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// so stub compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Add corresponding elements of a and b and place them in sum.}
\PYG{+w}{      }\PYG{c+c1}{///  Assume all arrays have the same Length.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}2, 4, 6\PYGZcb{} and b contains \PYGZob{}7, \PYGZhy{}1, 8\PYGZcb{}}
\PYG{+w}{      }\PYG{c+c1}{///  then at the end sum should contain \PYGZob{}9, 3, 14\PYGZcb{}.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PairwiseAdd}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}

\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To test this out, you’ll need to declare and initialize the arrays
to be added. You’ll \sphinxstyleemphasis{also} need to declare a third array to hold the
results. Make sure that the arrays all have the same
dimensionality before proceeding.

\sphinxAtStartPar
This section is a warm\sphinxhyphen{}up for the next one.  It is not required
if you do the next one:

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Return a new array whose elements are the sums of the}
\PYG{+w}{      }\PYG{c+c1}{///  corresponding elements of a and b.}
\PYG{+w}{      }\PYG{c+c1}{///  Assume a and b have the same Length.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}2, 4, 6\PYGZcb{} and b contains \PYGZob{}3, \PYGZhy{}1, 5\PYGZcb{}}
\PYG{+w}{      }\PYG{c+c1}{///  then return an array containing \PYGZob{}5, 3, 11\PYGZcb{}.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n+nf}{NewPairwiseAdd}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// so stub compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See how this is different from the previous part!

\item {} 
\sphinxAtStartPar
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Return true if the numbers are sorted in increasing order,}
\PYG{+w}{      }\PYG{c+c1}{///  so that in each pair of consecutive entries,}
\PYG{+w}{      }\PYG{c+c1}{///  the second is always at least as large as the first.}
\PYG{+w}{      }\PYG{c+c1}{///  Return false otherwise.  Assume an array with fewer than}
\PYG{+w}{      }\PYG{c+c1}{///  two elements is ascending.}
\PYG{+w}{      }\PYG{c+c1}{///  Examples: If a contains \PYGZob{}2, 5, 5, 8\PYGZcb{}, return true;}
\PYG{+w}{      }\PYG{c+c1}{///  if a contains \PYGZob{}2, 5, 3, 8\PYGZcb{}, return false.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsAscending}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{false}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// so stub compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This has some pitfalls.  You will need more tests that the ones
in the documentation!  You can code this with
a “short\sphinxhyphen{}circuit” loop.  What do you need to find to be
immediately sure you know the answer?

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{20 \% extra credit:}
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Print an ascending sequence from the elements}
\PYG{+w}{      }\PYG{c+c1}{///  of a, starting with the first element and printing}
\PYG{+w}{      }\PYG{c+c1}{///  the next number after the previous number}
\PYG{+w}{      }\PYG{c+c1}{///  that is at least as large as the previous one printed.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}5, 2, 8, 4, 8, 11, 6, 7, 10\PYGZcb{},}
\PYG{+w}{      }\PYG{c+c1}{///  print:  5 8 8 11}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintAscendingValues}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}

\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{20 \% extra credit:}
Complete and test the function with documentation and heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{///  Prints each ascending run in a, one run per line.}
\PYG{+w}{      }\PYG{c+c1}{///  Example: If a contains \PYGZob{}2, 5, 8, 3, 9, 9, 8\PYGZcb{}, print}
\PYG{+w}{      }\PYG{c+c1}{///  2 5 8}
\PYG{+w}{      }\PYG{c+c1}{///  3 9 9}
\PYG{+w}{      }\PYG{c+c1}{///  8}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintRuns}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}

\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{20 \% extra credit:}
Given two arrays, \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} that represent vectors. Write a
function that computes the vector dot product of these two
floating point arrays. The vector dot product (in mathematics) is defined
as the sum of \sphinxcode{\sphinxupquote{a{[}i{]} * b{[}i{]}}} (for all i). Here’s an example of how it
should work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{1.5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3.0}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{4.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2.0}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{1.0}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{dotProduct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{VectorDotProduct}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The dot product is \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{dotProduct}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Should calculate 1.5 * 4.0 + 2.0 * 2.0 + 3.0 * \PYGZhy{}1.0 = 7.0}
\end{sphinxVerbatim}

\sphinxAtStartPar
From here on, create your own headings.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{20 \% extra credit:}
Suppose we have loaded an array with the digits of an integer,
where the digit for the highest power of 10 is kept in position 0,
next highest in
position 1, and so on. The ones position is always at position
array.Length \sphinxhyphen{} 1:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{digits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
representing \(1(10^3)+9(10^2)+6(10^1)+7(10^0)\).

\sphinxAtStartPar
Without showing you the code, here is how you would convert a
number from its digits to an integer efficiently, without
calculating high powers for 10 separately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{9}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{19}
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{19}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{196}
\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{196}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{7}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1967}
\PYG{n}{done}\PYG{o}{!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Write a function that converts the array of digits representing
a base 10 number to its \sphinxcode{\sphinxupquote{int}} value
(or for really long integers, you are encouraged to use
a \sphinxcode{\sphinxupquote{long}} data type). Note that we only allow single digit
numbers to be placed
in the array, so negative numbers are not addressed.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{20 \% extra credit:}
Each digit represents a multiple of a \sphinxstyleemphasis{power} of the
\sphinxstyleemphasis{base}.  In the previous version the base is 10,
but other bases are important.  Now make the base a parameter.
Here we consider bases no bigger than 10, so we can continue to use
only digits for place value symbols.
Write a function (or revise the
previous solution) to return the int or long represented.
For example if \{1, 0, 0, 1, 1\} represents a base 2 number,
\(1(2^4)+0(2^3)+0(2^2)+1(2^1)+1(2^0)=19\)
is returned. Base 2 is central to computer hardware.

\end{enumerate}

\sphinxstepscope


\section{Lab: Performance}
\label{\detokenize{arrays/lab-searching-arrays-lists-maps:lab-performance}}\label{\detokenize{arrays/lab-searching-arrays-lists-maps:lab-search-performance}}\label{\detokenize{arrays/lab-searching-arrays-lists-maps::doc}}
\sphinxAtStartPar
In {\hyperref[\detokenize{arrays/sorting:sorting}]{\sphinxcrossref{\DUrole{std,std-ref}{Sorting Algorithms}}}} we took advantage of a few ideas
to show how to do basic
benchmarking to compare the various approaches.
\begin{itemize}
\item {} 
\sphinxAtStartPar
using randomly\sphinxhyphen{}generated data

\item {} 
\sphinxAtStartPar
making sure each algorithm is working with the same data

\item {} 
\sphinxAtStartPar
making sure that we try a range of sizes to observe the effects of scaling

\item {} 
\sphinxAtStartPar
using a timer with sufficiently high resolution (the \sphinxcode{\sphinxupquote{Stopwatch}} gives
us measurements in milliseconds).

\end{itemize}

\sphinxAtStartPar
In this lab, you get your chance  to learn a bit more about performance
by comparing \sphinxstyleemphasis{searches}.
The art of benchmarking is
something that is easy to learn but takes a lifetime to master (to borrow
a phrase from the famous Othello board game).

\sphinxAtStartPar
Most of the algorithms we cover in introductory courses tend to be \sphinxstyleemphasis{polynomial}
in nature. That is, the execution time can be bounded by a polynomial function
of the data size \(n\). A more accurate measure may also include
a logarithm.  Examples
include but are not limited to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(O(1)\) is constant time,
characterized by a calculation with a limited number of steps.

\item {} 
\sphinxAtStartPar
\(O(n)\) is linear time; often characterized by a single loop

\item {} 
\sphinxAtStartPar
\(O(n^2)\) is the time squared; often characterized by a nested loop

\item {} 
\sphinxAtStartPar
\(O(log\ n)\) is logarithmic (base 2) time; often characterized by a loop
that repeatedly divides its work in half. The binary search is a well\sphinxhyphen{}known example.

\item {} 
\sphinxAtStartPar
\(O(n\ log\ n)\) is an example of a hybrid. Perhaps there is an outer loop that
is linear and an inner loop that is logarithmic.

\end{itemize}

\sphinxAtStartPar
And there are way more than these shown here. As you progress in computing, you’ll
come to know and appreciate these in greater detail.

\sphinxAtStartPar
In this lab, we’re going to look at a few different data structures and methods
that perform searches on them and do \sphinxstyleemphasis{empirical} analysis to get an idea of how
well each combination works. Contrasted with other labs where you had to write
a lot of code, we’re going to give you some code to do all of the needed work
but ask you to write the code to
do the actual analysis and produce a basic table.


\subsection{The Experiments}
\label{\detokenize{arrays/lab-searching-arrays-lists-maps:the-experiments}}
\sphinxAtStartPar
We’re going to measure the performance of data structures we have been learning
about (and \sphinxstyleemphasis{will} learn about, for lists and sets). For this lab, we’ll focus on:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Integer arrays using {\hyperref[\detokenize{arrays/searching:searching}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear Searching}}}} and {\hyperref[\detokenize{arrays/binarysearching:binarysearching}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary Searching}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lists/lists:lists}]{\sphinxcrossref{\DUrole{std,std-ref}{Lists}}}} of integers with linear searching

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dictionaries/dictionaryexamples:sets}]{\sphinxcrossref{\DUrole{std,std-ref}{Sets}}}} of integers; checking if an item is contained in the set

\end{itemize}

\sphinxAtStartPar
In the interest of fairness, we are only going to look at the time it takes
to perform the various search operations. We’re not going to count the time
to randomly\sphinxhyphen{}generate the data and actually \sphinxstyleemphasis{build} the data structure. The
reasoning is straightforward. We’re interested in the search time, which is
completely independent of other aspects that may be at play. We’re not at all
saying that the other aspects are unimportant but want to keep the assignment
focus on search.

\sphinxAtStartPar
The experimental apparatus that we are constructing will do the following
for each of the cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
create the data structure (e.g. new array, new list, new set)

\item {} 
\sphinxAtStartPar
use a random seed \sphinxcode{\sphinxupquote{seed}}, initialize a random generator that will generate
\sphinxcode{\sphinxupquote{n}} values.

\item {} 
\sphinxAtStartPar
insert the random values into the data structure .
For the case of sets, which eliminate duplicates, it is
entirely possible you will end up with a tiny fraction of a percent
fewer than \sphinxcode{\sphinxupquote{n}} values.

\item {} 
\sphinxAtStartPar
to measure the performance of any given search method, we need to perform a
significant number of lookups (based on numbers in the random sequence) to
ensure that we get an accurate idea of the \sphinxstyleemphasis{average} lookup time in practice.
We’ll call this parameter, \sphinxcode{\sphinxupquote{rep}}.  We will spread out the values looked for
by checking data elements that have indices at a regular interval throughout the array.
The separation is \sphinxcode{\sphinxupquote{m = n/rep}} when \sphinxcode{\sphinxupquote{rep \textless{} n}}. The separation is 1, and
we wrap around at the end of the array if \sphinxcode{\sphinxupquote{rep \textgreater{} n}}.

\item {} 
\sphinxAtStartPar
We’ll start a Stopwatch just before entering the loop to perform the lookups.

\end{itemize}


\subsection{Starter Project}
\label{\detokenize{arrays/lab-searching-arrays-lists-maps:starter-project}}
\sphinxAtStartPar
To make your life easier, we have put together a project
that refers to all the code for all of the experiments you need
to run. (That’s right, we’re giving you the code for the \sphinxstyleemphasis{experiments},
but you’re going to write
some code to run the various experiments and then run for varying sizes of \sphinxcode{\sphinxupquote{n}}.)
The stub file is \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/performance\_lab\_stub/performance\_lab.cs}{performance\_lab\_stub/performance\_lab.cs}.

\sphinxAtStartPar
Recreate example project performance\_lab\_stub in your solution as performance\_lab,
so you have your own copy to modify.  You can either
\begin{itemize}
\item {} 
\sphinxAtStartPar
copy into the
lab project the files \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/sorting/sorting.cs}{sorting/sorting.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/searching/searching.cs}{searching/searching.cs}, and
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/binary\_searching/binary\_searching.cs}{binary\_searching/binary\_searching.cs}.  \sphinxstyleemphasis{If} you copy them into the lab
project, \sphinxstyleemphasis{rename} the unused \sphinxcode{\sphinxupquote{Main}} method from \sphinxcode{\sphinxupquote{binary\_searching.cs}}
to something else (since Xamarin Studio allows only one \sphinxcode{\sphinxupquote{Main}} method in a
project).

\item {} 
\sphinxAtStartPar
An alternative is to recreate their whole projects,
and \sphinxstyleemphasis{reference} them from the lab project.

\end{itemize}

\sphinxAtStartPar
Here is the code for the first experiment, to test the performance of linear
searching on integer arrays:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n+nf}{ExpIntArrayLinearSearch}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{rep}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{seed}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{n}{watch}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Stopwatch}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{data}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Sorting}\PYG{p}{.}\PYG{n}{IntArrayGenerate}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{seed}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Max}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{/}\PYG{n}{rep}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Reset}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Start}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// perform the rep lookups}
\PYG{+w}{   }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{rep}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{k}\PYG{o}{++}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Searching}\PYG{p}{.}\PYG{n}{IntArrayLinearSearch}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{Stop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{watch}\PYG{p}{.}\PYG{n}{ElapsedMilliseconds}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take a quick look at how this experiment is constructed. We’ll also take a
look at the other experiments but these will likely be presented in a bit
less detail, except to highlight the differences:
\begin{itemize}
\item {} 
\sphinxAtStartPar
On line 3, we create a \sphinxcode{\sphinxupquote{Stopwatch}} instance. We’ll be using this to do the timing.

\item {} 
\sphinxAtStartPar
On lines 4\sphinxhyphen{}5, we are creating the data to be searched. Because we have already
written this code in our sorting algorithms examples, we can refer to the
Sorting class code in \sphinxcode{\sphinxupquote{sorting.cs}}, as long as you made the lab project
able to reference it.  We use the \sphinxcode{\sphinxupquote{Sorting}} class name
to access the method \sphinxcode{\sphinxupquote{IntArrayGenerate()}} within this class. We also take advantage
of this in the other experiments.

\item {} 
\sphinxAtStartPar
Line 6 converts the number of repetitions into the increment in index values for each
time.

\item {} 
\sphinxAtStartPar
Line 7 resets the stopwatch. It is not technically required; however, we tend to be
in the habit of doing it, because we sometimes reuse the same stopwatch and want
to make sure it is completely zeroed out. A call to \sphinxcode{\sphinxupquote{Reset()}} ensures it is zero.

\item {} 
\sphinxAtStartPar
Line 8 actually starts the stopwatch. We are starting here as opposed to before line
4, because the random data generation has nothing to do with the actual searching of
the array data structure.

\item {} 
\sphinxAtStartPar
Lines 10 through 12 are searching \sphinxcode{\sphinxupquote{rep}} times for an item already known to
be in the array.

\item {} 
\sphinxAtStartPar
Line 13 stops the stopwatch.

\item {} 
\sphinxAtStartPar
Line 14 returns the elapsed time in \sphinxstyleemphasis{milliseconds}
between the \sphinxcode{\sphinxupquote{Start()}} and \sphinxcode{\sphinxupquote{Stop()}} method calls,
which reflects the actual time of the experiment.

\end{itemize}

\sphinxAtStartPar
Each of the other experiments is constructed similarly.
For linear search and binary search
we use the methods created earlier.
For the lists and the set we use the built\sphinxhyphen{}in \sphinxcode{\sphinxupquote{Contains}}
method to search.
The list and set are directly initialized in their constructors from the
array data.  (More on that in later chapters.)

\sphinxAtStartPar
You need to fill in the \sphinxcode{\sphinxupquote{Main}} method.
The stub already has code to generate a random value for the \sphinxcode{\sphinxupquote{seed}} for
any run of the program.  \sphinxstyleemphasis{Read} through to the end of the lab before
starting to code.  A step\sphinxhyphen{}by\sphinxhyphen{}step sequence is suggested at the end.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Your code must parse command line \sphinxcode{\sphinxupquote{args}} for the parameters \sphinxcode{\sphinxupquote{rep}}
and \sphinxstyleemphasis{any number}
of values for \sphinxcode{\sphinxupquote{n}}.  For instance:
\begin{quote}

\sphinxAtStartPar
mono PerformanceLab.exe 50000 1000 10000 100000
\end{quote}

\sphinxAtStartPar
would generate the table shown below for 50000 repetitions
for each of the values of \sphinxcode{\sphinxupquote{n}}: 1000,
10000, and 100000.

\item {} 
\sphinxAtStartPar
In the end you will want to run each experiment
for \sphinxcode{\sphinxupquote{rep}} repetitions and iterate through each different value of \sphinxcode{\sphinxupquote{n}}.

\item {} 
\sphinxAtStartPar
Present the result data in a nice printed right\sphinxhyphen{}justified table for
all values of n,
with a title including the number of repetitions.  Print
something like the following, with the number of seconds calculated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Times in seconds with 50000 repetitions
       n    linear      list  binary     set
    1000  ????.???  ????.???  ??.???  ??.???
   10000  ????.???  ????.???  ??.???  ??.???
  100000  ????.???  ????.???  ??.???  ??.???
\end{sphinxVerbatim}

\sphinxAtStartPar
The table would be longer if more values of n were entered on the command line.
Note that the experiments return times in milliseconds, (1/1000 of a second)
while the table should print times in \sphinxstyleemphasis{seconds}.

\item {} 
\sphinxAtStartPar
Your final aim is to
show your TA or instructor the results of
a run with a table with at least three lines of data and with n
being successive powers of 10, and \sphinxstyleemphasis{non\sphinxhyphen{}zero entries everywhere}.  \sphinxstyleemphasis{Read on}
for the major catch!

\sphinxAtStartPar
You will need to
\sphinxstyleemphasis{experiment} and adjust the repetitions and \sphinxcode{\sphinxupquote{n}} choices.
In order to \sphinxstyleemphasis{get all perceptible values} (nonzero), you will need a
very large number of repetitions to work for the fastest searches.
Our choice of 50000 in the example is not appropriate with these \sphinxcode{\sphinxupquote{n}} values.
The catch is that without further tweaking, you will only get nonzero
values for all the fastest searches if the slower ones take
\sphinxstyleemphasis{ridiculously long}.

\sphinxAtStartPar
Because the range of speeds is so enormous, make an accommodation with the
slow linear versions:  If \sphinxcode{\sphinxupquote{rep \textgreater{}= 100}} and \sphinxcode{\sphinxupquote{(long)n*rep \textgreater{}= 100000000}},
then, for the linear and list columns \sphinxstyleemphasis{only}, time with \sphinxcode{\sphinxupquote{rep2 = rep/100}}
instead of \sphinxcode{\sphinxupquote{rep}},
and then compensate by multiplying the resulting time by \sphinxcode{\sphinxupquote{(double)rep/rep2}}
to produce the final table value.
(This multiplier is not necessarily just 100, since the integer division creating
\sphinxcode{\sphinxupquote{rep2}} may not be exact.)

\end{itemize}

\sphinxAtStartPar
Before making the modification for large numbers, be sure to test with
small enough values (though some results will be 0).
Once again, you are encouraged to develop this is steps, for example:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure you can parse the command line parameters.  In a testing version
write code to print out \sphinxcode{\sphinxupquote{rep}},
and \sphinxstyleemphasis{separate} code to print out all \sphinxcode{\sphinxupquote{n}} values, for any number
of \sphinxcode{\sphinxupquote{n}} values.

\item {} 
\sphinxAtStartPar
Print out one \sphinxstyleemphasis{linear} test for \sphinxcode{\sphinxupquote{rep}} and one value of \sphinxcode{\sphinxupquote{n}}.

\item {} 
\sphinxAtStartPar
Print out the results for all tests for \sphinxcode{\sphinxupquote{rep}} and one value of \sphinxcode{\sphinxupquote{n}}.
Keep \sphinxcode{\sphinxupquote{rep*n}} small enough so the linear searches do not take too much time.

\item {} 
\sphinxAtStartPar
Do all values of \sphinxcode{\sphinxupquote{n}}.

\item {} 
\sphinxAtStartPar
Make the printing be formatted as in the sample table.

\item {} 
\sphinxAtStartPar
Add the modification for large \sphinxcode{\sphinxupquote{rep*n}}.

\item {} 
\sphinxAtStartPar
Experiment and get a table to show off!

\end{enumerate}

\sphinxstepscope


\section{Multi\sphinxhyphen{}dimensional Arrays}
\label{\detokenize{arrays/twodim:multi-dimensional-arrays}}\label{\detokenize{arrays/twodim:id1}}\label{\detokenize{arrays/twodim::doc}}
\index{array@\spxentry{array}!two dimensional@\spxentry{two dimensional}}\index{two dimensional array@\spxentry{two dimensional array}}\ignorespaces 

\subsection{Rectangular Arrays (Two Dimensional)}
\label{\detokenize{arrays/twodim:rectangular-arrays-two-dimensional}}\label{\detokenize{arrays/twodim:index-0}}
\sphinxAtStartPar
You should be familiar with one dimensional arrays. The data in arrays
may be any type. While a one dimensional array
works for a sequence of data,
we need something more for a two dimensional table,
where data values vary over both row and column.

\sphinxAtStartPar
If we have a table of integers, for instance with three
rows and four columns:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{  }\PYG{l+m}{7}\PYG{+w}{ }\PYG{l+m}{55}
\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{  }\PYG{l+m}{8}\PYG{+w}{ }\PYG{l+m}{10}
\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{49}\PYG{+w}{ }\PYG{l+m}{12}
\end{sphinxVerbatim}

\sphinxAtStartPar
We could declare an array variable of the right size as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{,}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{table}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Multiple indices are separated by commas inside the square brackets.
In declaring an array type, no indices are included so the \sphinxcode{\sphinxupquote{{[},{]}}}
indicates a two dimensional array.  Where the \sphinxcode{\sphinxupquote{new}} object is being created,
the values inside the square brackets give each dimension.

\sphinxAtStartPar
In general the notation for a two dimensional array declaration is:
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{type} \sphinxcode{\sphinxupquote{{[}, {]}}} \sphinxstylestrong{variableName}
\end{quote}

\sphinxAtStartPar
and to create a new array with default values:
\begin{quote}

\sphinxAtStartPar
new \sphinxstylestrong{type} \sphinxcode{\sphinxupquote{{[}}} \sphinxstyleemphasis{intExpression1}\sphinxcode{\sphinxupquote{,}} \sphinxstyleemphasis{intExpression2} \sphinxcode{\sphinxupquote{{]}}}
\end{quote}

\sphinxAtStartPar
where the expressions evaluate to integers for the dimensions.

\sphinxAtStartPar
To assign the 8 in the table above, consider that it is in the second
row in normal counting, but we start array indices at 0, so there are
rows 0, 1, and 2, and the 8 has row index 1.
Again starting with index 0 for columns, the 8 is at index
2. We can assign a value to that position with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{table}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In fact a two dimensional array just needs two indices that could mean
anything.  For instance, it was just the standard convention,
calling the left index the row.  They could have been switched everywhere, and
assume the notation \sphinxcode{\sphinxupquote{table{[}column, row{]}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{,}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{table}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{table}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
but we will \sphinxstyleemphasis{stick with} the original \sphinxcode{\sphinxupquote{{[}row, column{]}}} model.

\sphinxAtStartPar
Data indexed by more than two integer indices can be stored in a higher
dimension array, with more indices between the square braces.  We
will only consider two dimensional arrays in the examples here.

\sphinxAtStartPar
A shorthand for initializing all the data in the table,
analogous to initializing one dimensional arrays is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{]}\PYG{+w}{ }\PYG{n}{table}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{  }\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{55}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{p}{\PYGZob{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{  }\PYG{l+m}{8}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{p}{\PYGZob{}}\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{49}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{12}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
All rows must be the same length when using this notation.

\sphinxAtStartPar
Often two dimensional arrays, like one dimensional  arrays, are processed
in loops. Multiple dimension arrays are often processed in nested loops.
We could print out this table using columns 5 spaces wide with the code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0, 5\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{table}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we wanted to make a more general function out of that code,
we have a problem:  the number of rows and columns were literal values
that we knew.  We need something more general.  For one dimensional
arrays we had the Length property, but now there are more than one
lengths!

\sphinxAtStartPar
The following csharp sequence illustrates the syntax needed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{]}\PYG{+w}{ }\PYG{n}{table}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{  }\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{55}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{      }\PYG{o}{\PYGZgt{}}\PYG{+w}{                   }\PYG{p}{\PYGZob{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{  }\PYG{l+m}{8}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{      }\PYG{o}{\PYGZgt{}}\PYG{+w}{                   }\PYG{p}{\PYGZob{}}\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{49}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{12}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{table}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{l+m}{12}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{table}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{table}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{4}
\PYG{n}{csharp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{table}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{o}{\PYGZgt{}}\PYG{+w}{    }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{l+m}{2}
\PYG{l+m}{4}
\PYG{l+m}{7}
\PYG{l+m}{55}
\PYG{l+m}{3}
\PYG{l+m}{1}
\PYG{l+m}{8}
\PYG{l+m}{10}
\PYG{l+m}{6}
\PYG{l+m}{0}
\PYG{l+m}{49}
\PYG{l+m}{12}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The meaning for the Length property,
is now the \sphinxstyleemphasis{total} number of elements, (3)(4) = 12.

\item {} 
\sphinxAtStartPar
The separate method \sphinxcode{\sphinxupquote{GetLength}} is needed to find the number of rows and columns.
The entries in the list of array indices in the multi\sphinxhyphen{}dimensional array notation
are themselves indexed to provide the \sphinxcode{\sphinxupquote{GetLength}} method parameter for each dimension.
In this case index 0 gives the row length (left index of the array notation),
and 1 gives the column length (right index of the array notation).

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{foreach}} statement behavior is consistent with the \sphinxcode{\sphinxupquote{Length}} property, giving \sphinxstyleemphasis{all}
the elements, row by row.  More generally, the rightmost indices vary most rapidly
as the \sphinxcode{\sphinxupquote{foreach}} statement iterates through all elements.

\end{itemize}

\sphinxAtStartPar
Just replacing 3 and 4 by \sphinxcode{\sphinxupquote{table.GetLength(0)}} and \sphinxcode{\sphinxupquote{table.GetLength(1)}} in the
table printing code would make it general.

\sphinxAtStartPar
A more elaborate table might include row and column sums:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{l+m}{2}\PYG{+w}{   }\PYG{l+m}{4}\PYG{+w}{   }\PYG{l+m}{7}\PYG{+w}{  }\PYG{l+m}{55}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{68}
\PYG{+w}{  }\PYG{l+m}{3}\PYG{+w}{   }\PYG{l+m}{1}\PYG{+w}{   }\PYG{l+m}{8}\PYG{+w}{  }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{22}
\PYG{+w}{  }\PYG{l+m}{6}\PYG{+w}{   }\PYG{l+m}{0}\PYG{+w}{  }\PYG{l+m}{49}\PYG{+w}{  }\PYG{l+m}{12}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{67}
\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{+w}{ }\PYG{l+m}{11}\PYG{+w}{   }\PYG{l+m}{5}\PYG{+w}{  }\PYG{l+m}{64}\PYG{+w}{  }\PYG{l+m}{77}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{157}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example, the following function from example file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_table/print\_table.cs}{print\_table/print\_table.cs},
prints out a table of integers
neatly, including row and column sums.  It illustrates
a number of things.  It shows the interplay between
one and two dimensional arrays, since the row and column sums are
just one dimensional arrays.

\sphinxAtStartPar
Now that we are using arrays,
we can easily look at the same collection of data repeatedly.
It is possible to look at the data one time to just see its maximum
width, and then go through again and print data using a column
width that is just large enough for the longest numbers.
When looking through the data for string lengths, the row and column
structure is not important, so the code illustrates \sphinxcode{\sphinxupquote{foreach}} loops
to chug through all the data.  We use the earlier trick in
{\hyperref[\detokenize{for/forexamples:modular-mult-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Modular Multiplication Table}}}}, creating a custom format string to make columns
the right width.

\sphinxAtStartPar
The code refers once to the earlier \sphinxcode{\sphinxupquote{StringOfReps}} in {\hyperref[\detokenize{for/lab-nested-loops:lab-loops}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab: Loops}}}}
for the row of dashes setting off the column sums:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintTableAndSums}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{,}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{rowSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{         }\PYG{n}{colSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{rowSum}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{               }\PYG{n}{colSum}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{rowSum}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{sum}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Max}\PYG{p}{(}\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{colSum}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Max}\PYG{p}{(}\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{rowSum}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Max}\PYG{p}{(}\PYG{n}{width}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{format}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZob{}0,\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{width}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZcb{} \PYGZdq{}}\PYG{p}{;}

\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{r}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{format}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}| \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{format}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{rowSum}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{reps}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{StringOfReps}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{width}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{reps}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{GetLength}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{format}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{colSum}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}| \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{format}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\index{exercise@\spxentry{exercise}!row and column numbering@\spxentry{row and column numbering}}\index{row and column numbering exercise@\spxentry{row and column numbering exercise}}\ignorespaces 

\subsubsection{Row and Column Numbering Exercise}
\label{\detokenize{arrays/twodim:row-and-column-numbering-exercise}}\label{\detokenize{arrays/twodim:row-col-number-exercise}}\label{\detokenize{arrays/twodim:index-1}}
\sphinxAtStartPar
Write a function that sets the values in a given
rectangular array to 10 * (row index +1) + column index + 1, with the
normal row and column indices, starting from 0. For example
an array with two rows
and five columns would end up with values below. Your method should set
the values in the array, not print them out:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{11}\PYG{+w}{ }\PYG{l+m}{12}\PYG{+w}{ }\PYG{l+m}{13}\PYG{+w}{ }\PYG{l+m}{14}\PYG{+w}{ }\PYG{l+m}{15}
\PYG{l+m}{21}\PYG{+w}{ }\PYG{l+m}{22}\PYG{+w}{ }\PYG{l+m}{23}\PYG{+w}{ }\PYG{l+m}{24}\PYG{+w}{ }\PYG{l+m}{25}
\end{sphinxVerbatim}

\sphinxAtStartPar
If there are no more than 9 rows or columns, this display gives row and
column numbers neatly for the normal human counting system, starting from 1.

\index{exercise@\spxentry{exercise}!varying column width@\spxentry{varying column width}}\index{varying column width exercise@\spxentry{varying column width exercise}}\ignorespaces 

\subsubsection{Varying Column Width Exercise}
\label{\detokenize{arrays/twodim:varying-column-width-exercise}}\label{\detokenize{arrays/twodim:varying-width-columns-exercise}}\label{\detokenize{arrays/twodim:index-2}}
\sphinxAtStartPar
Copy the project file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/print\_table/print\_table.cs}{print\_table/print\_table.cs} to a file
\sphinxcode{\sphinxupquote{print\_varying\_width\_table.cs}} in a projet of yours.
Edit it so that \sphinxstyleemphasis{each} column
is only as wide as it needs to be: the width for the widest entry in
that column.
The earlier data would now print as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{  }\PYG{l+m}{7}\PYG{+w}{ }\PYG{l+m}{55}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{68}
\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{  }\PYG{l+m}{8}\PYG{+w}{ }\PYG{l+m}{10}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{22}
\PYG{+w}{ }\PYG{l+m}{6}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{l+m}{49}\PYG{+w}{ }\PYG{l+m}{12}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{  }\PYG{l+m}{67}
\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}
\PYG{l+m}{11}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }\PYG{l+m}{64}\PYG{+w}{ }\PYG{l+m}{77}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{l+m}{157}
\end{sphinxVerbatim}

\sphinxAtStartPar
Calculate each of these widths \sphinxstyleemphasis{only once}.
Hint: Create an array of widths and an array of format strings.

\index{array@\spxentry{array}!of arrays@\spxentry{of arrays}}\index{array@\spxentry{array}!two\sphinxhyphen{}dimensional, ragged@\spxentry{two\sphinxhyphen{}dimensional, ragged}}\ignorespaces 

\subsection{Advanced topic: Array of Arrays}
\label{\detokenize{arrays/twodim:advanced-topic-array-of-arrays}}\label{\detokenize{arrays/twodim:index-3}}
\sphinxAtStartPar
Since you can have an array of any type, it is also possible to have an
\sphinxstyleemphasis{array of arrays}.

\sphinxAtStartPar
You could create a table with shape like the initial example
in {\hyperref[\detokenize{arrays/twodim:multi-dimensional-arrays}]{\sphinxcrossref{\DUrole{std,std-ref}{Multi\sphinxhyphen{}dimensional Arrays}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{table2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{array}\PYG{p}{[}\PYG{l+m}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and refer to an element still by row and column index::

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{table2}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The notational difference so far is just that each index in enclosed in
separate square brackets, with no commas.

\sphinxAtStartPar
This takes somewhat more memory and is longer to
access than the multidimensional arrays that we have been talking about
with the comma\sphinxhyphen{}separated notation.  For most uses, when you want to
refer to a rectangular table of data, like above,
this new version has little to
offer.

\sphinxAtStartPar
There are a couple of reasons why you might want this format.

\sphinxAtStartPar
First you may have functions that operate on one dimensional arrays,
and individual rows of \sphinxcode{\sphinxupquote{table2}} are one dimensional arrays:
\sphinxcode{\sphinxupquote{table2{[}1{]}}} has type \sphinxcode{\sphinxupquote{int{[}{]}}}.  On the other hand, with the
earlier \sphinxcode{\sphinxupquote{table}} with type  \sphinxcode{\sphinxupquote{int{[},{]}}}, references to part of
the array must always include a comma, so \sphinxcode{\sphinxupquote{tabel{[}1{]}}} would
not refer to a row, but would be a syntax error.

\sphinxAtStartPar
Also in an array of arrays, since each row is an independent array,
their lengths can \sphinxstyleemphasis{vary}.
Here is code to make a doubly indexed “triangular” collection
(of 0 values).
Each row must be separately created as a new array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{tri}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//create four null int[] elements}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{tri}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// Length 4 (rows)}
\PYG{+w}{   }\PYG{n}{tri}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// each row has a different length}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{tri}} constructed as above:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tri{[}3, 3{]}}} would given a compiler error: no changing \sphinxcode{\sphinxupquote{{[}{]}{[}{]}}} to \sphinxcode{\sphinxupquote{{[}, {]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tri{[}3{]}{[}3{]}}} would refer to an element.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tri{[}1{]}{[}3{]}}} would given a run\sphinxhyphen{}time out\sphinxhyphen{}of\sphinxhyphen{}bounds error.
since \sphinxcode{\sphinxupquote{tri{[}1{]}}} is an array of length 2.

\end{itemize}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{arrays/reviewarrays:chapter-review-questions}}\label{\detokenize{arrays/reviewarrays::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
When do you want to use an array rather than just
a bunch of individually named variables?

\item {} 
\sphinxAtStartPar
Before writing a program, must you know the exact size of an array that
you are going to create?

\item {} 
\sphinxAtStartPar
Before creating a new array in a program,
must the program be able to calculate the proper size for the array?

\item {} 
\sphinxAtStartPar
After you have created the array, can you change the size of the original
array object?

\item {} 
\sphinxAtStartPar
If I have the declaration

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{vals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
What is stored directly in the memory position for variable \sphinxcode{\sphinxupquote{vals}}?

\item {} 
\sphinxAtStartPar
Does \sphinxcode{\sphinxupquote{vals{[}3{]}}} then have a clear value?  If so, what?

\item {} 
\sphinxAtStartPar
Can I later make \sphinxcode{\sphinxupquote{vals}} refer to an array of a different size?

\end{enumerate}

\item {} 
\sphinxAtStartPar
Comment on the comparison between these two snippets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{char}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}n\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}o\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}w\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}c\PYGZsq{}}\PYG{p}{;}

\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}now\PYGZdq{}}\PYG{p}{;}
\PYG{n}{s}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}c\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
If I want to read or modify the first 100 elements of a 999 element
array, would I use a
\sphinxcode{\sphinxupquote{foreach}} loop or a \sphinxcode{\sphinxupquote{for}} loop? Explain.

\item {} 
\sphinxAtStartPar
If I want to modify all the elements of an array, would I use a
\sphinxcode{\sphinxupquote{foreach}} loop or a \sphinxcode{\sphinxupquote{for}} loop? Explain.

\item {} 
\sphinxAtStartPar
If I want to read all the elements of an array, but not change the array,
and I do not care about the exact position in the array of any member,
would I use a \sphinxcode{\sphinxupquote{foreach}} loop or a \sphinxcode{\sphinxupquote{for}} loop?

\item {} 
\sphinxAtStartPar
Is this legal?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//...}
\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m}{7}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The definition of a program’s \sphinxcode{\sphinxupquote{Main}} method may optionally
include a parameter.  What is the type?  How is it used?

\item {} 
\sphinxAtStartPar
What is an alias?  Why is understanding aliases important with arrays?

\item {} 
\sphinxAtStartPar
If I have a function declared

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{)}
\PYG{c+c1}{//...}
\end{sphinxVerbatim}

\sphinxAtStartPar
and I call it from my \sphinxcode{\sphinxupquote{Main}} function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{n}{f}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Could \sphinxcode{\sphinxupquote{f}} change the value of the variable \sphinxcode{\sphinxupquote{v}}, so 1 is printed
in \sphinxcode{\sphinxupquote{Main}}?
If so, write a one\sphinxhyphen{}line body for \sphinxcode{\sphinxupquote{f}} that does it.

\item {} 
\sphinxAtStartPar
If I have a function declared

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}
\PYG{c+c1}{//...}
\end{sphinxVerbatim}

\sphinxAtStartPar
and I call it from my \sphinxcode{\sphinxupquote{Main}} function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{f}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Could \sphinxcode{\sphinxupquote{f}} change the value of the variable \sphinxcode{\sphinxupquote{v{[}0{]}}}, so 1 is printed
in \sphinxcode{\sphinxupquote{Main}}?
If so, write a one\sphinxhyphen{}line body for \sphinxcode{\sphinxupquote{f}} that does it.

\item {} 
\sphinxAtStartPar
What is printed by this snippet?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is printed by this snippet? (Only the second line is changed.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{;}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
If my only use for variable \sphinxcode{\sphinxupquote{temp}} is to set up this call to \sphinxcode{\sphinxupquote{f}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{f}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
how could I rewrite it with an anonymous array?

\item {} 
\sphinxAtStartPar
After this line, what is the value of \sphinxcode{\sphinxupquote{a{[}2{]}}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
This will cause a runtime error.  Why?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
If you get a data sequence from a \sphinxcode{\sphinxupquote{Random}} object,
is it really random?

\item {} 
\sphinxAtStartPar
Explain the significance of a \sphinxstyleemphasis{seed} for a \sphinxcode{\sphinxupquote{Random}} object.

\item {} 
\sphinxAtStartPar
Suppose I create an object \sphinxcode{\sphinxupquote{table}} of type \sphinxcode{\sphinxupquote{double{[},{]}}},
and I think of the first index as referring to a row and the second
index as referring to a column.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Must each row be the same length?

\item {} 
\sphinxAtStartPar
Does each row have a type \sphinxcode{\sphinxupquote{double{[}{]}}} ?

\end{enumerate}

\item {} 
\sphinxAtStartPar
(Optional) Suppose I create an object \sphinxcode{\sphinxupquote{table}} of type \sphinxcode{\sphinxupquote{double{[}{]}{[}{]}}},
and I think of the first index as referring to a row and the second
index as referring to a column.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Must each each row be the same length?

\item {} 
\sphinxAtStartPar
Does each row have a type \sphinxcode{\sphinxupquote{double{[}{]}}} ?

\end{enumerate}

\end{enumerate}

\sphinxstepscope

\index{list@\spxentry{list}}\index{type@\spxentry{type}!List@\spxentry{List}}\ignorespaces 

\chapter{Lists}
\label{\detokenize{lists/lists:lists}}\label{\detokenize{lists/lists:index-0}}\label{\detokenize{lists/lists:id1}}\label{\detokenize{lists/lists::doc}}
\sphinxstepscope

\index{list@\spxentry{list}}\ignorespaces 

\section{List Syntax}
\label{\detokenize{lists/listsyntax:list-syntax}}\label{\detokenize{lists/listsyntax:listsyntax}}\label{\detokenize{lists/listsyntax:index-0}}\label{\detokenize{lists/listsyntax::doc}}
\sphinxAtStartPar
Arrays are fine if you know ahead of time how long your sequence of items is.
Then you create your array with that length, and you are all set.

\sphinxAtStartPar
If you want a variable sized container, you are likely to want a \sphinxcode{\sphinxupquote{List}}.
As with arrays, you might want a collection of any particular type.
Unfortunately, you cannot use the simple notation of arrays to specify
the type of element in a \sphinxcode{\sphinxupquote{List}}.  Array syntax is
\sphinxstyleemphasis{built into} the language.  Lists are handled in the \sphinxstyleemphasis{library} of types
provided by C\# from the .Net framework.  There are all sorts of
situations where you might want a general idea to have a version for each of
many kinds of objects.  There is \sphinxstyleemphasis{not} a new syntax for \sphinxstyleemphasis{each} one.

\index{generics@\spxentry{generics}}\index{\textless{} \textgreater{} for generics@\spxentry{\textless{} \textgreater{} for generics}}\ignorespaces 

\subsection{Generics}
\label{\detokenize{lists/listsyntax:generics}}\label{\detokenize{lists/listsyntax:index-1}}
\sphinxAtStartPar
Instead .Net 4.0 introduced one new form of syntax that can apply to all sorts of
classes, \sphinxstyleemphasis{generics}.

\sphinxAtStartPar
The type for a list of strings is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The type for an \sphinxcode{\sphinxupquote{int}} list is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general the new generic syntax allows a type (or several, comma separated) in angle
brackets after a class name.  Lists are an example that depends on just
one included type.  We will see more shortly.

\sphinxAtStartPar
There is a namespace for the generics for collections, including List:
System.Collections.Generic.

\sphinxAtStartPar
We will use several generic library classes, though we will not write the definitions of
new generic classes ourselves.

\index{List@\spxentry{List}!constructor@\spxentry{constructor}}\index{List@\spxentry{List}!Count@\spxentry{Count}}\index{List@\spxentry{List}!Add@\spxentry{Add}}\index{List@\spxentry{List}!Remove@\spxentry{Remove}}\index{List@\spxentry{List}!RemoveAt@\spxentry{RemoveAt}}\index{List@\spxentry{List}!Contains@\spxentry{Contains}}\ignorespaces 

\subsection{List Constructors and Methods}
\label{\detokenize{lists/listsyntax:list-constructors-and-methods}}\label{\detokenize{lists/listsyntax:index-2}}
\sphinxAtStartPar
We can play with some \sphinxcode{\sphinxupquote{List}} methods in csharp.
Note that csharp informally displays the
value of a \sphinxcode{\sphinxupquote{List}} with a list of elements inside braces.
This is \sphinxstyleemphasis{not} a legal
way to assign values to lists.

\sphinxAtStartPar
The blocks below are all from one csharp session,
with our comments breaking up the sequence.

\sphinxAtStartPar
With the no\sphinxhyphen{}parameter constructor, the \sphinxcode{\sphinxupquote{List}} is empty to start:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} List\PYGZlt{}string\PYGZgt{} words = new List\PYGZlt{}string\PYGZgt{}();
csharp\PYGZgt{} words;
\PYGZob{}  \PYGZcb{}
csharp\PYGZgt{} words.Count;
0
\end{sphinxVerbatim}

\sphinxAtStartPar
You can add elements, and keep count with the \sphinxcode{\sphinxupquote{Count}} property
as the size changes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words.Add(\PYGZdq{}up\PYGZdq{});
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} words.Add(\PYGZdq{}down\PYGZdq{});
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}down\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} words.Add(\PYGZdq{}over\PYGZdq{});
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}down\PYGZdq{}, \PYGZdq{}over\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} words.Count;
3
\end{sphinxVerbatim}

\index{list@\spxentry{list}!index {[} {]}@\spxentry{index {[} {]}}}\index{{[} {]}@\spxentry{{[} {]}}!list index@\spxentry{list index}}\ignorespaces 
\sphinxAtStartPar
You can reference and change elements by index, like with arrays:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words[0];
\PYGZdq{}up\PYGZdq{}
csharp\PYGZgt{} words[2];
\PYGZdq{}over\PYGZdq{}
csharp\PYGZgt{} words[2] = \PYGZdq{}in\PYGZdq{};
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}down\PYGZdq{}, \PYGZdq{}in\PYGZdq{} \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can use \sphinxcode{\sphinxupquote{foreach}} like with arrays or other sequences:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} foreach (string s in words) \PYGZob{}
          \PYGZgt{}    Console.WriteLine(s.ToUpper());
          \PYGZgt{} \PYGZcb{}
UP
DOWN
ON
\end{sphinxVerbatim}

\index{List@\spxentry{List}!Console.WriteLine useless@\spxentry{Console.WriteLine useless}}\ignorespaces 
\sphinxAtStartPar
Note:  Unfortunately C\# is not user\sphinxhyphen{}friendly if
you try to use \sphinxcode{\sphinxupquote{Console.WriteLine}} to print a \sphinxcode{\sphinxupquote{List}} \sphinxstyleemphasis{object}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(words)
System.Collections.Generic.List`1[System.Int32]
\end{sphinxVerbatim}

\sphinxAtStartPar
Next compare \sphinxcode{\sphinxupquote{Remove}}, which finds the first matching element and removes it,
and \sphinxcode{\sphinxupquote{RemoveAt}}, which removes the element at a specified index.
\sphinxcode{\sphinxupquote{Remove}} returns whether the List has been changed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words.Remove(\PYGZdq{}down\PYGZdq{});
true
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}in\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} words.Remove(\PYGZdq{}around\PYGZdq{}); // no change
false
csharp\PYGZgt{} words.Add(\PYGZdq{}out\PYGZdq{});
csharp\PYGZgt{} words.Add(\PYGZdq{}on\PYGZdq{});
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}in\PYGZdq{}, \PYGZdq{}out\PYGZdq{}, \PYGZdq{}on\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} words.RemoveAt(2); // \PYGZdq{}out\PYGZdq{} is at index 2
csharp\PYGZgt{} words;
\PYGZob{} \PYGZdq{}up\PYGZdq{}, \PYGZdq{}in\PYGZdq{}, \PYGZdq{}on\PYGZdq{} \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Removing does not leave a “hole” in the \sphinxcode{\sphinxupquote{List}}:  The list closes up,
so the index decreases for the elements after the removed one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words[2];
\PYGZdq{}on\PYGZdq{}
csharp\PYGZgt{} words.Count;
3
\end{sphinxVerbatim}

\sphinxAtStartPar
You can check for membership in a \sphinxcode{\sphinxupquote{List}} with \sphinxcode{\sphinxupquote{Contains}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words.Contains(\PYGZdq{}in\PYGZdq{});
true
csharp\PYGZgt{} words.Contains(\PYGZdq{}into\PYGZdq{});
false
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also remove all elements at once:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} words.Clear();
csharp\PYGZgt{} words.Count;
0
\end{sphinxVerbatim}

\index{List@\spxentry{List}!constructor with sequence@\spxentry{constructor with sequence}}\ignorespaces 
\sphinxAtStartPar
Here is a List containing \sphinxcode{\sphinxupquote{int}} elements.
Though more verbose than for an array, you can initialize a \sphinxcode{\sphinxupquote{List}}
with another collection, including an anonymous array,
specified with an explicit sequence in braces:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} List\PYGZlt{}int\PYGZgt{} nums = new List\PYGZlt{}int\PYGZgt{}(new[]\PYGZob{}5, 3, 7, 4\PYGZcb{});
csharp\PYGZgt{} nums;
\PYGZob{} 5, 3, 7, 4 \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have been using the explicit declaration syntax, but generic types tend to get long,
so \sphinxcode{\sphinxupquote{var}} is handy with them:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{stuff}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
When initializing a generic object, you still need to remember both the angle braces
around the type \sphinxstyleemphasis{and} the parentheses for the parameter list after that.

\index{side effect@\spxentry{side effect}}\ignorespaces 
\sphinxAtStartPar
An aside on the \sphinxcode{\sphinxupquote{Remove}} method:  It both causes a side effect,
changing the list,
\sphinxstyleemphasis{and} it returns a value.  If a function returns a value,
we typically use the function call as an
expression in a larger statement.  This is not necessary, as described in
{\hyperref[\detokenize{functions/notusereturn:not-using-ret-val}]{\sphinxcrossref{\DUrole{std,std-ref}{Not using Return Values}}}}.  In that section we discussed the \sphinxstyleemphasis{mistake} of not
using return values.  The \sphinxcode{\sphinxupquote{Remove}} method illustrates that this is
not always a mistake:  If you just want the side effect, trying to remove an element,
whether or not it is in the list, then there is no need to check for the return value.
This complete C\# statement is fine:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{someList}\PYG{p}{.}\PYG{n}{Remove}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You should generally think carefully before \sphinxstyleemphasis{defining} a function
that both has a side effect
and a return value.  Most functions that return a value do not have a side effect.
If you see a function used in the normal way as an expression, it is easy to forget that
it was \sphinxstyleemphasis{also} producing some side effect.

\index{example@\spxentry{example}!ReadLines@\spxentry{ReadLines}}\index{ReadLines example@\spxentry{ReadLines example}}\index{List@\spxentry{List}!ReadLines example@\spxentry{ReadLines example}}\ignorespaces 

\subsection{Interactive List Example}
\label{\detokenize{lists/listsyntax:interactive-list-example}}\label{\detokenize{lists/listsyntax:index-7}}
\sphinxAtStartPar
Lists are handy when you do not know how much data there will be.
A simple example would be reading in lines from the user interactively:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a List of lines entered by the user in response}
\PYG{c+c1}{/// to the prompt.  Lines in the List will be nonempty, since an}
\PYG{c+c1}{/// empty line terminates the input.}
\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ReadLines}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{prompt}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{lines}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}An empty line terminates input.\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{line}\PYG{p}{.}\PYG{n}{Length}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{lines}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{line}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{lines}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstepscope

\index{.net api@\spxentry{.net api}}\index{API for .Net@\spxentry{API for .Net}}\index{library@\spxentry{library}!reference for .Net@\spxentry{reference for .Net}}\index{URL for .Net library reference@\spxentry{URL for .Net library reference}}\index{msdn.microsoft.com@\spxentry{msdn.microsoft.com}}\ignorespaces 

\section{.Net Library (API)}
\label{\detokenize{lists/dotnetapi:net-library-api}}\label{\detokenize{lists/dotnetapi:dotnetapi}}\label{\detokenize{lists/dotnetapi:index-0}}\label{\detokenize{lists/dotnetapi::doc}}
\sphinxAtStartPar
This book can only introduce so many classes and methods from the C\# library.
You should browse the MSDN .Net Framework Class Library’s online documentation.
\begin{quote}

\sphinxAtStartPar
\sphinxurl{http://msdn.microsoft.com/en-us/library/gg145045.aspx}
\end{quote}

\sphinxAtStartPar
We mostly deal with classes in the namespaces System, System.IO,
and System.Collections.Generic, and you can drill down to them.

\sphinxAtStartPar
One complication is that
variations on these classes and methods are included for several Microsoft languages.
Under the Syntax heading, make sure the \sphinxstylestrong{C\# tab} is selected.

\sphinxAtStartPar
For example, you can click in the left column on System.Collections Namespaces, and then
System.Collections.Generic, and then, for example, List(T).  (In C\# that is \sphinxcode{\sphinxupquote{List\textless{}T\textgreater{}}}.)

\sphinxAtStartPar
The summary section separates constructors, properties, and methods.  When you see one of these
with promise, click on it to get the full details.  For example, click on the first method in the
Methods section, \sphinxcode{\sphinxupquote{Add}}, or something new, like \sphinxcode{\sphinxupquote{IndexOf}}, or \sphinxcode{\sphinxupquote{Reverse}}, or \sphinxcode{\sphinxupquote{Sort}}….

\sphinxAtStartPar
Classes also can be classified in several ways for browsing:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Those you will want to be fairly familiar with pretty soon:  string, List, Dictionary

\item {} 
\sphinxAtStartPar
Those that might be useful, that you should be at least aware of.

\item {} 
\sphinxAtStartPar
Those that may be useful eventually, but are not worth your time now.

\end{itemize}

\sphinxAtStartPar
You will also find methods in various categories as you browse:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Methods that make sense and are useful right away

\item {} 
\sphinxAtStartPar
Methods that take a little reading to absorb

\item {} 
\sphinxAtStartPar
Features that we have yet to discuss

\item {} 
\sphinxAtStartPar
Features that are well beyond what we have talked about \sphinxhyphen{} ask or wait or read a \sphinxstyleemphasis{lot}.

\end{itemize}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{lists/reviewlists:chapter-review-questions}}\label{\detokenize{lists/reviewlists::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Distinguish the cases when you would want to use a list instead of an array, or
the other way around.

\item {} 
\sphinxAtStartPar
What syntax is consistent between arrays and lists?  What are comparable
features, but with different syntax?

\item {} 
\sphinxAtStartPar
How is the type declaration for a generic type distinctive?

\item {} 
\sphinxAtStartPar
Here is one way to put five particular elements into a list:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}a\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}an\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}the\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}on\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}of\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{foreach}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{temp}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{words}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
How can you do this all without a loop, and with only two statements?
How about with a single statement,
assuming you do not need \sphinxcode{\sphinxupquote{temp}} again?

\item {} 
\sphinxAtStartPar
If we continue on from above, with the line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{words2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then what would be the difference in effect between these two possible next
lines?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{words}\PYG{p}{.}\PYG{n}{Clear}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The constructors for collections like a List are all overloaded.
What forms are allowed in general?

\item {} 
\sphinxAtStartPar
If you delete an element from the middle of a list, what happens to the
spot where you removed the element?

\end{enumerate}

\sphinxstepscope

\index{dictionary@\spxentry{dictionary}}\index{type@\spxentry{type}!Dictionary@\spxentry{Dictionary}}\ignorespaces 

\chapter{Dictionaries}
\label{\detokenize{dictionaries/dictionaries:dictionaries}}\label{\detokenize{dictionaries/dictionaries:dictionary}}\label{\detokenize{dictionaries/dictionaries:index-0}}\label{\detokenize{dictionaries/dictionaries::doc}}
\sphinxstepscope


\section{Dictionary Syntax}
\label{\detokenize{dictionaries/dictionarysyntax:dictionary-syntax}}\label{\detokenize{dictionaries/dictionarysyntax::doc}}
\sphinxAtStartPar
We have explored several ways of storing a collection of the same type of data:
\begin{itemize}
\item {} 
\sphinxAtStartPar
arrays: built\sphinxhyphen{}in syntax, unchanging size of the collection

\item {} 
\sphinxAtStartPar
List: generic class type, allows the size of the collection to grow

\end{itemize}

\sphinxAtStartPar
Both approaches allow reference to data elements using a
numerical index between square brackets, as in \sphinxcode{\sphinxupquote{words{[}i{]}}}.
The index provides an order for the elements,
but there is no meaning to the index beyond the sequence order.

\sphinxAtStartPar
Often, we want to look up data based on a more meaningful key, as in a
dictionary: given a word,
you can look up the definition.

\sphinxAtStartPar
C\# uses the type name \sphinxcode{\sphinxupquote{Dictionary}}, but with greater generality than in
nontechnical use. In a regular dictionary, you start with a word,
and look up the definition.  The generalization is to have some piece of
data that leads you to (or \sphinxstyleemphasis{maps} to) another piece of data.
The computer science jargon is that a \sphinxstyleemphasis{key} leads you to a \sphinxstyleemphasis{value}.
In a normal dictionary, these are both likely to be strings, but in the
C\# generalization, the possible types of key and value are much more extensive.
Hence the generic \sphinxcode{\sphinxupquote{Dictionary}} type requires you to specify
both a type for the key and a type for the value.

\sphinxAtStartPar
We can initialize an English\sphinxhyphen{}Spanish dictionary \sphinxcode{\sphinxupquote{e2sp}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{e2sp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is quite a mouthful!  The C\# \sphinxcode{\sphinxupquote{var}} syntax is handy to shorten it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{e2sp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The general generic type syntax is
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dictionary\textless{}}} \sphinxstylestrong{keyType}\sphinxcode{\sphinxupquote{,}} \sphinxstylestrong{valueType} \sphinxcode{\sphinxupquote{\textgreater{}}}
\end{quote}

\sphinxAtStartPar
If you are counting the number of repetitions of words in a document, you are likely to want
a \sphinxcode{\sphinxupquote{Dictionary}} mapping each word to its number of repetitions so far:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{wordCount}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If your friends all have a personal list of phone numbers, you might look them up
with a dictionary with a string name for the key and a \sphinxcode{\sphinxupquote{List}} of personal phone number
strings for the value.  The type could be \sphinxcode{\sphinxupquote{Dictionary\textless{}string, List\textless{}string\textgreater{}\textgreater{}}}.
This example illustrates how one generic type can be built on another.

\sphinxAtStartPar
There is no restriction on the value type.  There is one important technical
restriction on the key type: it should be immutable. This has to do with the implementation
referenced in {\hyperref[\detokenize{dictionaries/dictionaryefficiency:dictionary-efficiency}]{\sphinxcrossref{\DUrole{std,std-ref}{Dictionary Efficiency}}}}.

\index{dictionary@\spxentry{dictionary}!key lookup {[} {]}@\spxentry{key lookup {[} {]}}}\index{{[} {]}@\spxentry{{[} {]}}!dictionary key lookup@\spxentry{dictionary key lookup}}\ignorespaces 
\sphinxAtStartPar
Similar to an array or \sphinxcode{\sphinxupquote{List}},
you can assign and reference elements of a \sphinxcode{\sphinxupquote{Dictionary}},
using square bracket notation.  The difference is that the reference is through a key,
not a sequential index, as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{e2sp}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}one\PYGZdq{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}uno\PYGZdq{}}\PYG{p}{;}
\PYG{n}{e2sp}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}two\PYGZdq{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}dos\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Csharp displays dictionaries in its own special form,
as a sequence of pairs \{key, value\}.  Again, this is \sphinxstyleemphasis{special} to csharp.
Here is a longer csharp sequence, broken up with our comments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Dictionary\PYGZlt{}string, string\PYGZgt{} e2sp = new Dictionary\PYGZlt{}string, string\PYGZgt{}();
csharp\PYGZgt{} e2sp;
\PYGZob{}\PYGZcb{}
csharp\PYGZgt{} e2sp[\PYGZdq{}one\PYGZdq{}] = \PYGZdq{}uno\PYGZdq{};
csharp\PYGZgt{} e2sp[\PYGZdq{}two\PYGZdq{}] = \PYGZdq{}dos\PYGZdq{};
csharp\PYGZgt{} e2sp[\PYGZdq{}three\PYGZdq{}] = \PYGZdq{}tres\PYGZdq{};
csharp\PYGZgt{} e2sp.Count;
3
csharp\PYGZgt{} e2sp;
\PYGZob{}\PYGZob{} \PYGZdq{}one\PYGZdq{}, \PYGZdq{}uno\PYGZdq{} \PYGZcb{}, \PYGZob{} \PYGZdq{}two\PYGZdq{}, \PYGZdq{}dos\PYGZdq{} \PYGZcb{}, \PYGZob{} \PYGZdq{}three\PYGZdq{}, \PYGZdq{}tres\PYGZdq{} \PYGZcb{}\PYGZcb{}
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}...\PYGZdq{}, e2sp[\PYGZdq{}one\PYGZdq{}],
      \PYGZgt{} e2sp[\PYGZdq{}two\PYGZdq{}], e2sp[\PYGZdq{}three\PYGZdq{}]);
uno, dos, tres...
\end{sphinxVerbatim}

\index{dictionary@\spxentry{dictionary}!Keys@\spxentry{Keys}}\index{Keys property@\spxentry{Keys property}}\ignorespaces 
\sphinxAtStartPar
If you want to iterate through a whole \sphinxcode{\sphinxupquote{Dictionary}}, you will want the syntax below,
with \sphinxcode{\sphinxupquote{foreach}} and the property \sphinxcode{\sphinxupquote{Keys}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} foreach (string s in e2sp.Keys) \PYGZob{}
      \PYGZgt{}    Console.WriteLine(s);
      \PYGZgt{} \PYGZcb{}
one
two
three
\end{sphinxVerbatim}

\sphinxAtStartPar
The documentation for \sphinxcode{\sphinxupquote{Dictionary}} says
that you cannot depend on the order of processing with \sphinxcode{\sphinxupquote{foreach}}, though the present
implementation remembers the order in which keys were added.

\index{example@\spxentry{example}!ContainsKey@\spxentry{ContainsKey}}\index{dictionary@\spxentry{dictionary}!ContainsKey example@\spxentry{ContainsKey example}}\index{ContainsKey example@\spxentry{ContainsKey example}}\ignorespaces 
\sphinxAtStartPar
It is often useful to know if a key is already in a \sphinxcode{\sphinxupquote{Dictionary}}:
Note the method \sphinxcode{\sphinxupquote{ContainsKey}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} e2sp.ContainsKey(\PYGZdq{}seven\PYGZdq{});
false
csharp\PYGZgt{} e2sp.ContainsKey(\PYGZdq{}three\PYGZdq{});
true
\end{sphinxVerbatim}

\sphinxAtStartPar
The method Remove takes a key as parameter.  Like a \sphinxcode{\sphinxupquote{List}} and other
collections, a \sphinxcode{\sphinxupquote{Dictionary}} has a \sphinxcode{\sphinxupquote{Clear}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} e2sp.Count;
3
csharp\PYGZgt{} e2sp.Remove(\PYGZdq{}two\PYGZdq{});
true
csharp\PYGZgt{} e2sp.Count;
2
csharp\PYGZgt{} e2sp.Clear();
csharp\PYGZgt{} e2sp.Count;
0
\end{sphinxVerbatim}

\sphinxstepscope

\index{big oh@\spxentry{big oh}}\index{dictionary@\spxentry{dictionary}!big oh@\spxentry{big oh}}\index{linear order@\spxentry{linear order}}\index{constant order@\spxentry{constant order}}\ignorespaces 

\section{Dictionary Efficiency}
\label{\detokenize{dictionaries/dictionaryefficiency:dictionary-efficiency}}\label{\detokenize{dictionaries/dictionaryefficiency:index-0}}\label{\detokenize{dictionaries/dictionaryefficiency:id1}}\label{\detokenize{dictionaries/dictionaryefficiency::doc}}
\sphinxAtStartPar
We could simulate the effect of a Dictionary pretty easily by keeping
a List \sphinxcode{\sphinxupquote{keys}} and a List \sphinxcode{\sphinxupquote{values}}, in the same order.  We could
find the entry with a specified key with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{keys}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{values}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Searching though a \sphinxcode{\sphinxupquote{List}}, however, take time proportional to the
length of the \sphinxcode{\sphinxupquote{List}} in general, \sphinxstyleemphasis{linear order}.  Through a clever implementation
covered in data structures classes, a \sphinxcode{\sphinxupquote{Dictionary}} uses a \sphinxstyleemphasis{hash table}
to make the average lookup time of \sphinxstyleemphasis{constant order}.  A hash table depends on the
keys being immutable.

\sphinxstepscope


\section{Dictionary Examples}
\label{\detokenize{dictionaries/dictionaryexamples:dictionary-examples}}\label{\detokenize{dictionaries/dictionaryexamples::doc}}
\index{generics@\spxentry{generics}!HashSet@\spxentry{HashSet}}\index{HashSet@\spxentry{HashSet}}\index{set@\spxentry{set}}\index{type@\spxentry{type}!HashSet@\spxentry{HashSet}}\ignorespaces 

\subsection{Sets}
\label{\detokenize{dictionaries/dictionaryexamples:sets}}\label{\detokenize{dictionaries/dictionaryexamples:index-0}}\label{\detokenize{dictionaries/dictionaryexamples:id1}}
\sphinxAtStartPar
In the next section we will have an example making central use of a dictionary.
It will also make use of a set.  The generic C\# version is
a \sphinxcode{\sphinxupquote{HashSet}}, which models a mathematical set:  a collection
with no repetitions and no defined order.  We use a \sphinxcode{\sphinxupquote{HashSet}} for the
words to be ignored.  We use a \sphinxcode{\sphinxupquote{HashSet}} rather than a \sphinxcode{\sphinxupquote{List}} because
the \sphinxcode{\sphinxupquote{Contains}} method for a \sphinxcode{\sphinxupquote{List}} has linear order, while the \sphinxcode{\sphinxupquote{Contains}} method for
a \sphinxcode{\sphinxupquote{HashSet}} uses the same trick as in a \sphinxcode{\sphinxupquote{Dictionary}} to be of constant order on average.

\sphinxAtStartPar
Here is a csharp session using the type \sphinxcode{\sphinxupquote{HashSet}} of strings. The \sphinxcode{\sphinxupquote{Add}} method, like
the \sphinxcode{\sphinxupquote{Remove}} method for Lists, returns true or false depending on whether the method
changes the set:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} var set = new HashSet\PYGZlt{}string\PYGZgt{}();
csharp\PYGZgt{} set;
\PYGZob{}  \PYGZcb{}
csharp\PYGZgt{} set.Add(\PYGZdq{}hi\PYGZdq{});
true
csharp\PYGZgt{} set;
\PYGZob{} \PYGZdq{}hi\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} set.Add(\PYGZdq{}up\PYGZdq{});
true
csharp\PYGZgt{} set;
\PYGZob{} \PYGZdq{}hi\PYGZdq{}, \PYGZdq{}up\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} set.Add(\PYGZdq{}hi\PYGZdq{});  // already there
false
csharp\PYGZgt{} set;
\PYGZob{} \PYGZdq{}hi\PYGZdq{}, \PYGZdq{}up\PYGZdq{} \PYGZcb{}
csharp\PYGZgt{} set.Contains(\PYGZdq{}hi\PYGZdq{});
true
csharp\PYGZgt{} set.Contains(\PYGZdq{}down\PYGZdq{});
false
csharp\PYGZgt{} var set2 = new HashSet\PYGZlt{}string\PYGZgt{}(new string[]\PYGZob{}\PYGZdq{}a\PYGZdq{}, \PYGZdq{}be\PYGZdq{}, \PYGZdq{}see\PYGZdq{}\PYGZcb{});
csharp\PYGZgt{} set2;
\PYGZob{} \PYGZdq{}a\PYGZdq{}, \PYGZdq{}be\PYGZdq{}, \PYGZdq{}see\PYGZdq{} \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
That lack of order for a \sphinxcode{\sphinxupquote{HashSet}} means it cannot
be indexed, but otherwise it has mostly the same methods and constructors
that have been discussed for a \sphinxcode{\sphinxupquote{List}}, including \sphinxcode{\sphinxupquote{Add}} and \sphinxcode{\sphinxupquote{Contains}} and
a constructor that takes a collection as parameter.

\index{example@\spxentry{example}!Word Count@\spxentry{Word Count}}\index{Word Count example@\spxentry{Word Count example}}\index{HashSet@\spxentry{HashSet}!example@\spxentry{example}}\index{List@\spxentry{List}!example@\spxentry{example}}\ignorespaces 

\subsection{Word Count Example}
\label{\detokenize{dictionaries/dictionaryexamples:word-count-example}}\label{\detokenize{dictionaries/dictionaryexamples:index-1}}
\sphinxAtStartPar
Counting the number of repetitions of words in a text provides a realistic
example of using a \sphinxcode{\sphinxupquote{Dictionary}}.  With each word that you find, you want to associate
a number of repetitions.  A complete program is in the example file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/count\_words/count\_words.cs}{count\_words/count\_words.cs}.

\sphinxAtStartPar
The central functions are excerpted below, and they also introduce some extra
features from the .Net libraries.

\sphinxAtStartPar
This constructor pattern taking the elements of one collection and creating another
collection, possibly of another type, is used twice: first
to create a \sphinxcode{\sphinxupquote{HashSet}} from an array, and later to create a \sphinxcode{\sphinxupquote{List}} from a \sphinxcode{\sphinxupquote{HashSet}}.
The latter is needed so the \sphinxcode{\sphinxupquote{List}} can be sorted in alphabetical order with its
\sphinxcode{\sphinxupquote{Sort}} method, used here for the first time.  Our table contains the words in
alphabetical order.

\sphinxAtStartPar
Also used for the first time are two string methods: the pretty clearly named \sphinxcode{\sphinxupquote{ToCharArray}} and
another variation on \sphinxcode{\sphinxupquote{Split}}.  An alternative to supplying a single character to split on,
is to use a \sphinxcode{\sphinxupquote{char}} array as parameter, and the string is split at an occurrence of any of the
characters in the array.  This allows a split on all punctuation and special symbol characters,
as well as a blank.

\sphinxAtStartPar
We separate the processing into two functions, one calculating the dictionary, and one printing
a table.  To reduce the amount of clutter in the \sphinxcode{\sphinxupquote{Dictionary}}, the function
\sphinxcode{\sphinxupquote{GetCounts}} takes as a parameter a set of words to ignore.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a Dictionary of word:count pairs from parsing s,}
\PYG{+w}{      }\PYG{c+c1}{///  excluding all strings in ignore.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{GetCounts}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{HashSet}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ignore}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{char}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{sep}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZbs{}n\PYGZbs{}t !@\PYGZsh{}\PYGZdl{}\PYGZpc{}\PYGZca{}\PYGZam{}*()\PYGZus{}+\PYGZob{}\PYGZcb{}|[]\PYGZbs{}\PYGZbs{}:\PYGZbs{}\PYGZdq{};\PYGZlt{}\PYGZgt{}?,./\PYGZdq{}}\PYG{p}{.}\PYG{n}{ToCharArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Split}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{ignore}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//generated from consecutive splitting characters}
\PYG{+w}{         }\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{wc}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{ignore}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{wc}\PYG{p}{.}\PYG{n}{ContainsKey}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{//increase count of word already seen}
\PYG{+w}{                  }\PYG{n}{wc}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{               }\PYG{p}{\PYGZcb{}}
\PYG{+w}{               }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{                   }\PYG{c+c1}{// make a first entry}
\PYG{+w}{                  }\PYG{n}{wc}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{               }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{wc}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Print each word and its count, if the count is at least minCount.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintCounts}\PYG{p}{(}\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{wc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{minCount}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{wc}\PYG{p}{.}\PYG{n}{Keys}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{words}\PYG{p}{.}\PYG{n}{Sort}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{wc}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{n}{minCount}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{}: \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{wc}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Look at the code carefully, and look at the whole program that analyses the
Gettysburg Address.

\sphinxstepscope


\section{Lab: File Data and Collections}
\label{\detokenize{dictionaries/lab-filedata:lab-file-data-and-collections}}\label{\detokenize{dictionaries/lab-filedata::doc}}

\subsection{Goals for this lab:}
\label{\detokenize{dictionaries/lab-filedata:goals-for-this-lab}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Read a text file.

\item {} 
\sphinxAtStartPar
Work with loops.

\item {} 
\sphinxAtStartPar
Work with a Dictionary and a List.

\item {} 
\sphinxAtStartPar
Retrieve a random entry.

\end{itemize}


\subsubsection{Overview}
\label{\detokenize{dictionaries/lab-filedata:overview}}
\sphinxAtStartPar
Copy project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub}{dict\_lab\_stub} to your own project.
Note that there are data files in the project directory.
Make sure your project,
like this stub, sets the Output Path to the project folder.

\sphinxAtStartPar
This lab provides a replacement file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/fake\_help.cs}{fake\_help.cs} for an improved
project.  The project still needs some additions in a helper class.

\sphinxAtStartPar
Before we get there, open the comparison program
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/fake\_help\_verbose/fake\_help\_verbose.cs}{fake\_help\_verbose/fake\_help\_verbose.cs} and
look at the methods \sphinxcode{\sphinxupquote{GetParagraphs()}} and \sphinxcode{\sphinxupquote{GetDictionary()}}.
All the strings for the responses are pre\sphinxhyphen{}coded for you there, but if
you were writing your own methods, it would be a pain. There is all the
repetitious code to make multiline strings and then to add to the
List and Dictionary. This lab will provide simple versatile methods to
fill a \sphinxcode{\sphinxupquote{List\textless{}string\textgreater{}}} or a \sphinxcode{\sphinxupquote{Dictionary\textless{}string, string\textgreater{}}}: You only need
you to write the string data itself into a text file, with the only
overhead being a few extra newlines. Minor further adaptations could
save time later in a project, too.

\sphinxAtStartPar
Look in your copy of
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/fake\_help.cs}{fake\_help.cs}.
It creates the \sphinxcode{\sphinxupquote{List}} \sphinxcode{\sphinxupquote{guessList}} and the
\sphinxcode{\sphinxupquote{Dictionary}} \sphinxcode{\sphinxupquote{responses}} using more general functions that you need to fill in.
The stubs for these new versions are put in
the class \sphinxcode{\sphinxupquote{FileUtil}} for easy reuse.  \sphinxcode{\sphinxupquote{Main}} calls these functions
and chooses the files to read.
The results will look the same as the original program to the user,
but the second version will be easier
for a programmer to read and generalize:  It will be easier in other situations
where you want lots of canned data
in your program (like in a game you might write soon).

\sphinxAtStartPar
The stub should run as is
(mostly saying things are not implemented).
Test out your work at every stage!

\sphinxAtStartPar
You will need to complete very short versions of functions
\sphinxcode{\sphinxupquote{GetParagraphs}} and \sphinxcode{\sphinxupquote{GetDictionary}} that have been moved to
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/file\_util.cs}{file\_util.cs}
and now
take a \sphinxcode{\sphinxupquote{StreamReader}} as parameter.
The files that they read will contain the basic data.
You can look in the lab project at the first data file:
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_defaults.txt}{help\_not\_defaults.txt},
and the beginning is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Welcome to We\PYGZhy{}Give\PYGZhy{}Answers!
What do you have to say?

We\PYGZhy{}Give\PYGZhy{}Answers 
thanks you for your patronage.
Call again if we can help you 
with any other problem!

No other customer has ever complained 
about this before.  What is your system 
configuration?

That sounds odd. Could you describe 
that problem in more detail?

\end{sphinxVerbatim}

\sphinxAtStartPar
You can see that it includes the data for the welcome
and goodbye strings followed by all the data to go in the \sphinxcode{\sphinxupquote{List}} of random answers.

\sphinxAtStartPar
One complication is that many of these strings take up several lines, in what we call
a \sphinxstyleemphasis{paragraph}.  We follow a standard convention for putting paragraphs into plain text:
Put a blank line after a paragraph to mark its end.  As you can see, that is how
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_defaults.txt}{help\_not\_defaults.txt} is set up.


\subsection{Steps}
\label{\detokenize{dictionaries/lab-filedata:steps}}
\sphinxAtStartPar
All of the additions you need to make are in bodies of function
definitions in the class \sphinxcode{\sphinxupquote{FileUtil}}.  Look back to \sphinxcode{\sphinxupquote{Main}} in \sphinxcode{\sphinxupquote{FakeAdvise}} to
see how the functions from \sphinxcode{\sphinxupquote{FileUtil}} are actually used:  The
\sphinxcode{\sphinxupquote{StreamReader}} is set up to read from the right file.  The the \sphinxcode{\sphinxupquote{FileUtil}} functions
\sphinxcode{\sphinxupquote{ReadParagraph}}, \sphinxcode{\sphinxupquote{GetParagraphs}}, and \sphinxcode{\sphinxupquote{GetDictionary}} are used to provide
the text data needed.


\subsubsection{ReadParagraph}
\label{\detokenize{dictionaries/lab-filedata:readparagraph}}
\sphinxAtStartPar
The first method to complete in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/file\_util.cs}{file\_util.cs}
is useful by itself and later for use in the
\sphinxcode{\sphinxupquote{GetParagraphs}} and \sphinxcode{\sphinxupquote{GetDictionary}} that you will complete.  See the stub:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a string consisting of a sequence of nonempty lines read}
\PYG{c+c1}{/// from reader. All the newlines at the ends of these lines are included.}
\PYG{c+c1}{/// The function ends after reading (but not including) an empty line.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ReadParagraph}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first call to \sphinxcode{\sphinxupquote{ReadParagraph}}, using the file illustrated above, should
return the following (showing the escape codes for the newlines):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}Welcome to We\PYGZhy{}Give\PYGZhy{}Answers!\PYGZbs{}nWhat do you have to say?\PYGZbs{}n\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and then the reader should be set to read the goodbye paragraph
(the next time \sphinxcode{\sphinxupquote{ReadParagraph}} is called).

\sphinxAtStartPar
To code, you can read lines one at a time, and append them to the part of the
paragraph read so far. There is one thing to watch out for: The
\sphinxcode{\sphinxupquote{ReadLine}} function \sphinxstyleemphasis{throws away} the following newline (\sphinxcode{\sphinxupquote{"\textbackslash{}n"}}) in the input. You
need to preserve it, so be sure to explicitly add a newline, back onto
your paragraph string after each nonempty line is added. The returned
paragraph should end with a single newline.

\sphinxAtStartPar
Throw away the empty line
in the input after the paragraph. Make sure you stop after reading
the empty line.  It is very important that you advance the reader
to the right place, to be ready to read the next paragraph.

\sphinxAtStartPar
Be careful of a pitfall with files:  You can only read a given chunk once:
If you read again, with the exact same syntax,
you get the \sphinxstyleemphasis{next} line of the file.  The \sphinxcode{\sphinxupquote{ReadLine}} method
has the \sphinxstyleemphasis{side effect} of advancing the reading position in the file.

\sphinxAtStartPar
\sphinxstylestrong{Testing}: This first short \sphinxcode{\sphinxupquote{ReadParagraph}} function should actually be most of
the code that you write for the lab!  The program is set up so you can immediately
run the program and test \sphinxcode{\sphinxupquote{ReadParagraph}}:  It is called to read in the welcome string
and the goodbye string for the program, so if those come correctly to the screen, you
can advance to the next two parts.


\subsubsection{GetParagraphs}
\label{\detokenize{dictionaries/lab-filedata:getparagraphs}}
\sphinxAtStartPar
Since you have \sphinxcode{\sphinxupquote{ReadParagraph}} at your disposal, you now only need to
insert a \sphinxstyleemphasis{few remaining lines of code} to complete the next method
\sphinxcode{\sphinxupquote{GetParagraphs}}, that reads to the end of the file, and likely
processes more than one paragraph.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Read the remaining empty\PYGZhy{}line terminated paragraphs}
\PYG{+w}{      }\PYG{c+c1}{/// from reader into a new list of paragraph strings,}
\PYG{+w}{      }\PYG{c+c1}{/// and return the list.}
\PYG{+w}{      }\PYG{c+c1}{/// The function reads all the way to the end of}
\PYG{+w}{      }\PYG{c+c1}{/// the file attached to reader.}
\PYG{+w}{      }\PYG{c+c1}{/// The file must end with two newlines in sequence: one at the}
\PYG{+w}{      }\PYG{c+c1}{/// end of the last nonempty line followed by one for the empty line.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{GetParagraphs}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{all}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{c+c1}{// REPLACE the next line with your lines of code to fill all}
\PYG{+w}{         }\PYG{n}{all}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}You have not coded GetParagraphs yet!\PYGZbs{}n\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{all}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Look again at
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_defaults.txt}{help\_not\_defaults.txt},
to see how the data is set up.

\sphinxAtStartPar
This lab requires very few lines of code. Be sure to read the examples
and instructions carefully (several times). A lot of ideas get packed
into the few lines!

\sphinxAtStartPar
\sphinxstylestrong{Testing}: After writing \sphinxcode{\sphinxupquote{GetParagraphs}}, the random
responses in the lab project program should work as the user enters lines in the program.


\subsubsection{GetDictionary}
\label{\detokenize{dictionaries/lab-filedata:getdictionary}}
\sphinxAtStartPar
The last stub to complete in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/file\_util.cs}{file\_util.cs}
is \sphinxcode{\sphinxupquote{GetDictionary}}.  Its
stub also takes a \sphinxcode{\sphinxupquote{StreamReader}} as parameter.  In
\sphinxcode{\sphinxupquote{Main}} this function is called to read from
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_responses.txt}{help\_not\_responses.txt}.
Here are the first few lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
crash
Well, it never crashes on our system. 
It must have something to do with your system. 
Tell me more about your configuration.

slow
I think this has to do with your hardware. 
Upgrading your processor should solve all 
performance problems. 
Have you got a problem with our software?

performance
Performance was quite adequate in all our tests. 
Are you running any other processes in the background?

\end{sphinxVerbatim}

\sphinxAtStartPar
Here is the stub of the function to complete, reading such data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a new Dictionary, taking data for it from reader.}
\PYG{c+c1}{/// Reader contains key\PYGZhy{}value pairs, where each single\PYGZhy{}line key is}
\PYG{c+c1}{/// followed by a possibly multi\PYGZhy{}line paragraph value that is terminated}
\PYG{c+c1}{/// by an empty line. The file must end with two newlines in sequence:}
\PYG{c+c1}{/// one at the end of the last nonempty line followed by one for the}
\PYG{c+c1}{/// empty line.}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{GetDictionary}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{   }\PYG{c+c1}{// add your lines of code to fill d here!}

\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Testing}:
When you complete this function, the program should behave
just like the earlier
verbose version with the hard\sphinxhyphen{}coded data, using a dictionary value
if it finds the right key,
or choosing a random response if there is no key match.

\sphinxAtStartPar
Be careful to distinguish the data file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_responses.txt}{help\_not\_responses.txt}
from
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_responses2.txt}{help\_not\_responses2.txt},
used in the extra credit option.

\sphinxAtStartPar
This should also be an extremely short amount of coding!
Think of following through the data file, and get the corresponding
sequence of instructions to handle the data in the exact same sequence.

\sphinxAtStartPar
Show the program output to a TA (after the extra credit if you like).


\subsubsection{Extra credit}
\label{\detokenize{dictionaries/lab-filedata:extra-credit}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
(20\%) Modify ReadParagragh so it \sphinxstyleemphasis{also} works if the paragraph ends
at the end of the file, with no blank line after it, or if the line after
the paragraph only has whitespace characters.  Both changes are good to
bullet\sphinxhyphen{}proof the code, since
the added or removed whitespace is hard to see in print.

\item {} 
\sphinxAtStartPar
(20\%) The crude word classification scheme would recognize “crash”, but not
“crashed” or “crashes”.  You could make whole file entries
for each key variation, repeating the value paragraph.
A concise approach is to use a data file
like \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/dict\_lab\_stub/help\_not\_responses2.txt}{help\_not\_responses2.txt}.
Here are the first few lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
crash crashes crashed
Well, it never crashes on our system. 
It must have something to do with your system. 
Tell me more about your configuration.

slow slowly
I think this has to do with your hardware. 
Upgrading your processor should solve all 
performance problems. 
Have you got a problem with our software?

performance
Performance was quite adequate in all our tests. 
Are you running any other processes in the background?

\end{sphinxVerbatim}

\sphinxAtStartPar
The line that used to have one key now may have several blank\sphinxhyphen{}separated keys.

\sphinxAtStartPar
Here is how the documentation for \sphinxcode{\sphinxupquote{GetDictionary}} should be changed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// Return a new Dictionary, taking data for it from reader.}
\PYG{c+c1}{/// Reader generates key\PYGZhy{}value pairs, where one or more space}
\PYG{c+c1}{/// separated keys on a line are followed by a possibly multi\PYGZhy{}line}
\PYG{c+c1}{/// paragraph value that is terminated by an empty line.  Each}
\PYG{c+c1}{/// key on the line is mapped to the same paragraph that follows.}
\PYG{c+c1}{/// The file must end with two newlines in sequence:  one at the end}
\PYG{c+c1}{/// of the last nonempty line followed by one for the empty line.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Modify the lab project to use this file effectively:  Find
“help\_not\_responses.txt” on line 22 in \sphinxcode{\sphinxupquote{Main}}.  Change it to
“help\_not\_responses2.txt” (inserting ‘2’), so \sphinxcode{\sphinxupquote{Main}} reads it.

\sphinxAtStartPar
In your test of the program, be sure to use several of the keys that apply to the
same response, and show to your TA.

\end{enumerate}

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{dictionaries/reviewdictionaries:chapter-review-questions}}\label{\detokenize{dictionaries/reviewdictionaries::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Which is true for a \sphinxcode{\sphinxupquote{Dictionary}}: is it mutable or immutable?

\item {} 
\sphinxAtStartPar
Though for some collections, like arrays and lists,
you can fairly easily replace a \sphinxcode{\sphinxupquote{foreach}}
loop with a \sphinxcode{\sphinxupquote{for}} loop, that is not the case if you want to iterate
through a \sphinxcode{\sphinxupquote{Dictionary}}.  How do you go through all the keys in
a \sphinxcode{\sphinxupquote{Dictionary}}?

\item {} 
\sphinxAtStartPar
What syntax is there for a \sphinxcode{\sphinxupquote{Dictionary}} that matches that for a \sphinxcode{\sphinxupquote{List}}?

\item {} 
\sphinxAtStartPar
How is a \sphinxcode{\sphinxupquote{Dictionary}} like an array?  How is it different?

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dictionary}} values are of arbitrary type. What is the restriction on
key types?

\item {} 
\sphinxAtStartPar
How is a \sphinxcode{\sphinxupquote{HashSet}} different than a \sphinxcode{\sphinxupquote{List}}?

\item {} 
\sphinxAtStartPar
What syntax is shared between a \sphinxcode{\sphinxupquote{List}} and a \sphinxcode{\sphinxupquote{HashSet}}?

\item {} 
\sphinxAtStartPar
Which is more efficient in general:
searching for an element of a list or finding the
value given a key in a dictionary?

\end{enumerate}

\sphinxstepscope

\index{class@\spxentry{class}}\index{type@\spxentry{type}!user defined object@\spxentry{user defined object}}\ignorespaces 

\chapter{Classes and Object\sphinxhyphen{}Oriented Programming}
\label{\detokenize{classes/classes:classes-and-object-oriented-programming}}\label{\detokenize{classes/classes:classes}}\label{\detokenize{classes/classes:index-0}}\label{\detokenize{classes/classes::doc}}
\sphinxstepscope

\index{class@\spxentry{class}!Contact@\spxentry{Contact}}\index{Contact class@\spxentry{Contact class}}\index{instance of a class@\spxentry{instance of a class}}\ignorespaces 

\section{A First Example of Class Instances: Contact}
\label{\detokenize{classes/a-first-class:a-first-example-of-class-instances-contact}}\label{\detokenize{classes/a-first-class:class}}\label{\detokenize{classes/a-first-class:index-0}}\label{\detokenize{classes/a-first-class::doc}}

\subsection{Making a Datatype}
\label{\detokenize{classes/a-first-class:making-a-datatype}}
\sphinxAtStartPar
C\# comes with lots of built\sphinxhyphen{}in datatypes, but not
everything we might want to use.  We start with a very simple example of
building your own new type of object:  Contact information for a person
involves several pieces of data, and they are all unified by the fact
that they are for one person, so we would like to store them together
as a unit.  For simplicity, let us just consider the contact information to be
name, phone number, and email address.

\sphinxAtStartPar
You could always keep three independent string variables,
but conceptually the main idea is \sphinxstyleemphasis{the} contact.  It just happens
to have parts.

\sphinxAtStartPar
In order to treat a contact as  \sphinxstyleemphasis{one} entity, we create a \sphinxcode{\sphinxupquote{class}},
\sphinxcode{\sphinxupquote{Contact}}.
This way we can have a single
variable refer to a \sphinxcode{\sphinxupquote{Contact}} object.  Such an object is an \sphinxstyleemphasis{instance} of the
class.

\sphinxAtStartPar
It is important to distinguish between a class and an instance of a class:
A class provides a template or instructions to make new instance objects.  A
common comparison is that a class is like a cookie cutter while an
instance of the class is like a cookie.
You might consider constructor parameters as being for different decorations
on different cookies, so not all cookies must end up completely the same.

\sphinxAtStartPar
Later we will see an example for rational
numbers, {\hyperref[\detokenize{classes/rational:rational}]{\sphinxcrossref{\DUrole{std,std-ref}{The Rational Class}}}},
where the parts of the class are more tightly integrated, but that is more
complicated, so we defer it.

\sphinxAtStartPar
We have already considered built\sphinxhyphen{}in types with internal state, like a \sphinxcode{\sphinxupquote{List}}:
Each \sphinxcode{\sphinxupquote{List}} can contain different data, and the internal data can be changed.

\sphinxAtStartPar
The idea of creating a new type of object opens new ground for managing data.
Thus far we have stored data as local variables, and we have called functions,
with two ways to get information in and out of functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In through parameters and out through returned data.

\item {} 
\sphinxAtStartPar
Directly via the user: in through the keyboard and out to the screen.

\end{enumerate}

\sphinxAtStartPar
We have stored and passed around built\sphinxhyphen{}in types of object using this model.

\sphinxAtStartPar
We have alternatives for storing and accessing data in the methods within
a new class that we write.
Now we have the idea of an object that has \sphinxstyleemphasis{internal} state
(like a contact with a name, phone, and email).  We shall see that
this state is \sphinxstyleemphasis{not}
stored in local variables and does \sphinxstyleemphasis{not} need to be passed through parameters for
methods \sphinxstyleemphasis{within} the class.
Pay careful attention as we introduce this new location for data and the new ways
of interacting with it.

\sphinxAtStartPar
This is quite a shift.
\sphinxstyleemphasis{Do not take it lightly.}

\index{OOP@\spxentry{OOP}!constructor@\spxentry{constructor}}\index{constructor@\spxentry{constructor}}\index{new as operator@\spxentry{new as operator}}\index{operator@\spxentry{operator}!new@\spxentry{new}}\ignorespaces 
\sphinxAtStartPar
We can create a new object with the \sphinxcode{\sphinxupquote{new}} syntax.
We can give parameters defining the initial state of the new object.
In our example the obvious thing to do is supply parameters giving
values for the three parts of the object state, so we can plan that

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie Ortiz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}7890\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}mortiz2@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would create a new Contact storing the data.  A Contact object, created with
\sphinxcode{\sphinxupquote{new}} is an \sphinxstyleemphasis{instance} of the class Contact.

\sphinxAtStartPar
Like with built\sphinxhyphen{}in types, we can have the natural operations on the
type as \sphinxstyleemphasis{methods}.  For instance we can
\begin{itemize}
\item {} 
\sphinxAtStartPar
look up individual pieces of the contact data with methods
\sphinxcode{\sphinxupquote{GetName}}, \sphinxcode{\sphinxupquote{GetPhone}} and \sphinxcode{\sphinxupquote{GetEmail}}

\item {} 
\sphinxAtStartPar
print it all out together, labeled, with method \sphinxcode{\sphinxupquote{Print}}.

\end{itemize}

\sphinxAtStartPar
Thinking ahead to what we would like for our Contact objects, here is
the testing code of \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/contact1/test\_contact1.cs}{contact1/test\_contact1.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{TestContact}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie Ortiz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}7890\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                                  }\PYG{l+s}{\PYGZdq{}mortiz2@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Otto Heinz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}9999\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                                  }\PYG{l+s}{\PYGZdq{}oheinz@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie\PYGZsq{}s full name: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Her phone number: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetPhone}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Her email: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetEmail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZbs{}nFull contact info for Otto:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{c2}\PYG{p}{.}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When running this testing code, we would like the results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Marie\PYGZsq{}s full name: Marie Ortiz
Her phone number: 773\PYGZhy{}508\PYGZhy{}7890
Her email: mortiz2@luc.edu

Full contact info for Otto:
Name:  Otto Heinz
Phone: 773\PYGZhy{}508\PYGZhy{}9999
Email: oheinz@luc.edu
\end{sphinxVerbatim}

\sphinxAtStartPar
We are using the same object oriented notation that we have for many other classes:
\sphinxstyleemphasis{Calls to instance methods are always attached to a specific object.}
That has always been
the part through the \sphinxcode{\sphinxupquote{.}} of
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{object}\sphinxcode{\sphinxupquote{.}}\sphinxstyleemphasis{method}\sphinxcode{\sphinxupquote{(}}  … \sphinxcode{\sphinxupquote{)}}
\end{quote}

\sphinxAtStartPar
So far we have been thinking and illustrating how we would like objects in this
Contact class to look like and behave from the \sphinxstyleemphasis{outside}.  We could be
describing another library class.  Now, for the first time,
we start to delve inside,
to the code and concepts needed to make this happen.
We start with the most basic parts.  First we need a \sphinxcode{\sphinxupquote{class}}:


\subsection{Class Syntax}
\label{\detokenize{classes/a-first-class:class-syntax}}
\sphinxAtStartPar
Our code is nested inside

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Contact}
\PYG{p}{\PYGZob{}}

\PYG{+w}{   }\PYG{c+c1}{// ... fields, constructor, code for Contact omitted}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the same sort of wrapper we have used for our Main programs!
\sphinxstyleemphasis{Before}, everything inside was
labeled \sphinxcode{\sphinxupquote{static}}.  Now we see what happens with the \sphinxcode{\sphinxupquote{static}} keyword
\sphinxstyleemphasis{omitted}….

\index{OOP@\spxentry{OOP}!instance variable@\spxentry{instance variable}}\index{instance variable@\spxentry{instance variable}}\index{variable@\spxentry{variable}!instance@\spxentry{instance}}\index{private@\spxentry{private}!instance variable@\spxentry{instance variable}}\ignorespaces 

\subsection{Instance Variables}
\label{\detokenize{classes/a-first-class:instance-variables}}\label{\detokenize{classes/a-first-class:index-2}}
\sphinxAtStartPar
A Contact has a name, phone number and email address.  We must remember that data.
Each individual Contact that we use will have its own
name, phone number and email address.

\sphinxAtStartPar
We have used some static variables before in classes, with the keyword \sphinxcode{\sphinxupquote{static}},
where there is just one copy for the whole class.  If we omit the \sphinxcode{\sphinxupquote{static}} we get
an \sphinxstyleemphasis{instance variable}, that is the particular data for an \sphinxstyleemphasis{individual} Contact,
for an individual instance of the class.
This is our new place to store data:

\sphinxAtStartPar
We declare these \sphinxstyleemphasis{in} the class and \sphinxstyleemphasis{outside} any method declaration.
(This is in the same place as we would store {\hyperref[\detokenize{functions/staticvariables:static-variables}]{\sphinxcrossref{\DUrole{std,std-ref}{Static Variables}}}}).

\sphinxAtStartPar
They are \sphinxstyleemphasis{fields} of the class.  As we will
discuss more in terms of safety and security,
we add the word “private” at the beginning:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Contact}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{;}

\PYG{+w}{   }\PYG{c+c1}{// ... constructor, code for Contact omitted}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You also see that we are lazy in this example,
and abbreviate the longer descriptions fullName, phoneNumber and
emailAddress.

\index{lifetime@\spxentry{lifetime}}\ignorespaces 
\sphinxAtStartPar
It is important to distinguish \sphinxstyleemphasis{instance} variables of a class
and \sphinxstyleemphasis{local} variables.
A local variable is only accessible inside the block (surrounded by braces)
where it was declared,
and is destroyed at the end of the execution of that block.
However the class fields  \sphinxcode{\sphinxupquote{name}}, \sphinxcode{\sphinxupquote{phone}} and \sphinxcode{\sphinxupquote{email}} are remembered by C\#
as long as the Contact object is in use.

\sphinxAtStartPar
The \sphinxstyleemphasis{lifetime} of a variable is from when it is first created until it is no
longer accessible by the program.  We repeat:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstyleemphasis{Instance} variable have a completely different lifetime and scope
from \sphinxstyleemphasis{local} variables.
An object and its instance variables,
persist from the time a new object is created
with \sphinxcode{\sphinxupquote{new}} for as long as the object
remains referenced in the program.
\end{sphinxadmonition}

\sphinxAtStartPar
We need to get values into our field variables.
They describe the state of our Contact.

\sphinxAtStartPar
We have \sphinxstyleemphasis{used} constructors for built\sphinxhyphen{}in types.
Now for the first time we \sphinxstyleemphasis{create} one.

\index{OOP@\spxentry{OOP}!constructor@\spxentry{constructor}}\index{constructor@\spxentry{constructor}}\ignorespaces 

\subsection{Constructors}
\label{\detokenize{classes/a-first-class:constructors}}\label{\detokenize{classes/a-first-class:index-4}}
\sphinxAtStartPar
The constructor is a slight variation on a regular method:
Its name is the same as the
kind of object constructed, so here it is the class name, Contact.
It has \sphinxstyleemphasis{no return type} (and \sphinxstyleemphasis{no} \sphinxcode{\sphinxupquote{static}}).  Implicitly you
are creating the kind of object named, a \sphinxstylestrong{Contact} in this case.
The constructor can have parameters like a regular method.  We will certainly
want to give a state to our new object.
That means giving values to its fields.  Recall we are want to
store this state in instance variables \sphinxcode{\sphinxupquote{name}}, \sphinxcode{\sphinxupquote{phone}} and \sphinxcode{\sphinxupquote{email}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Contact}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{phone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{email}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
While the local variables in the formal parameters
disappear after the constructor terminates,
we want the data to live on as the state of the object.
In order to remember state after the constructor terminates,
we must \sphinxstyleemphasis{make sure the information gets into the instance variables}
for the object.
This is the basic operation of most constructors:  Copy desired formal
parameters in to initialize the state in the fields.  That is all our simple
code above does.

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{name}}, \sphinxcode{\sphinxupquote{phone}} and \sphinxcode{\sphinxupquote{email}} are \sphinxstyleemphasis{not} declared as
local variables.  They refer to the \sphinxstyleemphasis{instance} variables, but we are \sphinxstyleemphasis{not} using
full object notation: an object reference and a
dot, followed by the field.

\sphinxAtStartPar
So far always we have always been referring to a built\sphinxhyphen{}in type of object
defined in a different class, like \sphinxcode{\sphinxupquote{arrayObject.Length}}.
The constructor is \sphinxstyleemphasis{creating} an object,
and the use of the bare instance variable names is understood to be giving
values to the instance variables in this Contact object
that is being constructed.
Inside a constructor
and also inside an instance method
(discussed below)
C\# allows this shorthand notation without \sphinxcode{\sphinxupquote{someObject.}}.

\index{OOP@\spxentry{OOP}!instance method@\spxentry{instance method}}\index{instance method@\spxentry{instance method}}\index{method@\spxentry{method}}\ignorespaces 

\subsection{Instance Methods}
\label{\detokenize{classes/a-first-class:instance-methods}}\label{\detokenize{classes/a-first-class:index-5}}\label{\detokenize{classes/a-first-class:id1}}
\sphinxAtStartPar
The instance variable names and method names
used without an object reference and dot refer to the
\sphinxstyleemphasis{current} instance.  Whenever a constructor or non\sphinxhyphen{}static method in the class is called,
there is \sphinxstyleemphasis{always} a current object:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In a constructor, referring to the object being created.  In execution,
a static method like \sphinxcode{\sphinxupquote{Main}} must create the first object.

\item {} 
\sphinxAtStartPar
When some instance method \sphinxcode{\sphinxupquote{methodName}} is called with explicit dot notation,
\sphinxcode{\sphinxupquote{someObject.methodName()}},
then it is acting on the current object \sphinxcode{\sphinxupquote{someObject}}.  In any program’s
execution the first call to an instance method must either be in this explicit
form or from within a constructor for a new object.

\item {} 
\sphinxAtStartPar
If that constructor or instance method calls a
further instance method inside the same class, without using dot notation,
then the further method has the \sphinxstyleemphasis{same} current object….
We will see examples of this as we go along.

\end{enumerate}

\sphinxAtStartPar
Again, this means that in execution, whenever an instance method is called,
there \sphinxstyleemphasis{is} a \sphinxstyleemphasis{current specific object}.  This is the object associated
with any instance variable or method referred to in that method,
if there is not an explicit prefix in the \sphinxcode{\sphinxupquote{someObject.}} form.  This will
take practice to get used to.

\index{OOP@\spxentry{OOP}!getter@\spxentry{getter}}\index{getter method@\spxentry{getter method}}\ignorespaces 

\subsection{Getters}
\label{\detokenize{classes/a-first-class:getters}}\label{\detokenize{classes/a-first-class:index-6}}\label{\detokenize{classes/a-first-class:id2}}
\sphinxAtStartPar
In instance methods
you have an extra way of getting
data in and out of the method:  Reading or setting instance variables.
(As we have just pointed out, in execution there will always be a current object
with its specific state.)
The simplest methods do nothing but reading or setting instance variables.
We start with those:

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{private}} in front
of the field declarations was important to keep code outside the
class from messing with the values.  On the other hand we do want
others to be able to \sphinxstyleemphasis{inspect} the name, phone and email,
so how do we do that?  Use \sphinxstylestrong{public methods}.

\sphinxAtStartPar
Since the fields are accessible anywhere \sphinxstyleemphasis{inside} the class’s instance methods,
and public methods can be used from \sphinxstyleemphasis{outside} the class, we can simply code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetName}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetPhone}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetEmail}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
These methods allow one\sphinxhyphen{}way communication of the name, phone and email
values out from the object.
These are examples
of a simple category of methods:  A \sphinxstyleemphasis{getter} simply returns the value of a part
of the object’s state, without changing the object at all.

\sphinxAtStartPar
Note again that there is no \sphinxcode{\sphinxupquote{static}} in the method heading.
The field value for the \sphinxstyleemphasis{current} Contact is returned.

\sphinxAtStartPar
A standard convention that we are following:
Have getter methods names start with “Get”,
followed by the name of the data to be returned.

\sphinxAtStartPar
In this first simple version of Contact we add one further method, to
print all the contact information with labels.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Print}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{@\PYGZdq{}Name:  \PYGZob{}0\PYGZcb{}}
\PYG{l+s}{Phone: \PYGZob{}1\PYGZcb{}}
\PYG{l+s}{Email: \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again, we use the instance variable names, plugging them into a format string.
Remember the \sphinxcode{\sphinxupquote{@}} syntax
for multiline strings from {\hyperref[\detokenize{data/strings2:strings2}]{\sphinxcrossref{\DUrole{std,std-ref}{String Special Cases}}}}.

\sphinxAtStartPar
You can see and see the entire Contact class
in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/contact1/contact1.cs}{contact1/contact1.cs}.

\sphinxAtStartPar
This is our first complete class defining a new type of object.
Look carefully to get used to the features introduced, before we add
more ideas:

\index{example@\spxentry{example}!Contact version 2@\spxentry{Contact version 2}}\ignorespaces 
\index{OOP@\spxentry{OOP}!this@\spxentry{this}}\index{this instance@\spxentry{this instance}}\ignorespaces 

\subsection{This Object}
\label{\detokenize{classes/a-first-class:this-object}}\label{\detokenize{classes/a-first-class:index-8}}
\sphinxAtStartPar
We will be making an elaboration on the Contact class from here on.  We introduce
new parts individually, but the whole code is in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/contact2/contact2.cs}{contact2/contact2.cs}.

\sphinxAtStartPar
The current object is \sphinxstyleemphasis{implicit} inside a constructor or instance method definition,
but it can be referred to \sphinxstyleemphasis{explicitly}.  It is called \sphinxcode{\sphinxupquote{this}}.
In a constructor or instance method, \sphinxcode{\sphinxupquote{this}} is automatically a legal
local variable to reference.
You usually do not need to
use it explicitly, but you could.   For example the current \sphinxcode{\sphinxupquote{Contact}} object’s
\sphinxcode{\sphinxupquote{name}} field could be referred to as either \sphinxcode{\sphinxupquote{this.name}} or the shorter plain \sphinxcode{\sphinxupquote{name}}.
In our next version of the Contact class we will see several places where
an explicit \sphinxcode{\sphinxupquote{this}} is useful.

\sphinxAtStartPar
In the first version of the constructor, repeated here,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Contact}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{phone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{email}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
we used different names for the instance variables and the formal
parameter names that we used to initialize the instance variables.  We
chose reasonable names, but we are adding extra names that we are not going
to use later, and it can be confusing.  The most obvious names for the formal
parameters that will initialize the instance variables are the \sphinxstyleemphasis{same} names.

\sphinxAtStartPar
If we are not careful, there is a problem with that.  An instance variable,
however named, and a local variable are not the same.  This is
nonsensical:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Contact}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ????}
\PYG{+w}{   }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Logically we want this pseudo\sphinxhyphen{}code in the constructor:
\begin{quote}

\sphinxAtStartPar
instance variable \sphinxcode{\sphinxupquote{name}}  \sphinxcode{\sphinxupquote{=}} local variable \sphinxcode{\sphinxupquote{name}}
\end{quote}

\sphinxAtStartPar
We have to disambiguate the two uses.  The compiler always looks for
\sphinxstyleemphasis{local} variable identifiers \sphinxstyleemphasis{first}, so plain \sphinxcode{\sphinxupquote{name}} will refer to the local
variable \sphinxcode{\sphinxupquote{name}} declared in the formal parameter list.
This local variable identifier  \sphinxstyleemphasis{hides} the matching instance variable
identifier.  We have to do something else to refer to the instance variable.
The explicit \sphinxcode{\sphinxupquote{this}} object comes to the rescue:  \sphinxcode{\sphinxupquote{this.name}} refers to
a part of this object.  It must refer to the
instance variable, not the local variable.  Our alternate constructor is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Contact}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{phone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{email}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Setters}
\label{\detokenize{classes/a-first-class:setters}}
\sphinxAtStartPar
The original version of Contact makes a Contact object be
\sphinxstyleemphasis{immutable}:  Once it is created with the constructor, there is no way
to change its internal state.  The only assignments to the private
instance variables are the ones in the constructor.  In real life
people can change their email address.  We might like to allow that
with our Contact objects.  Users can read the data in a Contact with the
\sphinxstyleemphasis{getter} methods.  Now we need \sphinxstyleemphasis{setter} methods.  The naming conventions
are similar:  start with “Set”.  In this case we must supply the new data,
so setter methods need a parameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{SetPhone}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{newPhone}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{phone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newPhone}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{SetPhone}}, like in our original constructor, we illustrate using a
\sphinxstyleemphasis{new} name for the parameter that sets the instance variable.  For
comparison we use the alternate identifier matching approach in the
other setter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{SetEmail}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{email}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can alter the contents of a Contact:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie Ortiz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}7890\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}mortiz2@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{c1}\PYG{p}{.}\PYG{n}{SetEmail}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}maria.ortiz@gmail.com\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{c1}\PYG{p}{.}\PYG{n}{SetPhone}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}555\PYGZhy{}555\PYGZhy{}5555\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{c1}\PYG{p}{.}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would print

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Name:  Marie Ortiz
Phone: 555\PYGZhy{}555\PYGZhy{}5555
Email: maria.ortiz@gmail.com
\end{sphinxVerbatim}

\index{ToString@\spxentry{ToString}}\index{override@\spxentry{override}}\ignorespaces 

\subsection{ToString Override}
\label{\detokenize{classes/a-first-class:tostring-override}}\label{\detokenize{classes/a-first-class:index-9}}
\sphinxAtStartPar
We created the \sphinxcode{\sphinxupquote{Print}} method for a Contact, and it is helpful to
assemble all the data for display \sphinxstyleemphasis{and} print it.   The issue there is that
the method does two \sphinxstyleemphasis{separate} clear things:  combining the string data
and printing it.  You might want the same string but put in a file or
used some other way.  Our \sphinxcode{\sphinxupquote{Print}} method will not help.

\sphinxAtStartPar
A good design decision is to separate the different actions:  the first is
to generate the 3\sphinxhyphen{}line string showing the full state of the object.  Once
we have this string, we can easily print it or write it to a file or ….
Hence we want a method to generate a descriptive string.

\sphinxAtStartPar
Think more generally about string representations:
All the built\sphinxhyphen{}in types can be concatenated into strings with the ‘+’ operator,
or displayed with \sphinxcode{\sphinxupquote{Console.Write}}.
We would like that behavior with our custom types, too.  How can the compiler
know how to handle types that were \sphinxstyleemphasis{not invented} when the compiler was written?

\sphinxAtStartPar
The answer is to have common features among all objects.
Any object has a \sphinxcode{\sphinxupquote{ToString}}
method, and that method is used implicitly when an object is used with
string concatenation, and also for \sphinxcode{\sphinxupquote{Write}}.
The default version supplied by the system is not very useful for an object
that it knows nothing about!  You need to define your own version,
one that knows how you have defined
your type, with its own specific instance variables.
You need to have that version used \sphinxstyleemphasis{in place of} the default:
You need to \sphinxstyleemphasis{override} the default.  To emphasize the \sphinxstyleemphasis{change}
in meaning, the word \sphinxcode{\sphinxupquote{override}} \sphinxstyleemphasis{must} be in the heading:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{@\PYGZdq{}Name:  \PYGZob{}0\PYGZcb{}}
\PYG{l+s}{ \PYGZob{}1\PYGZcb{}}
\PYG{l+s}{ \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{phone}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{email}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See what the method does:  it uses the object state to create and
\sphinxstyleemphasis{return} a single string representation of the object.

\sphinxAtStartPar
For any kind of new object that you create and want to be able to implicitly convert to
a string, you need a \sphinxcode{\sphinxupquote{ToString}} method with the \sphinxstyleemphasis{exact} same heading
as the \sphinxcode{\sphinxupquote{ToString}} for a Contact.

\sphinxAtStartPar
A more complete discussion of \sphinxcode{\sphinxupquote{override}}
would lead us into class hierarchies and
inheritance, which we are not emphasizing in this book.

\sphinxAtStartPar
We still might like to have a convenience method \sphinxcode{\sphinxupquote{Print}}.  It now can
be written much more easily, using our latest \sphinxcode{\sphinxupquote{ToString}}.

\sphinxAtStartPar
We want one instance method,
\sphinxcode{\sphinxupquote{Print}} to call another instance method \sphinxcode{\sphinxupquote{ToString}} for the \sphinxstyleemphasis{same} object.
How does this work?  It is like when instance method \sphinxcode{\sphinxupquote{GetName}}
refers to an instance variable
\sphinxcode{\sphinxupquote{name}} without using dot notation.  Then \sphinxcode{\sphinxupquote{name}} is assumed to refer to
this object associated with the call to \sphinxcode{\sphinxupquote{GetName}}.  We can change our
\sphinxcode{\sphinxupquote{Print}} definition to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Print}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{ToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{ToString()}} is a method called without dot notation explicitly
attaching it to an object.
As with instance variables, it is implicitly attached to this object, the one
attached to the call to \sphinxcode{\sphinxupquote{Print}}.

\sphinxAtStartPar
Again, the whole code for the elaborated Contact is in example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/contact2/contact2.cs}{contact2/contact2.cs}.

\sphinxAtStartPar
New testing code is in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/contact2/test\_contact2.cs}{contact2/test\_contact2.cs}.  Run the project
and check that it does what you would expect.  There are several new
features illustrated in the testing code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie Ortiz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}7890\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                            }\PYG{l+s}{\PYGZdq{}mortiz2@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Otto Heinz\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}773\PYGZhy{}508\PYGZhy{}9999\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                            }\PYG{l+s}{\PYGZdq{}oheinz@luc.edu\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Marie\PYGZsq{}s full name: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Her phone number: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetPhone}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Her email: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{GetEmail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}All together:\PYGZbs{}n\PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Full contact info for Otto:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{c2}\PYG{p}{.}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{c1}\PYG{p}{.}\PYG{n}{SetEmail}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}maria.ortiz@gmail.com\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{c2}\PYG{p}{.}\PYG{n}{SetPhone}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}123\PYGZhy{}456\PYGZhy{}7890\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Amy Li\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}847\PYGZhy{}111\PYGZhy{}2222\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                            }\PYG{l+s}{\PYGZdq{}amy.li22@yahoo.com\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}With changes and added contact:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{allc}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Contact}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Contact}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{n}{c1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{foreach}\PYG{p}{(}\PYG{n}{Contact}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{allc}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZbs{}n\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Contact is now a type we can use with other types.  \sphinxcode{\sphinxupquote{Main}} ends creating
a \sphinxcode{\sphinxupquote{List\textless{}Contact\textgreater{}}} and an array of Contacts, and processes Contacts in the
\sphinxcode{\sphinxupquote{List}} with a \sphinxcode{\sphinxupquote{foreach}} loop.

\sphinxAtStartPar
We mentioned that this particular signature in the
\sphinxcode{\sphinxupquote{ToString}} heading means that the system recognizes it in string
concatenation and in substitutions into a \sphinxcode{\sphinxupquote{Write}} or \sphinxcode{\sphinxupquote{WriteLine}}
format string.  Find both in \sphinxcode{\sphinxupquote{Main}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ToString}} override also means that the body of our \sphinxcode{\sphinxupquote{Print}}
definition in the Contact class could have been
even shorter, using the object \sphinxcode{\sphinxupquote{this}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Print}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When we use \sphinxcode{\sphinxupquote{Console.WriteLine}} on this current object, which is \sphinxstyleemphasis{not}
already a string, there is an automatic call to \sphinxcode{\sphinxupquote{ToString}}.

\index{redeclaring instance variables error@\spxentry{redeclaring instance variables error}}\index{compiler error@\spxentry{compiler error}!before error in text@\spxentry{before error in text}}\index{instance variable@\spxentry{instance variable}!redeclaring error@\spxentry{redeclaring error}}\ignorespaces 

\subsection{Local Variables Hiding Instance Variables}
\label{\detokenize{classes/a-first-class:local-variables-hiding-instance-variables}}\label{\detokenize{classes/a-first-class:index-10}}\label{\detokenize{classes/a-first-class:id3}}
\sphinxAtStartPar
A common error is for students to try to declare the instance variables twice,
once in the regular instance variable declarations,
\sphinxstyleemphasis{outside of any constructor or method} and then again \sphinxstyleemphasis{inside} a
constructor, like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Contact}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fullName}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{// LOGICAL ERROR!}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{phone}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{phoneNumber}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// LOGICAL ERROR!}
\PYG{+w}{   }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{email}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{emailAddress}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// LOGICAL ERROR}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is deadly.  It is worse than redeclaring a local variable, which at least will
trigger a compiler error.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Instance variable \sphinxstyleemphasis{only} get declared outside of all
functions and constructors.  Same\sphinxhyphen{}name
local variable declarations hide the
instance variables, but \sphinxstyleemphasis{compile just fine}.  The local variables disappear
after the constructor ends, leaving the instance variables
\sphinxstyleemphasis{without} your desired initialization. Instead the hidden instance variables
just get the default initialization, \sphinxcode{\sphinxupquote{null}} for an object
or 0 for a number.
\end{sphinxadmonition}

\sphinxAtStartPar
There is a related strange compiler error.  This is not likely to happen frequently,
but thinking through its logic (or illogic) could be helpful in understanding
local and instance variables:
Generally when you get a compiler error, the error is at or \sphinxstyleemphasis{before} the location the
error is referenced, but with local variables covering instance variables,
the real cause can come later in the text of the method.  Below, when you first
refer to \sphinxcode{\sphinxupquote{r}} in \sphinxcode{\sphinxupquote{Badnames}}, it appears to be correctly referring to the
instance variable \sphinxcode{\sphinxupquote{r}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ForwardError}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// ...}

\PYG{+w}{    }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{BadNames}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{*}\PYG{n}{r}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// legal in text *just* to here; instance field r}
\PYG{+w}{        }\PYG{c+c1}{//...}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// r declaration makes *earlier* line wrong}
\PYG{+w}{        }\PYG{c+c1}{//...}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The compiler scans through \sphinxstyleemphasis{all} of \sphinxcode{\sphinxupquote{BadNames}}, and sees the \sphinxcode{\sphinxupquote{r}} declared locally
in its scope.
The error may be marked on the earlier line, where the compiler then assumes
\sphinxcode{\sphinxupquote{r}} is the later declared local \sphinxcode{\sphinxupquote{int}} variable, not the instance variable.
The error it sees is a local variable used before declaration.

\sphinxAtStartPar
This is based on a real student example.
This example points to a second issue: using variable names that
that are too short and not descriptive of the variable meaning, and so may
easily be the same name as something unrelated.

\index{lifetime@\spxentry{lifetime}!vs. scope@\spxentry{vs. scope}}\index{scope@\spxentry{scope}!vs. lifetime@\spxentry{vs. lifetime}}\ignorespaces 

\subsubsection{Lifetime and Scope Exercise/Example}
\label{\detokenize{classes/a-first-class:lifetime-and-scope-exercise-example}}\label{\detokenize{classes/a-first-class:index-11}}
\sphinxAtStartPar
Be careful to distinguish lifetime and scope.  Either a local variable or
an instance variable can be temporarily out of scope, but still be alive.
Can you construct an example to illustrate that?  One of ours is
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/lifetime\_scope/lifetime\_scope.cs}{lifetime\_scope/lifetime\_scope.cs}.

\sphinxstepscope

\index{class@\spxentry{class}!instance examples@\spxentry{instance examples}}\ignorespaces 

\section{Class Instance Examples}
\label{\detokenize{classes/classexamples:class-instance-examples}}\label{\detokenize{classes/classexamples:index-0}}\label{\detokenize{classes/classexamples:id1}}\label{\detokenize{classes/classexamples::doc}}
\index{exercise@\spxentry{exercise}!getters and setters@\spxentry{getters and setters}}\ignorespaces 

\subsection{More Getters and Setters}
\label{\detokenize{classes/classexamples:more-getters-and-setters}}\label{\detokenize{classes/classexamples:index-1}}\label{\detokenize{classes/classexamples:id2}}
\sphinxAtStartPar
As an exercise you could write a simple class Example, with
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int}} instance variable \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{double}} instance variable \sphinxcode{\sphinxupquote{d}}

\item {} 
\sphinxAtStartPar
a simple constructor with parameters to set instance variables
\sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{d}}

\item {} 
\sphinxAtStartPar
getters and setters for both instance variables (4 methods in all)

\item {} 
\sphinxAtStartPar
a ToString that prints a line with both instance variables labeled.

\end{enumerate}

\sphinxAtStartPar
Compare yours to
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/example\_class/example\_class.cs}{example\_class/example\_class.cs}.

\sphinxAtStartPar
We include a testing class at the end of this file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ExampleTest}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{Example}\PYG{+w}{ }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Example}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2.5}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// use constructor}
\PYG{+w}{      }\PYG{c+c1}{// this creates the first Example object with reference e}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}e.n = \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{GetN}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints 1}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}e.d = \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{GetD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints 2.5}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 1, d = 2.5}

\PYG{+w}{      }\PYG{n}{e}\PYG{p}{.}\PYG{n}{SetN}\PYG{p}{(}\PYG{l+m}{25}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{e}\PYG{p}{.}\PYG{n}{SetD}\PYG{p}{(}\PYG{l+m}{3.14159}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}e.n = \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{GetN}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints 25}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}e.d = \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{GetD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints 3.14159}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 25, d = 3.14159}

\PYG{+w}{      }\PYG{n}{Example}\PYG{+w}{ }\PYG{n}{e2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Example}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10.5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{c+c1}{// this creates the second Example object with reference e2}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 3, d = 10.5}

\PYG{+w}{      }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e2}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// now both e and e2 reference the second object}
\PYG{+w}{      }\PYG{c+c1}{// the first Example object is now no longer referenced}
\PYG{+w}{      }\PYG{c+c1}{// and its memory can be reclaimed at runtime if necessary}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 3, d = 10.5}

\PYG{+w}{      }\PYG{n}{e2}\PYG{p}{.}\PYG{n}{SetN}\PYG{p}{(}\PYG{l+m}{77}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// symbolism uses e2, not e}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 77, d = 10.5}
\PYG{+w}{      }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints Example: n = 77, d = 10.5}
\PYG{+w}{      }\PYG{c+c1}{// but e is the same object \PYGZhy{} so its fields are changed}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{c+c1}{// end of class ExampleTest}
\end{sphinxVerbatim}

\sphinxAtStartPar
Besides the obvious tests, we also use
the fact that an Example object is mutable to play with  {\hyperref[\detokenize{arrays/onedim:alias}]{\sphinxcrossref{\DUrole{std,std-ref}{References and Aliases}}}}:
In the
last few lines of \sphinxcode{\sphinxupquote{Main}}, after \sphinxcode{\sphinxupquote{e}} becomes an alias for \sphinxcode{\sphinxupquote{e2}},
we change
an object under one name, and it affect the alias the same way.
Check this by running the program!

\sphinxAtStartPar
Make sure you can follow the code and the output from running.

\index{Averager Example@\spxentry{Averager Example}}\ignorespaces \phantomsection\label{\detokenize{classes/classexamples:beyond-getters-and-setters}}\subsubsection*{Beyond Getters and Setters}

\sphinxAtStartPar
Thus far we have had very simple classes with instance variables and
getter and setter methods, and maybe a ToString method.
These classes were designed to introduce the basic syntax for
classes with instances.  The classes have just been containers for data
that we can read back, and change if there are setter methods \sphinxhyphen{} pretty
boring and limited.  Many objects have more extensive behaviors, so we will
take a small step and imagine a somewhat more complicated  \sphinxcode{\sphinxupquote{Averager}} class:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A new \sphinxcode{\sphinxupquote{Averager}} starts with no data acknowledged.

\item {} 
\sphinxAtStartPar
Be able to enter data values one at a time (method \sphinxcode{\sphinxupquote{AddDatum}}).
We will use \sphinxcode{\sphinxupquote{double}} values.

\item {} 
\sphinxAtStartPar
At any point be able to return the average of the numbers entered so far
(method \sphinxcode{\sphinxupquote{GetAverage}}).
The average is the sum of all the values divided by number of values.
With \sphinxcode{\sphinxupquote{double}} values we assume a \sphinxcode{\sphinxupquote{double}} average.
This does not make sense if there
are no values so far, but with double type we can use the value
\sphinxcode{\sphinxupquote{NaN}} (Not a Number) in this case.

\item {} 
\sphinxAtStartPar
Be able to return the number of data elements entered so far
(method \sphinxcode{\sphinxupquote{GetDataCount}})

\item {} 
\sphinxAtStartPar
Be able to clear the \sphinxcode{\sphinxupquote{Averager}}, going back to no data elements
considered yet, like in a new \sphinxcode{\sphinxupquote{Averager}} (method \sphinxcode{\sphinxupquote{Clear}})

\item {} 
\sphinxAtStartPar
It is good to have a \sphinxcode{\sphinxupquote{ToString}} method.  We choose to have
it label the number of data items and the average of the items.

\end{itemize}

\sphinxAtStartPar
The object starts from a fixed
state (no data) so we do not need any constructor parameters.

\sphinxAtStartPar
We can imagine a demonstration class \sphinxcode{\sphinxupquote{AveragerDemo}} with a \sphinxcode{\sphinxupquote{Main}} method
containing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{         }\PYG{n}{Averager}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Averager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}New Averager: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{k}{new}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m}{5.1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{7.3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{11.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3.7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Next datum \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{a}\PYG{p}{.}\PYG{n}{AddDatum}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}average \PYGZob{}0\PYGZcb{} with \PYGZob{}1\PYGZcb{} data values\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                              }\PYG{n}{a}\PYG{p}{.}\PYG{n}{GetAverage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{GetDataCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{a}\PYG{p}{.}\PYG{n}{Clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}After clearing:\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}average \PYGZob{}0\PYGZcb{} with \PYGZob{}1\PYGZcb{} data values\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                           }\PYG{n}{a}\PYG{p}{.}\PYG{n}{GetAverage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{GetDataCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should print

\begin{sphinxVerbatim}[commandchars=\\\{\}]
New Averager: items: 0; average: NaN
Next datum 5.1
average 5.1 with 1 data values
Next datum \PYGZhy{}7.3
average \PYGZhy{}1.1 with 2 data values
Next datum 11
average 2.93333333333333 with 3 data values
Next datum 3.7
average 3.125 with 4 data values
After clearing:
average NaN with 0 data values
\end{sphinxVerbatim}

\sphinxAtStartPar
Now that we have a clear idea of the proposed outward behavior, we
can consider how to implement the \sphinxcode{\sphinxupquote{Averager}} class.

\sphinxAtStartPar
We could store a list of all the data values entered in any instance,
requiring a large amount of memory for a long list. However, this
functionality was built into early calculators, with very limited memory.
How can we do it without remembering the whole list?
Consider a concrete example:

\sphinxAtStartPar
If I have entered numbers 2.1, 4.5 and 5.4, and want the average, it is
\begin{quote}

\sphinxAtStartPar
\((2.1+4.5+5.4)/3=12.0/3=4.0\)
\end{quote}

\sphinxAtStartPar
If I want to include a further number 5.0, the average becomes
\begin{quote}

\sphinxAtStartPar
\((2.1+4.5+5.4+5.0)/4=17.0/4=4.25\)
\end{quote}

\sphinxAtStartPar
Note the relationship to the previous average expression:
\begin{quote}

\sphinxAtStartPar
\(=((2.1+4.5+5.4)+5.0)/4=(12.0+5.0)/(3+1)\)
\end{quote}

\sphinxAtStartPar
In the numerator we have added the latest value to the previous sum,
and in the denominator the count of data items is increased by one.
All we need to remember to
go on to include the next item is the sum of values so far and the
number of values so far.  We can just have instance variables
\sphinxcode{\sphinxupquote{sum}} and \sphinxcode{\sphinxupquote{dataCount}}.

\sphinxAtStartPar
You might think how to create this class….

\sphinxAtStartPar
The full \sphinxcode{\sphinxupquote{Averager}} code follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// a class that is more than a container}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Averager}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{dataCount}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{/// new Averager with no data}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Averager}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{AddDatum}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{k}{value}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{k}{value}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{dataCount}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetDataCount}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{dataCount}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Gets the average of the data}
\PYG{+w}{      }\PYG{c+c1}{///   or NaN if no data.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{GetAverage}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{o}{/}\PYG{n}{dataCount}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// is NaN if dataCount is 0}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Clear}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0.0}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{dataCount}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}items: \PYGZob{}0\PYGZcb{}; average: \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                              }\PYG{n}{GetDataCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GetAverage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Several things to note:
\begin{itemize}
\item {} 
\sphinxAtStartPar
We show that a constructor, like an instance method, can include a call
to a further instance method.  Though we illustrate this idea, the
constructor code is
actually unneeded.  See the {\hyperref[\detokenize{classes/classexamples:unneeded-constructor-code-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Unneeded Constructor Code Exercise}}}} below.

\item {} 
\sphinxAtStartPar
We have methods that are not ToString or mere getters or setters of instance
variables.  The logic of the class requires more.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{GetAverage}}
method does return data obtained by reading instance variable, but it does
a calculation using the instance variables first.  See
{\hyperref[\detokenize{classes/classexamples:alternate-internal-state-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Alternate Internal State Exercise}}}}.

\end{itemize}

\sphinxAtStartPar
The code for both classes is in project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/averager}{averager}.


\subsubsection{Statistics Exercise}
\label{\detokenize{classes/classexamples:statistics-exercise}}
\sphinxAtStartPar
Modify the project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/averager}{averager} so the \sphinxcode{\sphinxupquote{Averager}} class is
converted to \sphinxcode{\sphinxupquote{Statistics}}.  Besides having methods to calculate the count
of data items and average, also calculate the standard deviation with
a method \sphinxcode{\sphinxupquote{StandardDeviation}}.
It turns out that the only other instance variable needed is
the sum of the squares of the data items, call it \sphinxcode{\sphinxupquote{sumOfSqr}}.
Before calculating the standard deviation, suppose we
assign the current average to  a local variable \sphinxcode{\sphinxupquote{avg}}.
Then the handiest form of expression for the standard deviation is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sumOfSqr}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{avg}\PYG{o}{*}\PYG{n}{avg}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dataCount}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Modify the demonstration program to show the standard deviation, too.


\subsubsection{Unneeded Constructor Code Exercise}
\label{\detokenize{classes/classexamples:unneeded-constructor-code-exercise}}\label{\detokenize{classes/classexamples:id3}}
\sphinxAtStartPar
Recall that objects are always initialized. Each instance variable
has a default value assigned before a constructor is even run.
The default value for numeric instance variables is 0, so the
call to \sphinxcode{\sphinxupquote{Clear}} in the constructor could be left out, leaving the
body of the constructor empty!  Try commenting that line out
and test that the behavior of demo program is the same.

\sphinxAtStartPar
Emphasizing the fact that you are thinking about the
initial values of instance variables is not a bad idea.  Hence
a common practice is to
explicitly assign even the default values in the constructor, as
we did initially with the call to \sphinxcode{\sphinxupquote{Clear}} inside the constructor.

\sphinxAtStartPar
If no constructor definition is explicitly provided at all,
the compiler implicitly creates one with no parameters and an empty body.
This means that the entire constructor in \sphinxcode{\sphinxupquote{Averager}} could be omitted.
Comment the whole constructor out and check.

\sphinxAtStartPar
There is a defensive programming
reason to provide even the do\sphinxhyphen{}nothing constructor explicitly:
If you use the implicit constructor and then decide to add a constructor
with parameters, the implicit constructor is no longer defined by the compiler,
so any remaining call to it in your code becomes an error.


\subsubsection{Alternate Internal State Exercise}
\label{\detokenize{classes/classexamples:alternate-internal-state-exercise}}\label{\detokenize{classes/classexamples:id4}}
\sphinxAtStartPar
The way we represent the internal state for an \sphinxcode{\sphinxupquote{Averager}} is the
best probably, but if it turns out that the \sphinxcode{\sphinxupquote{GetAverage}} method
is called a lot more often than a method that changes the state,
we could avoid repeated division by saving the average as an
instance variable.  We could keep that \sphinxstyleemphasis{instead of} \sphinxcode{\sphinxupquote{sum}}
(and still keep \sphinxcode{\sphinxupquote{dataCount}}).  We can manage to
keep the same public interface to the methods.  With these
alternate instance variables how would you change
the implementation code and not change the method headings or meanings?
If we keep the assumption that the average of 0
items is
\sphinxcode{\sphinxupquote{double.Nan}}, you will need to treat adding the first datum as
a special case.  The code is simpler if we change the outward assumptions
enough to consider the average of 0 items
to be 0.  Try it either way.

\sphinxAtStartPar
In the version with NaN you can avoid testing for NaN,
but if you choose to test for
NaN, you need the boolean \sphinxcode{\sphinxupquote{Double.IsNaN}} function, because the expression
\sphinxcode{\sphinxupquote{double.NaN == double.NaN}} is \sphinxstyleemphasis{false}!

\index{class@\spxentry{class}!convert static game to instance@\spxentry{convert static game to instance}}\ignorespaces 

\subsection{Converting A Static Game To A Game Instance}
\label{\detokenize{classes/classexamples:converting-a-static-game-to-a-game-instance}}\label{\detokenize{classes/classexamples:index-3}}
\sphinxAtStartPar
For a comparison of procedural and object\sphinxhyphen{}oriented coding,
consider converting {\hyperref[\detokenize{while/lab-number-game:lab-number-game}]{\sphinxcrossref{\DUrole{std,std-ref}{Number Guessing Game Lab}}}} so that a GuessGame
is an object, an instance of the GuessGame class.

\sphinxAtStartPar
While our earlier example, Contact, is a simple but practical
use of object\sphinxhyphen{}oriented programming, GuessGame is somewhat more artificial.
We create it hoping that highlighting the differences between procedural
and object\sphinxhyphen{}oriented presentation is informative.  Also, we will see
with {\hyperref[\detokenize{interfaces/interfaces:interface}]{\sphinxcrossref{\DUrole{std,std-ref}{Interfaces}}}} that
there are C\# language features that require an
object rather than just a function and data.
In {\hyperref[\detokenize{interfaces/csproj-revisited:igame-interface-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{IGame Interface Exercise}}}} you can use a Game object.

\sphinxAtStartPar
Here is a procedural game version, example file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/static\_version/static\_version.cs}{static\_version/static\_version.cs}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Game}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Random}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{big}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a secret number bound: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Play}\PYG{p}{(}\PYG{n}{big}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Play}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{big}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{secret}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{n}{big}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{guesses}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Guess a number less than \PYGZob{}0\PYGZcb{}.\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{big}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{guess}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Next guess: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{secret}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{guess}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{guess}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{secret}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Too small!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Too big!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{guess}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UI}\PYG{p}{.}\PYG{n}{PromptInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Next guess: \PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{guesses}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}You won on guess \PYGZob{}0\PYGZcb{}!\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{guesses}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The project also refers to the library class UI,
with the functions we use for safe
keyboard input.  It is all static methods.

\sphinxAtStartPar
Is there any reason to make this UI class have its own own instances?

\sphinxAtStartPar
\sphinxstylestrong{No}.  There is no state to remember between UI method calls.
What comes in through
the keyboard goes out through a return value,
and then you are completely done with it.
A simple static function works fine each time.
\sphinxstyleemphasis{Do not get fancy for nothing}.

\sphinxAtStartPar
What state would a game hold?  We might set it up so the user
chooses the size of the range of choices just once, and remember it
for possibly multiple plays of the GuessGame.  The variable was
\sphinxcode{\sphinxupquote{big}} before, we can keep the name.
If we are going to remember it inside our GuessGame instance,
then \sphinxcode{\sphinxupquote{big}} needs to become an instance variable, and it will be something
we can set in a constructor.

\sphinxAtStartPar
What actions/methods will this object have?  Only one \sphinxhyphen{} playing a GuessGame.
The GuessGame could be played multiple times, and that action, play,
makes sense as a method, Play, which will look a lot like the current
static function.

\sphinxAtStartPar
In the procedural version there are several other important variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Random rand:  That was static before, for good reason:
We only need one Random number generator for the whole
time the program is running, so one static variable makes sense.

\item {} 
\sphinxAtStartPar
The central number in the procedural Game
and our future Play method is \sphinxcode{\sphinxupquote{secret}}.
Should that be an instance variable?  It would work, but it would
be unhelpful and misleading:  Secret is reset every time the game is played,
and it has no meaning after a Play function would be finished.
There is nothing to
remember \sphinxstyleemphasis{between} time you Play.  This is the
perfect place for a local variable \sphinxstyleemphasis{as we have now}.

\end{itemize}

\sphinxAtStartPar
A common newbie error is to make things
into instance variables, just because you can, when an old\sphinxhyphen{}fashioned
local variable is all that you need.  It is good to have variables leave the
programmer’s consciousness when they are no longer needed,
as a local variable does.
An instance variable lingers on, leaving extra places to make errors.

\sphinxAtStartPar
This introductory discussion could get you going, making a transformation.
Go ahead and make the changes as far as you can:
create project GuessGame inside the current solution.
Have a class GuessGame for the GuessGame instance,
with instance variable \sphinxcode{\sphinxupquote{big}} and method \sphinxcode{\sphinxupquote{Play}}.

\sphinxAtStartPar
You still need a static \sphinxcode{\sphinxupquote{Main}} method to first create the GuessGame object.
You could prompt the user for the value for \sphinxcode{\sphinxupquote{big}} to send to the constructor.
Once you have an object, you can call \sphinxstyleemphasis{instance method} \sphinxcode{\sphinxupquote{Play}}.
What about parameters? What needs to change from the procedural version?

\sphinxAtStartPar
There is also a video for this section that
follows all the way through the steps.
A possible final result is in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/instance\_version/guess\_game.cs}{instance\_version/guess\_game.cs}.


\subsection{Animal Class Lab}
\label{\detokenize{classes/classexamples:animal-class-lab}}\label{\detokenize{classes/classexamples:animal-lab}}
\sphinxAtStartPar
\sphinxstylestrong{Objectives}:
Complete a simple (silly) class, with constructor and methods,
including a \sphinxcode{\sphinxupquote{ToString}} method, and a separate testing class.

\sphinxAtStartPar
Make an animal\_lab project in your solution,
and copy in the files from the example
project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/animal\_lab\_stub}{animal\_lab\_stub}.
Then modify the two files as discussed below.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Complete the simple class Animal in your copy of the file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/animal\_lab\_stub/animal.cs}{animal.cs}.
The bullets below
name and describe the instance variables, constructor,
and methods you need to write:
\begin{itemize}
\item {} 
\sphinxAtStartPar
An Animal has a \sphinxcode{\sphinxupquote{name}} and a \sphinxcode{\sphinxupquote{gut}}.
In our version the \sphinxcode{\sphinxupquote{gut}} is a List of strings
describing the contents, in the order eaten.
A newly created Animal gets a \sphinxcode{\sphinxupquote{name}} from a parameter
passed to the constructor, while the \sphinxcode{\sphinxupquote{gut}} always starts off \sphinxstyleemphasis{empty}.

\item {} 
\sphinxAtStartPar
An Animal has a \sphinxcode{\sphinxupquote{Greet}} method, so an animal named “Froggy” would say
(that is, print)
\begin{quote}

\sphinxAtStartPar
Hello, my name is Froggy.
\end{quote}

\item {} 
\sphinxAtStartPar
An Animal can \sphinxcode{\sphinxupquote{Eat}} a string naming the food,
adding the food to the \sphinxcode{\sphinxupquote{gut}}.
If Froggy eats “worm” and then “fly”, its \sphinxcode{\sphinxupquote{gut}} list contains
“worm” and “fly”.

\item {} 
\sphinxAtStartPar
An Animal can \sphinxcode{\sphinxupquote{Excrete}}
(removing and printing what was \sphinxstyleemphasis{first} in the gut List).
Recall the method \sphinxcode{\sphinxupquote{RemoveAt}} in {\hyperref[\detokenize{lists/listsyntax:listsyntax}]{\sphinxcrossref{\DUrole{std,std-ref}{List Syntax}}}}.  Print the
empty string, “”, if the \sphinxcode{\sphinxupquote{gut}}
\sphinxstyleemphasis{was already empty}.  Following the
Froggy example above, Froggy could \sphinxcode{\sphinxupquote{Excrete}},
and “worm” would be printed.
Then its \sphinxcode{\sphinxupquote{gut}} would contain only “fly”.

\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{ToString}} method:
Remember the \sphinxcode{\sphinxupquote{override}} keyword.  Make it return a string in the format
shown below for Froggy, including the Animal’s name:
\begin{quote}

\sphinxAtStartPar
“Animal: Froggy”
\end{quote}

\sphinxAtStartPar
Try this first, and note the extra credit version below.

\item {} 
\sphinxAtStartPar
All the methods that print should be void.
Which need a parameter, of what type?

\end{itemize}

\item {} 
\sphinxAtStartPar
Complete the file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/animal\_lab\_stub/test\_animal.cs}{test\_animal.cs}
with its class \sphinxcode{\sphinxupquote{TestAnimal}} containing the
\sphinxcode{\sphinxupquote{Main}} method, testing the class Animal:
Create a couple of Animals and visibly test all the methods,
with enough explanation that someone running the test program,
but \sphinxstyleemphasis{not} looking at the code of either file, can see that everything works.

\item {} 
\sphinxAtStartPar
20\% EXTRA CREDIT:  Elaborate \sphinxcode{\sphinxupquote{ToString}} so if Froggy had “worm”, “fly”
and “bug” in the gut, the string would be:
\begin{quote}

\sphinxAtStartPar
“Animal: Froggy ate worm, fly and bug”
\end{quote}

\sphinxAtStartPar
with a comma separated list of the gut contents, except use proper English,
so the last separator
is ” and “, not “, “.
If the gut has nothing in it, list the contents as “nothing”:
\begin{quote}

\sphinxAtStartPar
“Animal: Froggy ate nothing”
\end{quote}

\end{enumerate}

\index{class@\spxentry{class}!user class as instance@\spxentry{user class as instance}}\index{example@\spxentry{example}!clock@\spxentry{clock}}\ignorespaces 

\subsection{Clock Example}
\label{\detokenize{classes/classexamples:clock-example}}\label{\detokenize{classes/classexamples:clock}}\label{\detokenize{classes/classexamples:index-4}}
\sphinxAtStartPar
Consider the logic for a digital 24 hour clock object,
type \sphinxcode{\sphinxupquote{Clock}}, that shows hours and minutes,
so 03:45 would be three forty\sphinxhyphen{}five.
Note that there is no AM or PM:  The hours go from 00, starting at midnight,
through hour 23, the 11PM hour, so 23:59 would be a minute before midnight,
and 13:00 would be 1PM.

\sphinxAtStartPar
Assume there is some attached circuit to signal when a new minute starts.

\sphinxAtStartPar
This class could have just a few methods:  \sphinxcode{\sphinxupquote{Tick}},
called when a new minute is signaled,
and \sphinxcode{\sphinxupquote{GetTimeString}} to return the time in the format illustrated above,
and \sphinxcode{\sphinxupquote{SetTime}} specifying new values for the hours and minutes.
We can start
from a constructor that just sets the clock’s time to midnight.

\sphinxAtStartPar
We can imagine a demonstration class \sphinxcode{\sphinxupquote{ClockDemo}} with a \sphinxcode{\sphinxupquote{Main}} method
containing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{         }\PYG{n}{Clock}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Midnight \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{GetTimeString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{c}\PYG{p}{.}\PYG{n}{SetTime}\PYG{p}{(}\PYG{l+m}{23}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{58}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Before midnight \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{GetTimeString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{c}\PYG{p}{.}\PYG{n}{Tick}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Tick \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{GetTimeString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should print

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Midnight 00:00
Before midnight 23:58
Tick 23:59
Tick 00:00
Tick 00:01
Tick 00:02
\end{sphinxVerbatim}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{Clock}} object will need instance variables.
One obvious approach would be to have \sphinxcode{\sphinxupquote{int}}
instance variables for the hours and minutes. Both can be set and can advance
and will need ot be read.

\sphinxAtStartPar
These actions are common to both the hours and minutes,
so we might think how we can avoid writing some things twice.
There is one main difference:  The minutes roll over at 60
while the hours roll over at 24.  Though the limits are different,
they are both numbers, so we can store the limit for each, 60 or 24.
Then the same code could be used to advance each one, just using a different value
for the rollover limit.

\sphinxAtStartPar
How would we neatly code this in a way that reuses code?  The most significant
thing to notice is that dealing with minutes involves data (the current count
and the limit 60) and associated actions:  being set, advanced and read.
The same is true for the hours.
The combination of \sphinxstyleemphasis{data and tightly associated actions}, particularly used
in more than one situation,
suggests a new class of objects, say \sphinxcode{\sphinxupquote{RolloverCounter}}.

\sphinxAtStartPar
Notice the shift in this approach:  The instance variables for hours and minutes
would become instances of the \sphinxcode{\sphinxupquote{RolloverCounter}} class.  A \sphinxcode{\sphinxupquote{RolloverCounter}}
should know how to advance itself.  Hence the logic for advancing a counter,
sometimes rolling it over, would not be directly in the \sphinxcode{\sphinxupquote{Clock}} class,
but in the \sphinxcode{\sphinxupquote{RolloverCounter}} class.

\sphinxAtStartPar
So let’s think more about what we would want in the \sphinxcode{\sphinxupquote{RolloverCounter}} class.
What instance variables?  Of course we have the current count,
and since we want the same class to work for both minutes and hours, we
also need to have the rollover limit. They are both integers.

\sphinxAtStartPar
The limit should just be set once for a particular counter,
presumably when the object is created.  For simplicity
we can just assume the count is 0 when a \sphinxcode{\sphinxupquote{RolloverCounter}}
is first created.  Of course we must have a method to let the count
advance, rolling over back to 0 when the limit it reached.

\sphinxAtStartPar
Throw in a getter and a setter for the count and we can have the following
class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// class used twice in Clock}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{RolloverCounter}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{RolloverCounter}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{limit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//for clarity \PYGZhy{} this is the default value}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetCount}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{SetCount}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{this}\PYG{p}{.}\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// advance by one time tick}
\PYG{+w}{      }\PYG{c+c1}{/// eventually roll over at limit}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Advance}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{count}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note how concise the \sphinxcode{\sphinxupquote{Advance}} method is!  With the remainder operation,
we do not need an \sphinxcode{\sphinxupquote{if}} statement.
Check examples by hand if this seems strange.

\index{format@\spxentry{format}!0\sphinxhyphen{}pad@\spxentry{0\sphinxhyphen{}pad}}\index{zero pad format@\spxentry{zero pad format}}\index{overloading@\spxentry{overloading}!constructors@\spxentry{constructors}}\ignorespaces 
\sphinxAtStartPar
Finally we introduce the \sphinxcode{\sphinxupquote{Clock}} class itself.
We display the entire code first, and follow it with comments about a number
of new features.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// class with instance variables of another user class}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Clock}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{n}{RolloverCounter}\PYG{+w}{ }\PYG{n}{hours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minutes}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{/// new Clock set to midnight}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Clock}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{hours}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{RolloverCounter}\PYG{p}{(}\PYG{l+m}{24}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{minutes}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{RolloverCounter}\PYG{p}{(}\PYG{l+m}{60}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{///  new Clock set to specified time}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Clock}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nHours}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nMinutes}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{hours}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{RolloverCounter}\PYG{p}{(}\PYG{l+m}{24}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{minutes}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{RolloverCounter}\PYG{p}{(}\PYG{l+m}{60}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{SetTime}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nHours}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nMinutes}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{SetTime}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nHours}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{nMinutes}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{hours}\PYG{p}{.}\PYG{n}{SetCount}\PYG{p}{(}\PYG{n}{nHours}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{minutes}\PYG{p}{.}\PYG{n}{SetCount}\PYG{p}{(}\PYG{n}{nMinutes}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// advance by one time tick}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Tick}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{minutes}\PYG{p}{.}\PYG{n}{Advance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{minutes}\PYG{p}{.}\PYG{n}{GetCount}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{hours}\PYG{p}{.}\PYG{n}{Advance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Always 2 digits for both hours and minute with colon in middle}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetTimeString}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0:D2\PYGZcb{}:\PYGZob{}1:D2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{hours}\PYG{p}{.}\PYG{n}{GetCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minutes}\PYG{p}{.}\PYG{n}{GetCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First the principal reason for this example:  We illustrate
writing a class where the instance variables are objects of a different
user\sphinxhyphen{}defined type.  Because the instance variables \sphinxcode{\sphinxupquote{hours}} and
\sphinxcode{\sphinxupquote{minutes}} are objects, we must initialize them
using the \sphinxcode{\sphinxupquote{new}} syntax.

\item {} 
\sphinxAtStartPar
Skip over the \sphinxstyleemphasis{second} constructor for now, and see the \sphinxcode{\sphinxupquote{SetTime}} method:
We call the appropriate method to update the individual
\sphinxcode{\sphinxupquote{RolloverCounter}} instances.

\item {} 
\sphinxAtStartPar
Now go back to the second constructor.  This is not really necessary:
With the first constructor the calling code could just have one more
\sphinxcode{\sphinxupquote{SetTime}} line any time you want to
to create a clock with a time other than midnight.
We can make a case for
this being so common, that we want to do it in just one line,
with a constructor that sets a specified time.
However, the main excuse was really to illustrate that
constructors can be \sphinxstyleemphasis{overloaded}, like methods:  You can have separate
constructors with distinct signatures.
In this case versions with no parameters vs. two \sphinxcode{\sphinxupquote{int}} parameters.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Tick}} method has a bit of logic to it:  while the minutes always
advance, the hours only advance when the minutes roll over to 0.

\item {} 
\sphinxAtStartPar
Finally the \sphinxcode{\sphinxupquote{GetTimeString}} method illustrates a new integer string
formatting mode:  The D2 format specifier applies to an integer, and displays it
as a minimum of 2 digits, padding on the left with 0’s as necessary.
This is just what we want here.  In general the 2 could be replaced by another
literal integer, so D6 would force at least 6 digits:  With the D6 format
specifier 12 would be formatted as 000012,
and the longer 1234567 would add no extra 0’s: still 1234567.

\end{enumerate}

\sphinxAtStartPar
The code for all the classes is in project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clock}{clock}.

\sphinxAtStartPar
Admittedly, with this exact functionality and such a concise line to
advance a count, it would actually have shorter to have done everything
inside the \sphinxcode{\sphinxupquote{Clock}} class, with no \sphinxcode{\sphinxupquote{RolloverCounter}}, but we were looking
for a simple illustration of combining user\sphinxhyphen{}defined types this way,
and a \sphinxcode{\sphinxupquote{RolloverCounter}} is a clear unified
concept that can be used in other situations.  See an upcoming exercise.


\subsubsection{Alternate Clock Constructor Exercise}
\label{\detokenize{classes/classexamples:alternate-clock-constructor-exercise}}
\sphinxAtStartPar
Make a small change to \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clock/clock\_demo.cs}{clock/clock\_demo.cs}, so the second
constructor is tested.


\subsubsection{Clock With Seconds Exercise}
\label{\detokenize{classes/classexamples:clock-with-seconds-exercise}}
\sphinxAtStartPar
Modify the project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clock}{clock}, assuming the Tick is for each second, and
the time also show the seconds, like 55 seconds before midnight would be
23:59:05.

\index{model\sphinxhyphen{}view\sphinxhyphen{}controller pattern@\spxentry{model\sphinxhyphen{}view\sphinxhyphen{}controller pattern}}\ignorespaces 

\subsubsection{Twelve Hour Time Exercise}
\label{\detokenize{classes/classexamples:twelve-hour-time-exercise}}\label{\detokenize{classes/classexamples:index-6}}
\sphinxAtStartPar
Modify the project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/clock}{clock} so a \sphinxcode{\sphinxupquote{GetTimeString12}} method returns
the 12 hour time with AM or PM, like 11:05PM or 3:45AM. (The hours do
not have a leading 0 in this format.)
This could be done modifying a lot of things:
keeping the actual hours and minutes that you will display
and remembering AM or PM (with the hours
being more complicated, not starting at 0).  We suggest something else instead:

\sphinxAtStartPar
This is a good place to note a very useful pattern for programming, called
\sphinxstyleemphasis{model\sphinxhyphen{}view\sphinxhyphen{}controller}.  The \sphinxstyleemphasis{model} is the way chosen to store the state internally.
The \sphinxstyleemphasis{controller} has the logic to modify the model as it needs to evolve.
A \sphinxstyleemphasis{view} of a part of
the model is something shown to the user that
does not need to be in the exact same form as the model itself:
A view just needs to be something that can be \sphinxstyleemphasis{easily calculated}
from the model, and presumably is desired by the user.

\sphinxAtStartPar
In this case a simple (and already coded!) way to store and control
the time model data
is the minutes and up to 23 hours that do happen to directly correspond
to the 24 hour clock view.

\sphinxAtStartPar
The main control is to advance the time,
and with just two 0\sphinxhyphen{}based counts we have the
very simple remainder formulas.

\sphinxAtStartPar
So the suggestion is to keep the \sphinxstyleemphasis{internal} data the same way as before.
Just in the method to create the desire 12\sphinxhyphen{}hour view have the logic to do the
\sphinxstyleemphasis{conversion} of the internal 24\sphinxhyphen{}hour model data.

\sphinxAtStartPar
You could leave in the method to provide the time in the
24 hour format, giving the \sphinxcode{\sphinxupquote{Clock}} class user the option to use either view
of the shared model data.
To be symmetrical in the naming,
you might change the original name \sphinxcode{\sphinxupquote{GetTimeString}} to
\sphinxcode{\sphinxupquote{GetTimeString24}}.

\sphinxstepscope

\index{class@\spxentry{class}!Rational@\spxentry{Rational}}\index{Rational class@\spxentry{Rational class}}\ignorespaces 

\section{The Rational Class}
\label{\detokenize{classes/rational:the-rational-class}}\label{\detokenize{classes/rational:rational}}\label{\detokenize{classes/rational:index-0}}\label{\detokenize{classes/rational::doc}}
\sphinxAtStartPar
Like other numbers, we think of a rational number as a unit,
but all rational numbers can be most easily represented as a fraction,
a ratio of two integers. We can create a class Rational, so

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would create a new Rational number for the mathematical expression, 2/3.

\sphinxAtStartPar
Our previous simple class examples have mostly been ways of
collecting related data, with limited methods beyond getters and setters.
Rational numbers also have lots of obvious operations defined on them.
Our Rational example we will use most of the concepts for object so far,
and add a few more, to provide a rich practical class
with a variety of methods.

\sphinxAtStartPar
Thinking ahead to what we would like for our rational numbers, here is
some testing code.  Hopefully the method names are clear and reasonable.
in the illustration
we operate on a single rational number, and do calculation with a pair,
and parse string literals.  The code is from
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_rational/test\_rational.cs}{test\_rational/test\_rational.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{TestRational}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}6/(\PYGZhy{}10) simplifies to \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}reciprocal of \PYGZob{}0\PYGZcb{} is \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Reciprocal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} negated is \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Negate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{h}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} + \PYGZob{}1\PYGZcb{} is \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZhy{} \PYGZob{}1\PYGZcb{} is \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Subtract}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} * \PYGZob{}1\PYGZcb{} is \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Multiply}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}(\PYGZob{}0\PYGZcb{}) / (\PYGZob{}1\PYGZcb{}) is \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{Divide}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} \PYGZgt{} \PYGZob{}1\PYGZcb{} ? \PYGZob{}2\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{h}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} as a double is \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{ToDouble}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{} as a decimal is \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{h}\PYG{p}{.}\PYG{n}{ToDecimal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{k}{new}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}\PYGZhy{}12/30\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}123\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}1.125\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Parse \PYGZbs{}\PYGZdq{}\PYGZob{}0\PYGZcb{}\PYGZbs{}\PYGZdq{} to Rational: \PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                              }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
One non\sphinxhyphen{}obvious method is \sphinxcode{\sphinxupquote{CompareTo}}.  This one method allows
all the usual comparison operators to be used with the result.
We will discuss it more in {\hyperref[\detokenize{interfaces/fractions-revisited:rationals-revisited}]{\sphinxcrossref{\DUrole{std,std-ref}{Rationals Revisited}}}}.

\sphinxAtStartPar
The results we would like when running this testing code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
6/(\PYGZhy{}10) simplifies to \PYGZhy{}3/5
reciprocal of \PYGZhy{}3/5 is \PYGZhy{}5/3
\PYGZhy{}3/5 negated is 3/5
\PYGZhy{}3/5 + 1/2 is \PYGZhy{}1/10
\PYGZhy{}3/5 \PYGZhy{} 1/2 is \PYGZhy{}11/10
\PYGZhy{}3/5 * 1/2 is \PYGZhy{}3/10
(\PYGZhy{}3/5) / (1/2) is \PYGZhy{}6/5
1/2 \PYGZgt{} \PYGZhy{}3/5 ? true
\PYGZhy{}3/5 as a double is \PYGZhy{}0.6
1/2 as a decimal is 0.5
Parse \PYGZdq{}\PYGZhy{}12/30\PYGZdq{} to Rational: \PYGZhy{}2/5
Parse \PYGZdq{}123\PYGZdq{} to Rational: 123
Parse \PYGZdq{}1.125\PYGZdq{} to Rational: 9/8
\end{sphinxVerbatim}

\sphinxAtStartPar
A Rational has a numerator and a denominator.  We must remember that data.
Each individual Rational that we use will have its own numerator and
denominator, which we store as the instance variables
(and which we abbreviate since we are lazy):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Rational}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{;}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{// ...}
\end{sphinxVerbatim}

\sphinxAtStartPar
We could have a very simple constructor that just copies in values for
the numerator and denominator.  However, there is an extra wrinkle with
rational numbers:  They can be represented many ways.  You remember from
grade school being told to “reduce to lowest terms”.  This will keep
our internal representations unique, and use the smallest numbers.

\sphinxAtStartPar
Intermediate operations and initial constructor parameters
will not always be in lowest terms.  To reduce to lowest terms
we need to divide the original numerator and denominator by their
{\hyperref[\detokenize{while/gcdexamples:gcd}]{\sphinxcrossref{\DUrole{std,std-ref}{Greatest Common Divisor}}}}.    We include a \sphinxstyleemphasis{static} GCD method taken from that section,
and make the adjustment to lowest terms in a helping method, \sphinxcode{\sphinxupquote{Normalize}},
that is called by the constructor:

\index{private@\spxentry{private}!helping method@\spxentry{helping method}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{classes/rational:index-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Force the invarient: in lowest terms with a positive denominator.}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Normalize}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// We *should* force an Exception, but we won\PYGZsq{}t.}
\PYG{+w}{            }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Zero denominator changed to 1!\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GCD}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{/=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{         }\PYG{c+c1}{// lowest}
\PYG{+w}{         }\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{/=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{       }\PYG{c+c1}{//    terms}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// make denom positive}
\PYG{+w}{            }\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{denom}\PYG{p}{;}\PYG{c+c1}{//   double negation:}
\PYG{+w}{            }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{num}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{//   same mathematical value}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are several things to note about this method:
\begin{itemize}
\item {} 
\sphinxAtStartPar
It is \sphinxstyleemphasis{private}.
It is only used as a helping method, called from inside of Rational.  It
is not a part of the public interface used from other classes.

\item {} 
\sphinxAtStartPar
We need to deal with a 0 denominator somehow.  We should be causing an
\sphinxstyleemphasis{exception}, but that is an advanced topic, so we wimp out and just
change the denominator to 1.

\item {} 
\sphinxAtStartPar
There is one other technical issue in getting a unique representation:  The
denominator could start off being negative.
If that is the case, we change the sign of
both the numerator and denominator, so we always end up with a positive
denominator.  We will use this fact in several places.

\item {} 
\sphinxAtStartPar
It calls a static method of the class, \sphinxcode{\sphinxupquote{GCD}}.  Classes can have both
instance and static methods.  It is fine for an instance method like
\sphinxcode{\sphinxupquote{Normalize}} to call a static method:  The instance variables cannot be
accessed.  Here \sphinxcode{\sphinxupquote{GCD}} is passed all its data explicitly through
its parameters.

\end{itemize}

\sphinxAtStartPar
The complete constructor, using \sphinxcode{\sphinxupquote{Normalize}}, is below.
Note that by the time we
are done constructing a new Rational, it is in this normalized form:  lowest
terms and positive denominator:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Create a fraction given numerator and denominator.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{numerator}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{denominator}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{numerator}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{denominator}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Normalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The call to the \sphinxcode{\sphinxupquote{Normalize}} method is another place where we have a
call without dot notation, since it
is acting on the same object as for the constructor.

\sphinxAtStartPar
We mentioned that instance method \sphinxcode{\sphinxupquote{Normalize}} calls static method \sphinxcode{\sphinxupquote{GCD}},
and this is fine.  The reverse is not true:

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Inside a \sphinxcode{\sphinxupquote{static}} method there
is \sphinxstyleemphasis{no} current object.  A common compiler error is caused when you
try to have a static method call
an instance method without dot notation for a specific object.
The shorthand notation
without an explicit object reference and dot cannot be used, because
there is no
current object to reference implicitly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{AnInstanceMethod}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}

\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{AStaticMethod}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{// no current object}
\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{n}{AnInstanceMethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// COMPILER ERROR CAUSED}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
On the other hand, there is no issue when
an instance method calls a static method.  (The instance variables are just
inaccessible inside the static method.)
\end{sphinxadmonition}

\sphinxAtStartPar
The Rational class has the usual getter methods, to access the
obvious parts of its state:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetNumerator}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetDenominator}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We certainly want to be able to display a Rational as a string version:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a string of the fraction in lowest terms,}
\PYG{+w}{      }\PYG{c+c1}{/// omitting the denominator if it is 1.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZob{}0\PYGZcb{}/\PYGZob{}1\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{o}{+}\PYG{n}{num}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we simplify so you would see “3” rather than “3/1”.  This is also
a place where the normalization to have a positive denominator comes in:
a negative Rational will always have a leading “\sphinxhyphen{}” as in “\sphinxhyphen{}5/9” rather than
“5/\sphinxhyphen{}9”

\sphinxAtStartPar
With a Rational, several other conversions make sense:  to \sphinxcode{\sphinxupquote{double}}
and \sphinxcode{\sphinxupquote{decimal}} approximations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a double approximation to the fraction.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{ToDouble}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{num}\PYG{p}{)}\PYG{o}{/}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Return a decimal approximation to the fraction.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{decimal}\PYG{+w}{ }\PYG{n+nf}{ToDecimal}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{decimal}\PYG{p}{)}\PYG{n}{num}\PYG{p}{)}\PYG{o}{/}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
So far we have returned built\sphinxhyphen{}in types.  What if we wanted to generate
the reciprocal of a Rational?  That would be another Rational.  It is
legal to return the type of the class that you are defining!
How do we make a new Rational?
We have a constructor!  We can easily use it.  The reciprocal
swaps the numerator and denominator.  It is also easy to negate
a Rational:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a new Rational which is the reciprocal of this Rational.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n+nf}{Reciprocal}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{n}{denom}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Return a new Rational which is this Rational negated.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n+nf}{Negate}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Static methods are still useful.
For example, in analogy with the other numeric types
we may want a static \sphinxcode{\sphinxupquote{Parse}} method
to act on a string parameter and return a new Rational.

\sphinxAtStartPar
The most obvious kind of string to parse would be one like \sphinxcode{\sphinxupquote{"2/3"}} or \sphinxcode{\sphinxupquote{"\sphinxhyphen{}10/77"}},
which we can split at the \sphinxcode{\sphinxupquote{\textquotesingle{}/\textquotesingle{}}}.
Integers are also rational numbers, so we would like to parse \sphinxcode{\sphinxupquote{"123"}}.
Finally decimal strings can be converted to rational numbers,
so we would like to parse \sphinxcode{\sphinxupquote{"123.45"}}.

\sphinxAtStartPar
See how our \sphinxcode{\sphinxupquote{Parse}} method below distinguishes and handles
all the cases.  It constructs integer strings,
\sphinxcode{\sphinxupquote{parts{[}0{]}}} and \sphinxcode{\sphinxupquote{parts{[}1{]}}}, for both the numerator and denominator,
and then parses the integers.  Note that the method \sphinxstyleemphasis{is} \sphinxcode{\sphinxupquote{static}}.
There is no Rational
being referred to when it starts, but in this case the method \sphinxstyleemphasis{returns} one.

\sphinxAtStartPar
That last case is the trickiest.  For example \sphinxcode{\sphinxupquote{"123.45"}} becomes 12345/100
(before being reduced to lowest terms).
Note that there were originally \sphinxstyleemphasis{two} digits after the decimal point
and then the denominator gets \sphinxstyleemphasis{two} zeroes to have the right power of 10:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Parse a string of an integer, fraction (with /) or decimal (with .)}
\PYG{+w}{      }\PYG{c+c1}{///  and return the corresponding Rational.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n+nf}{Parse}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{// will adjust numerator and denominator parts}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{parts}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// for an int string, this is correct}
\PYG{+w}{         }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{     }\PYG{c+c1}{// otherwise correct num, denom parts}
\PYG{+w}{            }\PYG{n}{parts}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Split}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}/\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{intFrac}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{Split}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}.\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// integer, fractional digits}
\PYG{+w}{            }\PYG{n}{parts}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{intFrac}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{intFrac}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// \PYGZdq{}shift\PYGZdq{} decimal point}
\PYG{+w}{            }\PYG{n}{parts}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{p}{;}\PYG{+w}{                 }\PYG{c+c1}{// denom will have as many 0\PYGZsq{}s}
\PYG{+w}{            }\PYG{k}{foreach}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{dig}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{intFrac}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{//    as digits after \PYGZsq{}.\PYGZsq{}}
\PYG{+w}{               }\PYG{n}{parts}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{p}{;}\PYG{+w}{                 }\PYG{c+c1}{//    to compensate}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{parts}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                             }\PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{parts}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Method Parameters of the Same Type}
\label{\detokenize{classes/rational:method-parameters-of-the-same-type}}
\sphinxAtStartPar
We can deal with the current object without using dot notation.  What if we are
dealing with \sphinxstyleemphasis{more than one} Rational, the current one \sphinxstyleemphasis{and} another one,
like the parameter in Multiply:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a new Rational which is the product of this Rational and f.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n+nf}{Multiply}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can mix the shorthand notation for the current object’s fields
and dot notation for another
\sphinxstyleemphasis{named} object:  \sphinxcode{\sphinxupquote{num}} and \sphinxcode{\sphinxupquote{denom}} refer to the fields in the \sphinxstyleemphasis{current} object, and
\sphinxcode{\sphinxupquote{f.num}} and \sphinxcode{\sphinxupquote{f.denom}} refer to fields for the other
\sphinxcode{\sphinxupquote{Rational}}, the parameter \sphinxcode{\sphinxupquote{f}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a new Rational which is the product of this Rational and f.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n+nf}{Multiply}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// end Multiply heading chunk}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{n}{num}\PYG{o}{*}\PYG{n}{f}\PYG{p}{.}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{denom}\PYG{o}{*}\PYG{n}{f}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We do not refer to the fields of \sphinxcode{\sphinxupquote{f}} through the public methods
\sphinxcode{\sphinxupquote{GetNumerator}} and \sphinxcode{\sphinxupquote{GetDenominator}}.
Though \sphinxcode{\sphinxupquote{f}} is not the same \sphinxstyleemphasis{object}, it is the same \sphinxstyleemphasis{type}:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Private members of \sphinxstyleemphasis{another} object of the \sphinxstyleemphasis{same} type are
accessible from method definitions in the class.
\end{sphinxadmonition}

\sphinxAtStartPar
There are a number of other arithmetic methods in the source code for Rational
that return a new Rational result of the arithmetic operation.  They \sphinxstyleemphasis{do} review
your knowledge of arithmetic! They do \sphinxstyleemphasis{not} add further C\# syntax.

\sphinxAtStartPar
The whole code for Rational is in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/rational\_nunit/rational.cs}{rational\_nunit/rational.cs}.
The testing code we started with, in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/test\_rational/test\_rational.cs}{test\_rational/test\_rational.cs}
uses all the methods.  We will see more advance ways to test Rational
in {\hyperref[\detokenize{testing/testing:testing}]{\sphinxcrossref{\DUrole{std,std-ref}{Testing}}}}.

\sphinxAtStartPar
There is also a more convenient version of Rational,
using advanced concepts, in {\hyperref[\detokenize{classes/overload-op:defining-operators}]{\sphinxcrossref{\DUrole{std,std-ref}{Defining Operators (Optional)}}}}.


\subsection{Pictorial Playing Computer}
\label{\detokenize{classes/rational:pictorial-playing-computer}}
\sphinxAtStartPar
Let us start pictorially playing computer on \sphinxcode{\sphinxupquote{test\_rational.cs}},
as a review of much of the previous sections.  We explicitly show a local variable
\sphinxcode{\sphinxupquote{this}} to identify the current object in an instance method or constructor.

\sphinxAtStartPar
The first line of \sphinxcode{\sphinxupquote{Main}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
creates a new Rational, so it calls the constructor.  At the very beginning of the
constructor, a prototype \sphinxcode{\sphinxupquote{Rational}} is already created as the current object,
so immediately, there is a \sphinxcode{\sphinxupquote{this}}.
The parameters 6, and \sphinxhyphen{}10 are passed, initializing the explicit local
variables \sphinxcode{\sphinxupquote{numerator}} and \sphinxcode{\sphinxupquote{denominator}}.
The figure illustrates the memory state at the beginning of the constructor call:

\noindent\sphinxincludegraphics[width=124bp]{{callConstructor}.png}

\sphinxAtStartPar
Note the immediate value assigned to the numeric instance variables is zero:  This is
as discussed in {\hyperref[\detokenize{arrays/onedim:default-fields}]{\sphinxcrossref{\DUrole{std,std-ref}{Default Initializations}}}}.
Of course we do not want to keep those default values:
The constructor finds the value of the local variable \sphinxcode{\sphinxupquote{numerator}}, and needs to
assign the value 6 to a variable \sphinxcode{\sphinxupquote{num}}.  The compiler has looked
first for a local variable \sphinxcode{\sphinxupquote{num}}, and found none.
Then it looked \sphinxstyleemphasis{second} for an instance variable in the object pointed to
by \sphinxcode{\sphinxupquote{this}}.  It found \sphinxcode{\sphinxupquote{num}} there.  Now it copies the 6 into that location.
Similarly for \sphinxcode{\sphinxupquote{denominator}} and \sphinxcode{\sphinxupquote{denom}}:

\noindent\sphinxincludegraphics[width=124bp]{{callConstructorCopied}.png}

\sphinxAtStartPar
Then the constructor calls \sphinxcode{\sphinxupquote{Normalize}}.
Since \sphinxcode{\sphinxupquote{Normalize}} is also an instance method,
a reference to \sphinxcode{\sphinxupquote{this}} is passed implicitly.
While illustrating the memory state for more than one active method,
we separate each one with a horizontal segment.

\noindent\sphinxincludegraphics[width=124bp]{{callNormalize}.png}

\sphinxAtStartPar
Later \sphinxcode{\sphinxupquote{Normalize}} calls \sphinxcode{\sphinxupquote{GCD}}.  Since \sphinxcode{\sphinxupquote{GCD}} is static, note that the local
variables for \sphinxcode{\sphinxupquote{GCD}} do \sphinxstyleemphasis{not} contain a reference to \sphinxcode{\sphinxupquote{this}}.

\noindent\sphinxincludegraphics[width=124bp]{{callGCD}.png}

\sphinxAtStartPar
At the end of \sphinxcode{\sphinxupquote{GCD}} the \sphinxcode{\sphinxupquote{int}} 2 is returned and initializes
\sphinxcode{\sphinxupquote{n}} in the calling method \sphinxcode{\sphinxupquote{Normalize}}.
Then \sphinxcode{\sphinxupquote{Normalize}} modifies the instance variable pointed to by \sphinxcode{\sphinxupquote{this}},
and finishes.

\noindent\sphinxincludegraphics[width=124bp]{{finishNormalize}.png}

\sphinxAtStartPar
That is the same object \sphinxcode{\sphinxupquote{this}} in the constructor.
Just before the constructor completes we have:

\noindent\sphinxincludegraphics[width=124bp]{{finishConstructor}.png}

\sphinxAtStartPar
Then in \sphinxcode{\sphinxupquote{Main}} the constructor’s \sphinxcode{\sphinxupquote{this}} is the reference to the new object
initializing \sphinxcode{\sphinxupquote{f}}.

\noindent\sphinxincludegraphics[width=120bp]{{setF}.png}

\sphinxAtStartPar
Consider the next line of \sphinxcode{\sphinxupquote{Main}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}6/(\PYGZhy{}10) simplifies to \PYGZob{}0\PYGZcb{}\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We omit the internals of the WriteLine call, except to note that it must convert
the reference \sphinxcode{\sphinxupquote{f}} to a string.  As with any object,
it does this by calling the \sphinxcode{\sphinxupquote{ToString}} method for \sphinxcode{\sphinxupquote{f}},
so the implicit \sphinxcode{\sphinxupquote{this}} in the call to \sphinxcode{\sphinxupquote{ToString}} refers to the same object as \sphinxcode{\sphinxupquote{f}}:

\noindent\sphinxincludegraphics[width=196.5bp]{{callToString}.png}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ToString}} returns “\sphinxhyphen{}3/5”, and it gets printed as part of the line generated
by \sphinxcode{\sphinxupquote{WriteLine}}….

\sphinxAtStartPar
We skip the similar details through two more \sphinxcode{\sphinxupquote{WriteLine}} statements and the
initialization of \sphinxcode{\sphinxupquote{h}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{h}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{WriteLine}}
statement after that needs to evaluate \sphinxcode{\sphinxupquote{f.Add(h)}}, generating a call to \sphinxcode{\sphinxupquote{Add}}.
The next figure shows the two local variables in \sphinxcode{\sphinxupquote{Main}}, \sphinxcode{\sphinxupquote{f}} and \sphinxcode{\sphinxupquote{h}}, each
pointing to a \sphinxcode{\sphinxupquote{Rational}} object.  The image shows the situation
in the call to \sphinxcode{\sphinxupquote{Add}}, just before the end of the return statement,
when the new Rational is being constructed.

\sphinxAtStartPar
In the local variables for the method \sphinxcode{\sphinxupquote{Add}}
see what the implicit \sphinxcode{\sphinxupquote{this}} refers to, and what the
(local to \sphinxcode{\sphinxupquote{Add}}) variable \sphinxcode{\sphinxupquote{f}} refer to.  As the figure shows,
this use of a local variable
\sphinxcode{\sphinxupquote{f}} is independent of the \sphinxcode{\sphinxupquote{f}} in \sphinxcode{\sphinxupquote{Main}}:

\noindent\sphinxincludegraphics[width=132bp]{{callAdd}.png}

\sphinxAtStartPar
Since the return statement in \sphinxcode{\sphinxupquote{Add}} creates a new object,
the figure shows  a call to the
constructor from inside \sphinxcode{\sphinxupquote{Add}}.  We do not go through the details of another
constructor call, but
\sphinxcode{\sphinxupquote{this}} in the constructor points to the Rational shown and returned by
\sphinxcode{\sphinxupquote{Add}}:

\noindent\sphinxincludegraphics[width=132bp]{{endAdd}.png}

\sphinxAtStartPar
which gets sent to the \sphinxcode{\sphinxupquote{WriteLine}} statement
and gets printed in \sphinxcode{\sphinxupquote{Main}} as in the earlier code.

\sphinxAtStartPar
Make sure you see how the pictures reinforce these important ideas:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Keeping track of the \sphinxcode{\sphinxupquote{this}} with
constructors and instance methods (but not static methods).

\item {} 
\sphinxAtStartPar
The aliasing of \sphinxcode{\sphinxupquote{Rational}} objects used as parameters explicitly or
implicitly (\sphinxcode{\sphinxupquote{this}}).

\end{itemize}

\sphinxAtStartPar
We have played computer before in procedural programming,
following individually explicitly named
variables.  This has allowed us to follow loops clearly after the code is
written.  The pictorial version with multiple object references and method calls
is also useful for checking on code that is written with many object
references.

\sphinxAtStartPar
When first \sphinxstyleemphasis{writing} code with object references that you are manipulating,
a picture of the setup
showing the references in your data is also helpful.
New object\sphinxhyphen{}oriented programmers often have a hard time referring to the
data they want to work with.
If you have a picture of the data relationships
you can point with a finger to a part that you want to use.
For example
in the call to \sphinxcode{\sphinxupquote{Add}}, one piece of data you need for your arithmetic is
the \sphinxcode{\sphinxupquote{num}} field in \sphinxcode{\sphinxupquote{f}}.  Then you must be carful to note
that \sphinxstyleemphasis{only local variables can be referenced directly}
(including the implicit \sphinxcode{\sphinxupquote{this}}).   If you want to refer to data that is not a local
variable, you must follow the reference path arrow that leads \sphinxstyleemphasis{from a local variable} to
an instance field that you want to reference.

\noindent\sphinxincludegraphics[width=132bp]{{pathToNum}.png}

\sphinxAtStartPar
Then use the proper object\sphinxhyphen{}oriented notation to refer to the path.
In the example, it takes one step,
from local variable \sphinxcode{\sphinxupquote{f}} to its field \sphinxcode{\sphinxupquote{num}}, referred to as \sphinxcode{\sphinxupquote{f.num}}.
Similarly the current object’s \sphinxcode{\sphinxupquote{num}} is connected through \sphinxcode{\sphinxupquote{this}}, but C\# shorthand
allows \sphinxcode{\sphinxupquote{this.}} to be omitted.  And so on, for \sphinxcode{\sphinxupquote{f.denom}} and \sphinxcode{\sphinxupquote{denom}}.

\sphinxAtStartPar
Visually following such paths will be even more important later, when we construct
more complex types of objects, and you need to follow
a path through \sphinxstyleemphasis{several} references in sequence.

\index{exercise@\spxentry{exercise}!ForceMatch@\spxentry{ForceMatch}}\ignorespaces 

\subsection{ForceMatch Exercise}
\label{\detokenize{classes/rational:forcematch-exercise}}\label{\detokenize{classes/rational:index-2}}
\sphinxAtStartPar
Suppose we have a class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Pair}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{;}

\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Pair}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k}{this}\PYG{p}{.}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{this}\PYG{p}{.}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{c+c1}{///Mutate the parameter so its instance variables match this object}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ForceMatch}\PYG{p}{(}\PYG{n}{Pair}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{// need code ...}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}(\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{})\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A test would be code in another class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Pair}\PYG{+w}{ }\PYG{n}{first}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Pair}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Pair}\PYG{+w}{ }\PYG{n}{second}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Pair}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{9}\PYG{p}{)}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// prints (1, 9)}
\PYG{n}{first}\PYG{p}{.}\PYG{n}{ForceMatch}\PYG{p}{(}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// prints (3, 7)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Would this code work?  If not, explain why not:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ForceMatch}\PYG{p}{(}\PYG{n}{Pair}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Pair}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you do not see it,
do a graphical play\sphinxhyphen{}computer like in the last section.

\item {} 
\sphinxAtStartPar
Complete the body of \sphinxcode{\sphinxupquote{ForceMatch}} correctly.

\end{enumerate}

\sphinxstepscope

\index{class@\spxentry{class}!plan classes and methods@\spxentry{plan classes and methods}}\index{plan problem split into classes@\spxentry{plan problem split into classes}}\ignorespaces 

\section{Planning A Class Structure}
\label{\detokenize{classes/planning_classes:planning-a-class-structure}}\label{\detokenize{classes/planning_classes:plan-classes}}\label{\detokenize{classes/planning_classes:index-0}}\label{\detokenize{classes/planning_classes::doc}}
\sphinxAtStartPar
The Console input/output interchange below illustrates
an idea for a skeleton of a text (adventure?) game.
It could be the basis of a later group project. It does not
have much in it yet, but it can be planned in terms of classes.
Classes with instances correspond to nouns you would be using,
particularly nouns used in more than one place with different
state data being remembered.
Verbs associated with nouns you use tend to be methods.
Think how you might break this down, looking at what is happening
in the sequence below.

\sphinxAtStartPar
The parts appearing after the ‘\textgreater{}’ prompt are entries by the user.
Other lines are computer responses:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Welcome to Loyola!
This is a pretty boring game, unless you modify it.
Type \PYGZsq{}help\PYGZsq{} if you need help.

You are outside the main entrance of the university that prepares people for
extraordinary lives.  It would help to be prepared now....
Exits: east south west
\PYGZgt{} help
You are lost. You are alone.
You wander around at the university.

Your command words are:
   help go quit

Enter
        help command
for help on the command.
\PYGZgt{} help go
Enter
        go direction
to exit the current place in the specified direction.
The direction should be in the list of exits for the current place.
\PYGZgt{} go west
You are in the campus pub.
Exits: east
\PYGZgt{} go east
You are outside the main entrance of the university that prepares people for
extraordinary lives.  It would help to be prepared now....
Exits: east south west
\PYGZgt{} go south
You are in a computing lab.
Exits: north east
\PYGZgt{} go east
You are in the computing admin office.
Exits: west
\PYGZgt{} bye
I don\PYGZsq{}t know what you mean...
\PYGZgt{} quit
Do you really want to quit? yes
Thank you for playing.  Good bye.
\end{sphinxVerbatim}

\sphinxAtStartPar
Think and discuss how to organize things first….

\sphinxAtStartPar
The different parts of a multi\sphinxhyphen{}class project interact through their public methods.
Remember the two roles of writer and consumer.  The consumer needs good documentation
of how to use (not implement) these methods.  These methods that allow the
interaction between classes provide the \sphinxstyleemphasis{interface} between classes.  Unfortunately
“interface” is used in more than one way.  Here it means publicly specified ways
for different parts to interact.

\sphinxAtStartPar
As you think how to break this game into parts (classes),
also think how the parts interact (public methods).
This is a good place for the start of a class discussion.

\sphinxAtStartPar
If the plan is to discuss it in class, \sphinxstyleemphasis{wait} before looking at
the code that generated the exchange above, in the
project folder \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/cs\_project1}{cs\_project1}.

\sphinxAtStartPar
The code uses many of the topics discussed so far in this book.

\sphinxAtStartPar
We will add some features from another meaning of {\hyperref[\detokenize{interfaces/interfaces:interface}]{\sphinxcrossref{\DUrole{std,std-ref}{Interfaces}}}},
and discuss the revision in project
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/csproject\_stub}{csproject\_stub} (no 1).  You \sphinxstyleemphasis{might} use this version
as a basis of a project.

\sphinxstepscope

\index{value type@\spxentry{value type}}\index{reference object@\spxentry{reference object}}\index{struct@\spxentry{struct}}\ignorespaces 

\section{Classes And Structs}
\label{\detokenize{classes/classes-and-structs:classes-and-structs}}\label{\detokenize{classes/classes-and-structs:structs-and-classes}}\label{\detokenize{classes/classes-and-structs:index-0}}\label{\detokenize{classes/classes-and-structs::doc}}
\sphinxAtStartPar
C\# has an alternate syntax to a class: a \sphinxstyleemphasis{struct}.
Everything we have said so far about classes such an \sphinxcode{\sphinxupquote{Rational}} applies to
structs also!  In fact you could change \sphinxcode{\sphinxupquote{class}} into \sphinxcode{\sphinxupquote{struct}} in the heading for
Rational, and it would become a \sphinxcode{\sphinxupquote{struct}}, with no further code changes in any of the
code we have written!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{Rational}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
So why the distinction?  We have mentioned that new objects created in a class are
accessed indirectly via a reference, as with an array.  As a general category,
they are called \sphinxstyleemphasis{reference objects}.  We distinguished the types \sphinxcode{\sphinxupquote{int}} and
\sphinxcode{\sphinxupquote{double}} and \sphinxcode{\sphinxupquote{bool}}, where the actual value of the data is stored in the space
for a variable of the type.  They are \sphinxstyleemphasis{value types}.  A struct is also a value
type.  In practice this is efficient for small objects of a fixed size.
We made Rational a class because
you have already seen the class construct with
\sphinxcode{\sphinxupquote{static}} entries, and classes are more generally useful.
In fact being a \sphinxcode{\sphinxupquote{struct}} would be a good choice for Rational,
since it only contains two integers.  Its size is no more than one \sphinxcode{\sphinxupquote{double}}.

\sphinxAtStartPar
The behavior of a Rational is the same either way, because it is immutable.  If we
allowed mutating methods, then a class version and a struct version would not behave
the same way, due to the fact the reference types can have aliases,
and value types cannot.

\sphinxAtStartPar
There are some more complicated situations where there are further distinctions between
classes and structs, but we shall not concern ourselves
with those fine advanced points in this book.

\sphinxstepscope


\section{Defining Operators (Optional)}
\label{\detokenize{classes/overload-op:defining-operators-optional}}\label{\detokenize{classes/overload-op:defining-operators}}\label{\detokenize{classes/overload-op::doc}}
\index{operator@\spxentry{operator}!overload in user class@\spxentry{overload in user class}}\index{overloading@\spxentry{overloading}!operators@\spxentry{operators}}\ignorespaces 

\subsection{Operator Overloading}
\label{\detokenize{classes/overload-op:operator-overloading}}\label{\detokenize{classes/overload-op:overloading-operators}}\label{\detokenize{classes/overload-op:index-0}}
\sphinxAtStartPar
The Rational class is a fine example of a useful utility class.
Still, to an experienced user, it has a striking deficiency:
A Rational is a \sphinxstyleemphasis{number} and we are used to doing arithmetic with
standard operators.  We would like to replace the mouthful
\sphinxcode{\sphinxupquote{frac1.Multiply(frac2)}} by our common symbolism for multiplication,
\sphinxcode{\sphinxupquote{frac1*frac2}}.  This can be coded in C\#, using \sphinxstyleemphasis{operator overloading} to
give new meanings to the operator \sphinxcode{\sphinxupquote{*}}.  The C\# syntax is illustrated in the
variant of the Rational class in
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/rational\_ops\_stub/rational.cs}{rational\_ops\_stub/rational.cs}.  This class also contains code
discussed in the
next section, {\hyperref[\detokenize{classes/overload-op:casts-in-user-classes}]{\sphinxcrossref{\DUrole{std,std-ref}{Casts in User\sphinxhyphen{}Defined Classes}}}}.
Here are operator overload declarations for \sphinxcode{\sphinxupquote{*}} and others:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// * binary multiplication operator}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{n}{f1}\PYG{p}{.}\PYG{n}{num}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{.}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{.}\PYG{n}{denom}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// \PYGZhy{} unary negation operator}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// binary == operator}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{==}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{.}\PYG{n}{num}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{.}\PYG{n}{num}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{.}\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// binary != operator}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{Boolean}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{!=}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{.}\PYG{n}{num}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{.}\PYG{n}{num}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{.}\PYG{n}{denom}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{c+c1}{// or extra call, but clearly consistent: return !(f1 == f2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
All operator overload headings have the special form
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{public static}} \sphinxstyleemphasis{returnType} \sphinxcode{\sphinxupquote{operator}} opSymbol \sphinxcode{\sphinxupquote{(}} \sphinxstyleemphasis{parameters} \sphinxcode{\sphinxupquote{)}}
\end{quote}

\sphinxAtStartPar
Here opSymbol can be any arithmetic or comparison operator, or
some other operators that we have not discussed.  So something like
\sphinxcode{\sphinxupquote{operator *}} or \sphinxcode{\sphinxupquote{operator \sphinxhyphen{}}} replaces the method name.
Binary operations like multiplication require two operands, and hence the
method has two parameters.
The method
computes and returns the named return type in the normal fashion.
In general
at least one of the parameters must be of the type of the class being defined.

\sphinxAtStartPar
(We could have directly defined four further overloads of \sphinxcode{\sphinxupquote{*}},
with the first or second parameter
being an \sphinxcode{\sphinxupquote{int}} or a \sphinxcode{\sphinxupquote{double}}, but we will avoid that by also adding methods
to provide implicit {\hyperref[\detokenize{classes/overload-op:casts-in-user-classes}]{\sphinxcrossref{\DUrole{std,std-ref}{Casts in User\sphinxhyphen{}Defined Classes}}}}.)

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} symbol is special, since it can be used either as a unary operator for
negation, or as a binary operator for subtraction.  Since we include only
one parameter above, we are defining the unary version.

\sphinxAtStartPar
The operator does not need to produce a result of the same type.  We
included \sphinxcode{\sphinxupquote{==}} and \sphinxcode{\sphinxupquote{!=}} as examples (returning a \sphinxcode{\sphinxupquote{Boolean}}).

\sphinxAtStartPar
(These methods
do not cause compiler errors, but warnings are generated:
We have not added further more advanced
overrides of Equals and HashCode methods, that are ideally in sync with
the meaning of \sphinxcode{\sphinxupquote{==}}.  You should see a discussion of these methods in a
data structures course, like Loyola’s Comp 271.)

\sphinxAtStartPar
The class is a stub,
and {\hyperref[\detokenize{classes/overload-op:overloading-operator-exercise}]{\sphinxcrossref{\DUrole{std,std-ref}{Operator Overloading Exercise}}}}
invites you to add further operator overloads.

\index{precedence@\spxentry{precedence}!with operator overloading@\spxentry{with operator overloading}}\index{operator@\spxentry{operator}!precedence with overloading@\spxentry{precedence with overloading}}\ignorespaces 
\sphinxAtStartPar
\sphinxstylestrong{Precedence}:  Note that the operator overloading method definitions include
nothing about {\hyperref[\detokenize{appendix/precedence:precedence}]{\sphinxcrossref{\DUrole{std,std-ref}{Precedence of Operators}}}}. That is because the precedence of operators
is fixed across the whole language. Unary \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} has higher
precedence than \sphinxcode{\sphinxupquote{*}} … no matter what the types involved.

\sphinxAtStartPar
An example testing class also uses the new casting syntax of next section:

\index{operator@\spxentry{operator}!casts in user class@\spxentry{casts in user class}}\index{casts in user\sphinxhyphen{}defined classes@\spxentry{casts in user\sphinxhyphen{}defined classes}}\index{implicit casts in user\sphinxhyphen{}defined classes@\spxentry{implicit casts in user\sphinxhyphen{}defined classes}}\ignorespaces 

\subsection{Casts in User\sphinxhyphen{}Defined Classes}
\label{\detokenize{classes/overload-op:casts-in-user-defined-classes}}\label{\detokenize{classes/overload-op:casts-in-user-classes}}\label{\detokenize{classes/overload-op:index-2}}
\sphinxAtStartPar
We have discussed casts before.  We know that an \sphinxcode{\sphinxupquote{int}} can also be represented
as a \sphinxcode{\sphinxupquote{double}} with an integer value, and the cast from \sphinxcode{\sphinxupquote{int}} to \sphinxcode{\sphinxupquote{double}}
is done implicitly
when needed:  An expression like \sphinxcode{\sphinxupquote{3.2 * 2}} is processed by the compiler,
\sphinxstyleemphasis{implicitly} casting the
2 to \sphinxcode{\sphinxupquote{double}} 2.0, and then doing a \sphinxcode{\sphinxupquote{double}} multiplication.
The same idea makes sense with an
\sphinxcode{\sphinxupquote{int}} \sphinxcode{\sphinxupquote{n}} and a Rational \sphinxcode{\sphinxupquote{f}}.  We only defined the operator overload \sphinxcode{\sphinxupquote{*}}
for two Rationals, so in our code so far, \sphinxcode{\sphinxupquote{f * n}} does not make sense.
Mathematically an integer is rational, so mathematically, it should make sense.
We bridge this difference by defining an implicit cast of an \sphinxcode{\sphinxupquote{int}} to a Rational,
so  the compiler will take \sphinxcode{\sphinxupquote{f * n}} and see the need to implicitly cast
\sphinxcode{\sphinxupquote{n}} to a Rational.  The definition below will also allow explicit casts
if you choose, like \sphinxcode{\sphinxupquote{f * (Rational) n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Code to cast an int to a Rational implicitly when needed.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{implicit}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Rational}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again it is
the heading that takes a special form, starting with
\sphinxcode{\sphinxupquote{public static implicit operator}} followed by the type being cast to,
like Rational, while the parameter is the starting type, like \sphinxcode{\sphinxupquote{int}}.
This is not like a regular method with its return type and method name.
Here it looks something like a constructor with a type in place of a method
name, but a constructor would not start with \sphinxcode{\sphinxupquote{static implicit operator}}!

\sphinxAtStartPar
Now consider a \sphinxcode{\sphinxupquote{double}} \sphinxcode{\sphinxupquote{d}} and a Rational \sphinxcode{\sphinxupquote{f}}.
We would like to allow an expression like
\sphinxcode{\sphinxupquote{d * f}}.
Again, the operator overload for \sphinxcode{\sphinxupquote{*}} does not allow this directly, so consider
implicit casts:  Since
a \sphinxcode{\sphinxupquote{double}} is only an approximation, in general,
it would not be wise to implicitly convert
a \sphinxcode{\sphinxupquote{double}} to a Rational, but it does make sense to approximate a Rational
by a \sphinxcode{\sphinxupquote{double}} before use with a \sphinxcode{\sphinxupquote{double}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Code to cast to a double implicitly when needed.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{implicit}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{n+nf}{double}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{f}\PYG{p}{.}\PYG{n}{num}\PYG{o}{/}\PYG{n}{f}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The general format of such an implicit cast in a user\sphinxhyphen{}defined class is:
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{public static implicit operator}} \sphinxstyleemphasis{resultType} \sphinxcode{\sphinxupquote{(}} \sphinxstyleemphasis{sourceType} \sphinxstyleemphasis{paramName} \sphinxcode{\sphinxupquote{)}}
\end{quote}

\sphinxAtStartPar
One of the two types should be the type of the containing class.
We have illustrated both combinations.

\sphinxAtStartPar
Finally, you need to be \sphinxstyleemphasis{very careful where you declare implicit casts}, to
make sure you are not being overly general, and maybe allowing
trouble in a form that may be very hard to debug:
It is much harder to foresee and trace implicit actions than explicit actions.
You are
\sphinxstyleemphasis{safe}, but more \sphinxstyleemphasis{verbose}, if you \sphinxstyleemphasis{only allow explicit} casts.  For example,
we have already seen these required for a cast from \sphinxcode{\sphinxupquote{double}} to \sphinxcode{\sphinxupquote{int}}.
To only allow an explicit cast with your type,
replace \sphinxcode{\sphinxupquote{implicit}} by \sphinxcode{\sphinxupquote{explicit}} in the cast method heading.

\index{decimal type@\spxentry{decimal type}}\index{type@\spxentry{type}!decimal@\spxentry{decimal}}\index{explicit casts in user\sphinxhyphen{}defined classes@\spxentry{explicit casts in user\sphinxhyphen{}defined classes}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{classes/overload-op:decimal-type}}\label{\detokenize{classes/overload-op:index-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Code to cast to a decimal with an explicit cast.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{explicit}\PYG{+w}{ }\PYG{k}{operator}\PYG{+w}{ }\PYG{n+nf}{decimal}\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{decimal}\PYG{p}{)}\PYG{n}{f}\PYG{p}{.}\PYG{n}{num}\PYG{o}{/}\PYG{n}{f}\PYG{p}{.}\PYG{n}{denom}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{The decimal type}:  Though we have not used the
\sphinxcode{\sphinxupquote{decimal}} type before, we use it here for contrast to illustrate a cast
from Rational to \sphinxcode{\sphinxupquote{decimal}} that can only be used explicitly, as in
\sphinxcode{\sphinxupquote{(decimal) f}}:

\sphinxAtStartPar
Example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/rational\_ops\_stub/test\_ops.cs}{rational\_ops\_stub/test\_ops.cs} tests all of the operator overloads
and casts shown for a Rational.  Look at the source code and run it.
Note where overloaded operators are used and where implicit and explicit casts
to or from a Rational are used.

\sphinxAtStartPar
The example also illustrates a special feature
of the \sphinxcode{\sphinxupquote{decimal}} type.  While a \sphinxcode{\sphinxupquote{double}} is encoded with a power of 2, so
0.1 is \sphinxstyleemphasis{not} stored accurately, a \sphinxcode{\sphinxupquote{decimal}} is encoded with a power of 10, so
exact decimal values with up to 28 digits can be stored and manipulated.
(This is important for \sphinxstyleemphasis{monetary calculations}, so a \sphinxcode{\sphinxupquote{decimal}} literal
has \sphinxstylestrong{m} for money appended, like  \sphinxcode{\sphinxupquote{5.99m}}, representing the mathematical
quantity 5.99 \sphinxstyleemphasis{exactly}.)

\index{exercise@\spxentry{exercise}!overloading operators@\spxentry{overloading operators}}\index{overloading@\spxentry{overloading}!exercise for operators@\spxentry{exercise for operators}}\ignorespaces 

\subsubsection{Operator Overloading Exercise}
\label{\detokenize{classes/overload-op:operator-overloading-exercise}}\label{\detokenize{classes/overload-op:overloading-operator-exercise}}\label{\detokenize{classes/overload-op:index-4}}
\sphinxAtStartPar
The classes discussed above from example project
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/rational\_ops\_stub}{rational\_ops\_stub}
are incomplete.  Add the
overloaded binary operators  /, +, \sphinxhyphen{}, \textless{}, \textgreater{}, \textless{}= and \textgreater{}= to the Rational class,
and extend the TestOps class to test them.

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{classes/reviewclasses:chapter-review-questions}}\label{\detokenize{classes/reviewclasses::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Where in a class are instance variables declared?

\item {} 
\sphinxAtStartPar
For most instance variables, what is the modifier used that does not
appear at the beginning of a local variable declaration?

\item {} 
\sphinxAtStartPar
What is the lifetime of an instance variable:
When does it come into existence, and how long does it last?

\item {} 
\sphinxAtStartPar
Why do we generally make an instance variable \sphinxcode{\sphinxupquote{private}}?

\item {} 
\sphinxAtStartPar
In what code can an instance variable be seen and used?

\item {} 
\sphinxAtStartPar
Must instance variables and methods always be preceded by
an explicit object reference and \sphinxcode{\sphinxupquote{.}}?

\item {} 
\sphinxAtStartPar
Can we refer to an instance variable in a part of the code
where there is no current object?

\item {} 
\sphinxAtStartPar
In what kind of method in a class definition are instance variables never
accessible?

\item {} 
\sphinxAtStartPar
What is the purpose of a constructor?

\item {} 
\sphinxAtStartPar
How is the heading of a constructor different from a regular method?

\item {} 
\sphinxAtStartPar
How are parameters to a constructor generally used?

\item {} 
\sphinxAtStartPar
If you do not explicitly assign a value to an instance variable in a
constructor, does the instance variable have a value?

\item {} 
\sphinxAtStartPar
If we want users to be able to see the value of a private instance variable
from outside of the class, how do we do it?

\item {} 
\sphinxAtStartPar
What is the general name of the category of methods that return
instance state values?

\item {} 
\sphinxAtStartPar
Instance variables are usually visible from inside instance methods for
the class.  What is the exception?  In the exceptional case, what is
the workaround to allow access to the instance variable?

\item {} 
\sphinxAtStartPar
Sometimes you need to refer explicitly to the current object.  How
do you do it?

\item {} 
\sphinxAtStartPar
Sometimes you want to let users outside the class modify the value
of a private instance variable.  How do you do it?

\item {} 
\sphinxAtStartPar
What is the general name of the category of public methods whose sole purpose
is to set a part of instance state to a new specified value?

\item {} 
\sphinxAtStartPar
If a class has one or more setter methods, is the object type
immutable?

\item {} 
\sphinxAtStartPar
What is the return type for a setter method?

\item {} 
\sphinxAtStartPar
If you want to set an instance variable in a method, should you declare
that instance variable in the method?

\item {} 
\sphinxAtStartPar
A method with what signature allows you to control how the string
concatenation operate (\sphinxcode{\sphinxupquote{+}}) generates a string from the object?

\item {} 
\sphinxAtStartPar
If you write an override the \sphinxcode{\sphinxupquote{ToString}} method in a class, should the method
print the string?   If not, what should it do with the resulting string?

\item {} 
\sphinxAtStartPar
What is \sphinxcode{\sphinxupquote{this}}?

\item {} 
\sphinxAtStartPar
Can aliased objects cause problems when created for an immutable object?
Mutable object?

\item {} 
\sphinxAtStartPar
In a class with instance methods you can always design the class so variables
are instance variables and not local variables.  When should you
use local variables instead?

\item {} 
\sphinxAtStartPar
If an instance method has a formal parameter of the same type as the
class being defined,
can you refer to a private instance variable in the parameter object?
May you change it?
How do you distinguish an instance variable for the current object from the
corresponding instance variable for the parameter object?

\end{enumerate}

\sphinxstepscope

\index{testing@\spxentry{testing}}\ignorespaces 

\chapter{Testing}
\label{\detokenize{testing/testing:testing}}\label{\detokenize{testing/testing:index-0}}\label{\detokenize{testing/testing:id1}}\label{\detokenize{testing/testing::doc}}
\sphinxAtStartPar
Now that we have learned a bit about classes, we’re going to use the same feature
to support \sphinxstyleemphasis{unit testing}. Unit testing is a concept that will become part of just
about everything you do in future programming\sphinxhyphen{}focused courses, so we want to make sure
that you understand the idea and begin to make use of it in all of your work.

\sphinxAtStartPar
The notion of unit testing is straightforward in principle. When you write a program
in general, the program comprises what are properly known as units of development.
Each language has its own definition of what units are but most modern programming
languages view the \sphinxstyleemphasis{class} concept as the core unit of testing. Once we have a class,
we can test it and all of the parts associated with it, especially its methods.

\sphinxAtStartPar
We will be introducing parts of file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/rational\_nunit/rational\_unit\_tests.cs}{rational\_nunit/rational\_unit\_tests.cs}.

\index{testing@\spxentry{testing}!assertion@\spxentry{assertion}}\index{assertion testing@\spxentry{assertion testing}}\ignorespaces 

\section{Assertions}
\label{\detokenize{testing/testing:assertions}}\label{\detokenize{testing/testing:index-1}}
\sphinxAtStartPar
A key notion of testing is the ability to make a logical assertion about something
that generally must hold \sphinxstyleemphasis{true} if the test is to pass.

\sphinxAtStartPar
Assertions are not a standard language feature in C\#. Instead, there are a number of
classes that provide functions for assertion handling. In the framework we are using for
unit testing (NUnit), a class named Assert supports assertion testing.

\sphinxAtStartPar
In our tests, we make use of an assertion method, \sphinxcode{\sphinxupquote{Assert.IsTrue()}} to determine
whether an assertion is successful. If the variable or expression passed to this
method is \sphinxstyleemphasis{false}, the assertion fails.

\sphinxAtStartPar
Here are some examples of assertions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Assert.IsTrue(true)}}: The assertion is trivially successful,
because the boolean value \sphinxcode{\sphinxupquote{true}} is true.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Assert.IsTrue(false)}}: The assertion is not successful, because the boolean value
\sphinxcode{\sphinxupquote{false}} is not true!

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Assert.IsFalse(false)}}: This assertion is successful, because
\sphinxcode{\sphinxupquote{false}} is, of course, false.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Assert.IsTrue(5 \textgreater{} 0)}}: Success

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Assert.IsTrue(0 \textgreater{} 5)}}: Failure

\end{itemize}

\sphinxAtStartPar
There are many available assertion methods. In our tests, we use \sphinxcode{\sphinxupquote{Assert.IsTrue()}},
which works for everything we want to test. Other assertion methods do their magic
rather similarly, because every assertion method ultimately must determine whether
what is being tested is true or false.

\index{attribute {[} {]}@\spxentry{attribute {[} {]}}}\index{{[} {]}@\spxentry{{[} {]}}!attribute@\spxentry{attribute}}\ignorespaces 

\section{Attributes}
\label{\detokenize{testing/testing:attributes}}\label{\detokenize{testing/testing:index-2}}
\sphinxAtStartPar
Besides assertions, a building block of testing (in C\# and beyond) comes in the form
of attributes. Attributes are an additional piece of information that can be attached
to classes, variables, and methods in C\#. There are two attributes of interest to us:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}TestFixture{]}: This indicates that a class is being used for testing purposes.

\item {} 
\sphinxAtStartPar
{[}Test{]}: This indicates that a method is one of the methods in a class being used
for testing purposes.

\end{itemize}

\sphinxAtStartPar
Without these annotations, classes and methods will \sphinxstyleemphasis{not} be used for testing purposes.
This allows a class to have some methods that are used for testing while other methods
are ignored.

\sphinxAtStartPar
In the remainder of this section, we’re going to take a look at the strategy for testing
the Rational class. In general, your goal is to ensure that the entire class is tested.
It is easier said than done. In later courses (Software Engineering) you would learn about
strategies for \sphinxstyleemphasis{coverage} testing.

\sphinxAtStartPar
Our strategy will be as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Test the constructor and make sure the \sphinxstyleemphasis{representation} of the rational number is
sound. If the constructor isn’t initializing an instance properly, it is likely
that little else in the class will work properly.

\item {} 
\sphinxAtStartPar
Then test the rest of the class. Whenever possible, group the tests in some logical
way. In the case of the Rational class, there are three general categories (and one
rather special one): arithmetic operations, comparisons, and conversions. In addition,
there is the parsing test, which ensures that we can convert strings representing
fractions into properly initialized (and reduced) rational numbers.

\end{itemize}

\sphinxAtStartPar
Let’s get started.


\section{Testing the Constructor}
\label{\detokenize{testing/testing:testing-the-constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{      }\PYG{n+na}{[Test()]}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ConstructorTest}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetNumerator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetDenominator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetNumerator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetDenominator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetNumerator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetDenominator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{125}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetNumerator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{125}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetDenominator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Testing the constructor is fairly straightforward. We essentially test three basic
cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Test whether a basic rational number can be constructed. In the above, we test for
3/5, 3/\sphinxhyphen{}5, 6/10, and 125. Per the implementation of the Rational class (how we defined
it), these should result in fractions with numerators of 3, \sphinxhyphen{}3, 3, and 12; and denominators
of 5, 5, 5, and 1, respectively.

\item {} 
\sphinxAtStartPar
As you can observe from the code, we perform basic assertion testing to ensure that
the numerators and denominators are what we expect. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{GetNumerator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Tests whether the newly minted rational number, Rational(3, 5), actually has the
expected numerator of 3.

\item {} 
\sphinxAtStartPar
If we are able to get through the entire code of the \sphinxcode{\sphinxupquote{ConstructorTest()}} method,
our constructor test is a success. Otherwise, it is a failure.

\end{itemize}

\sphinxAtStartPar
We’ll look at how to actually run our tests in a bit but let’s continue taking a look
at how the rest of our testing is done.


\section{Testing Rational Comparisons}
\label{\detokenize{testing/testing:testing-rational-comparisons}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{      }\PYG{n+na}{[Test()]}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{BasicComparisonTests}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{r3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is pretty well established by now that the ability to compare is of fundamental importance
whenever we are talking about data. Everything we do, especially when it comes to searching
(finding a value) and sorting (putting values in order) depends on comparison.

\sphinxAtStartPar
In this test, we construct a few Rational instances (r1, r2, and r3) and perform at least
one test for each of the essential operators (\textgreater{}, \textless{}, and =). Recall from our earlier discussion
of the Rational class that the CompareTo method return a value \sphinxcode{\sphinxupquote{\textless{} 0}}
when one Rational is \sphinxstyleemphasis{less than} another. It returns a number
\sphinxcode{\sphinxupquote{\textgreater{} 0}} for \sphinxstyleemphasis{greater than}, and \sphinxcode{\sphinxupquote{== 0}} for \sphinxstyleemphasis{equal to}.

\sphinxAtStartPar
If any one of these comparisons fails, this means that we cannot rely on the ability to
compare Rational numbers. This will likely prevent other tests from working, such as the
arithmetic tests, which rely on the ability to test whether a \sphinxstyleemphasis{computed result} matches
an \sphinxstyleemphasis{expected result} (e.g. 1/4 + 2/4 == 3/4).


\section{Testing Rational Arithmetic}
\label{\detokenize{testing/testing:testing-rational-arithmetic}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{      }\PYG{n+na}{[Test()]}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{BasicArithmeticTests}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r2}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{47}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{11}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{36}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Subtract}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{58}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Multiply}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{47}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{11}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Divide}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{47}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{11}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Reciprocal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{64}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{47}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Negate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{47}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Testing of arithmetic is a fairly straightforward idea. For all of these tests, we
create a couple of rational numbers (47/64 and \sphinxhyphen{}11/64) and then call the various methods
to perform addition, subtraction, multiplication, division, reciprocal, and negation.

\sphinxAtStartPar
The key to testing arithmetic successfully in the case of a Rational number is to know
know what the result \sphinxstyleemphasis{should be}. As a concrete example, the result of adding these
two rational numbers should be 36/64. So the testing strategy is to use the \sphinxcode{\sphinxupquote{Add()}}
method to add the two rational numbers and then test whether the result of the addition
is equal to the \sphinxstyleemphasis{known} answer of 36/64.

\sphinxAtStartPar
As you can observe by looking at the code, the magic occurs by checking whether the
\sphinxstyleemphasis{computed} result matches the \sphinxstyleemphasis{constructed} result:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{36}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{64}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Because we have \sphinxstyleemphasis{separately} tested the constructor and comparison methods, we can
assume that it is ok to rely upon comparison methods as part of this arithmetic test.

\sphinxAtStartPar
And it is in this example where we begin to see the \sphinxstyleemphasis{art of testing}. You can write
tests that assume that other tests of features you are using have \sphinxstyleemphasis{already passed}. In the
event that your assumption is wrong, you’d be able to know that this is the case, because
all of the tests you assumed to pass would not have passed.

\sphinxAtStartPar
Again, to be clear, the arithmetic tests we have done here \sphinxstyleemphasis{assume} that we can rely on
the constructor and the comparison operation to determine equality of two rational numbers.
It is entirely possible that this is not true, so we’ll be able to determine this when
examining the test output (we’d see that not only the arithmetic test fails but possibly the
constructor and/or comparison tests as well).

\sphinxAtStartPar
The remaining tests are fairly straightforward. We’ll more or less present them as is with
minimal explanation as they are in many ways variations on the theme.


\section{Testing Rational Conversions (to other types)}
\label{\detokenize{testing/testing:testing-rational-conversions-to-other-types}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{      }\PYG{n+na}{[Test()]}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ConversionTests}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{ToDecimal}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0.5}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{ToDecimal}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{0.5}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{ToDouble}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0.5}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//.5 is stored exactly}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{ToDouble}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{ToString}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZhy{}1/2\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{r3}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZhy{}5\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//implicit use of ToString}

\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this test, we want to make sure that Rational objects can be converted to floating point
and decimal types (the built\sphinxhyphen{}in types of the C\# language).

\sphinxAtStartPar
For example, Rational(3/6) is 1/2, which is 0.5 (both in its floating\sphinxhyphen{}point and decimal
representations.


\section{Testing the Parsing Feature}
\label{\detokenize{testing/testing:testing-the-parsing-feature}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{      }\PYG{n+na}{[Test()]}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{ParseTest}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZhy{}12/30\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{12}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{30}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}123\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{123}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}1.125\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{8}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Assert}\PYG{p}{.}\PYG{n}{IsTrue}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{ToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Equals}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}9/8\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parsing test tests whether we can convert the string representation of a rational number
into an actual (reduced) rational number. We test three general cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The ability to take a fraction and convert it into a rational number. This fraction may
or may not have a “\sphinxhyphen{}” sign in it. For example \sphinxhyphen{}12/30 should be equivalent to constructing
a Rational(\sphinxhyphen{}12, 30).

\item {} 
\sphinxAtStartPar
The ability to take a whole number and get a proper Rational, e.g. 123 is equal to
Rational(123)

\item {} 
\sphinxAtStartPar
The ability to take a textual representation (1.125) and get a proper Rational(9, 8)
representation. In this case, we are also getting an extra test to ensure the result
is reduced.

\end{itemize}

\index{Xamarin Studio@\spxentry{Xamarin Studio}!running NUnit tests@\spxentry{running NUnit tests}}\index{testing@\spxentry{testing}!running in Xamarin Studio@\spxentry{running in Xamarin Studio}}\ignorespaces 

\section{Running the NUnit Tests}
\label{\detokenize{testing/testing:running-the-nunit-tests}}\label{\detokenize{testing/testing:running-nunit-tests}}\label{\detokenize{testing/testing:index-3}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In Xamarin Studio, select the rational\_nunit project.

\item {} 
\sphinxAtStartPar
In the main Xamarin Studio menu click “Run” and select “Run Unit Tests”

\end{enumerate}

\sphinxAtStartPar
A test pad should appear and show something like

\noindent\sphinxincludegraphics[width=350bp]{{NUnitTestXamarinInit}.png}

\sphinxAtStartPar
This likely just shows the overall results in the summary line at the bottom.
You can show details by clicking on one or more of headings at the
top of the pad.  In particular, if you click Successful Test, Failed Tests,
and Output (and likely drag the top of the pad to make
it large enough to see everything), you should see something like

\noindent\sphinxincludegraphics[width=350bp]{{NUnitTestXamarinDetails}.png}

\sphinxAtStartPar
As you can see in the above displays, all of the tests in \sphinxcode{\sphinxupquote{RationalTests}}
get executed, and they all pass.
There are no failed tests to see,
but that part would be the most important details if any were there!
The output just details the sequence of execution.

\sphinxAtStartPar
Xamarin Studio remembers the headings selected, so next time you run tests,
the same details will show.

\sphinxAtStartPar
The testing file is using NUnit.Framework.  There is a little more to this.
If you edit the references, selecting All sources, and entering nunit
in the search box, you see

\noindent\sphinxincludegraphics[width=350bp]{{NUnitReferencesXamarin}.png}

\sphinxAtStartPar
Note there are more than one version of nunit.framework. On a Mac,
the selected version worked directly, but the logical looking one, provided
by Xamarin, did \sphinxstyleemphasis{not} work directly.  Either worked if we select the context
menu in the Solutions pad for the nunit.framework version added to the references,
and make it look like

\noindent\sphinxincludegraphics[width=200bp]{{NUnitNotSpecificVersion}.png}

\sphinxAtStartPar
with the “Require Specific Version” item toggled so it is \sphinxstyleemphasis{not} checked.

\sphinxAtStartPar
We waited until now to discuss unit testing, because the test classes are coded with
\sphinxstyleemphasis{instance} methods,
unlike the static methods that we started out with.

\sphinxAtStartPar
A test can also call \sphinxcode{\sphinxupquote{Main}} of a program, with specified parameters that
would normally come from the command line.  See the small project
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/cmdline\_to\_file}{cmdline\_to\_file}.

\index{String Replace NUnit Exercise@\spxentry{String Replace NUnit Exercise}}\index{exercise@\spxentry{exercise}!String Replace NUnit@\spxentry{String Replace NUnit}}\ignorespaces 

\subsection{String Replace NUnit Test Exercise}
\label{\detokenize{testing/testing:string-replace-nunit-test-exercise}}\label{\detokenize{testing/testing:index-4}}
\sphinxAtStartPar
If you completed the program from the stub
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/string\_manip\_stub/string\_manip.cs}{string\_manip\_stub/string\_manip.cs},
then add a testing class using NUnit that tests \sphinxcode{\sphinxupquote{ReplaceFirst}}
with the same parameters as used in the original file’s \sphinxcode{\sphinxupquote{Main}}.
If you did the elaboration of \sphinxcode{\sphinxupquote{ReplaceFirst}} that just returns the original
string when the target is not found, then add tests for that, too.
Remember the necessary library reference and try it out.

\index{Grade File NUnit Exercise\textquotesingle{}@\spxentry{Grade File NUnit Exercise\textquotesingle{}}}\index{exercise@\spxentry{exercise}!Grade File NUnit test@\spxentry{Grade File NUnit test}}\ignorespaces 

\subsection{Grade File NUnit Test Exercise}
\label{\detokenize{testing/testing:grade-file-nunit-test-exercise}}\label{\detokenize{testing/testing:index-5}}
\sphinxAtStartPar
Add a testing class using NUnit to {\hyperref[\detokenize{appendix/hw-gradefiles:hw-gradefiles}]{\sphinxcrossref{\DUrole{std,std-ref}{Homework: Grade File}}}}.
Remember the necessary library reference.
Sample data files and files for testing the results
are included in the project.  Just test
using command line parameters (so there is no Console input).
Test with both comp170 and comp150.

\sphinxstepscope

\index{interface@\spxentry{interface}}\ignorespaces 

\chapter{Interfaces}
\label{\detokenize{interfaces/interfaces:interfaces}}\label{\detokenize{interfaces/interfaces:interface}}\label{\detokenize{interfaces/interfaces:index-0}}\label{\detokenize{interfaces/interfaces::doc}}
\sphinxstepscope

\index{IComparable Interface@\spxentry{IComparable Interface}}\index{interface@\spxentry{interface}!IComparable@\spxentry{IComparable}}\ignorespaces 

\section{Rationals Revisited}
\label{\detokenize{interfaces/fractions-revisited:rationals-revisited}}\label{\detokenize{interfaces/fractions-revisited:index-0}}\label{\detokenize{interfaces/fractions-revisited:id1}}\label{\detokenize{interfaces/fractions-revisited::doc}}
\sphinxAtStartPar
C\# has a built\sphinxhyphen{}in method to sort a List.  \sphinxcode{\sphinxupquote{List}} is a
generic type, however, so how does C\# know how to do
comparisons for all different types?  Is this
specially programmed in for built\sphinxhyphen{}in types, or
can it be extended to user\sphinxhyphen{}defined types?

\sphinxAtStartPar
In fact it can be extended to user defined types,
such as our Rational.
To sort objects, you only need to be able to do one
thing: indicate which object comes before another.
We can do that.  The \sphinxcode{\sphinxupquote{CompareTo}} method
already does that.  If Rational r1 is less than
Rational r2, then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r1}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
The single CompareTo method is very versatile:  Just by varying
the comparison with 0, you vary the corresponding
comparison of Rationals:

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) \textless{} 0}} means r1 \textless{} r2
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) \textless{}= 0}} means r1 \textless{}= r2
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) \textgreater{} 0}} means r1  \textgreater{} r2
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) \textgreater{}= 0}} means r1 \textgreater{}= r2
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) == 0}} means r1 is equal to r2
\item[] \sphinxcode{\sphinxupquote{r1.CompareTo(r2) != 0}} means r1 is not equal to r2
\end{DUlineblock}

\sphinxAtStartPar
None of the other methods for Rationals make any difference for
sorting:  Just this one method is needed.  Of course the
comparison of strings or doubles are done with
totally different implementations, but they have methods
with the same name, \sphinxcode{\sphinxupquote{CompareTo}}, and with the same abstract
meaning.  Still C\# is strongly typed and we are talking about
totally different types.

\sphinxAtStartPar
An \sphinxstyleemphasis{interface} allows us to group diverse classes under one
interface type.  An interface just focuses on the commonality of behavior
in one or more methods among the different classes.
Interface types, like classes can also be generic.
For sorting we are only concerned
with one method, \sphinxcode{\sphinxupquote{CompareTo}}.  We want it to be able to compare to another
object of the same type.

\sphinxAtStartPar
C\# defines a generic interface \sphinxcode{\sphinxupquote{IComparable\textless{}T\textgreater{}}}.  A type T can satisfy this interface if
if has a public instance method with signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{CompareTo}\PYG{p}{(}\PYG{n}{T}\PYG{+w}{ }\PYG{n}{other}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\index{:@\spxentry{:}!in class heading@\spxentry{in class heading}}\ignorespaces 
\sphinxAtStartPar
There is one more step before we can use a library method to sort:
Although the signature shown above for \sphinxcode{\sphinxupquote{CompareTo}} is the
one that C\# requires to be able to satisfy the \sphinxcode{\sphinxupquote{Icomparable\textless{}T\textgreater{}}} interface,
it does not
automatically assume that this is your \sphinxstyleemphasis{intention}.
You must explicitly say that you \sphinxstyleemphasis{want} your class
to be considered to satisfy this interface.
For instance for Rational, we need to change
the class heading to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Rational}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{IComparable}\PYG{o}{\PYGZlt{}}\PYG{n}{Rational}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general one or more interface names can be listed
after the class name and a colon,
and before the opening brace of the class body.
This particular interface is defined in
System.Collections.Generic, so we need to be using that namespace.

\sphinxAtStartPar
The project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interfaces}{interfaces}
has the modified \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interfaces/rational.cs}{rational.cs}
and \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interfaces/test\_rational\_sort.cs}{test\_rational\_sort.cs}
to test this with a list of Rationals:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.Collections.Generic}\PYG{p}{;}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// Use IComparable\PYGZlt{}Rational\PYGZgt{} interface to sort Rationals.}
\PYG{+w}{   }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{TestRationalSort}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{Main}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{args}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Rational}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Rational}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{11}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Before sorting: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{ListString}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{Sort}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}After sorting:  \PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{ListString}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ListString}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Rational}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Rational}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
which prints:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Before sorting: 1/2 11/3 \PYGZhy{}1/10 2/5 2/3 1/3
After sorting:  \PYGZhy{}1/10 1/3 2/5 1/2 2/3 11/3
\end{sphinxVerbatim}

\index{interface@\spxentry{interface}!hides actual underlying type@\spxentry{hides actual underlying type}}\ignorespaces 
\sphinxAtStartPar
Interfaces are very handy for dealing with the \sphinxstyleemphasis{common} abstract behavior of
different objects and different underlying class, but if an object is
declared to be of interface type the compiler no longer sees the attributes
that are \sphinxstyleemphasis{not} common to the interface.  A silly example, legal as far
as it goes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IComparable}\PYG{o}{\PYGZlt{}}\PYG{n}{Rational}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                      }\PYG{n}{r2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{CompareTo}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// prints false}
\end{sphinxVerbatim}

\sphinxAtStartPar
The declarations are legal because a Rational does have interface type
\sphinxcode{\sphinxupquote{IComparable\textless{}Rational\textgreater{}}}.  The use of \sphinxcode{\sphinxupquote{CompareTo}} is legal
because that is the one method that this interface type guarantees.

\sphinxAtStartPar
However, if we add this extra line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{Multiply}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// compiler error!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Even though r1 and r2 are actually Rational underneath, where the
Multiply method is legal, their declaration as only their interface type
\sphinxstyleemphasis{hides} this extra functionality from the compiler. %
\begin{footnote}[1]\sphinxAtStartFootnote
It is possible to deal with the actual underlying class type, but this gets
more complicated.  It is better discussed in a course that more fully
explores \sphinxstyleemphasis{inheritance}.
%
\end{footnote}

\index{interface@\spxentry{interface}!syntax examples@\spxentry{syntax examples}}\ignorespaces 

\subsection{Interface Syntax Examples}
\label{\detokenize{interfaces/fractions-revisited:interface-syntax-examples}}\label{\detokenize{interfaces/fractions-revisited:index-3}}\label{\detokenize{interfaces/fractions-revisited:id3}}
\sphinxAtStartPar
In the previous section we showed a realistic application of an existing
interface.  It was in a fairly sophisticated class with a lot of other things
included.  Now you can look at examples that are designed to highlight syntax
for interfaces without distractions.  They are very simple and artificial.

\sphinxAtStartPar
There is a comment at the bottom of each file explaining the new
features introduced.  Like all our other examples, they compile and
run as given.  After running an example, see if the notes
include instructions to delete or comment out parts or
uncomment lines.  If so, follow instructions and try to compile again.
Check that the change causes a compiler error.

\sphinxAtStartPar
Look through and process these examples in order:

\sphinxAtStartPar
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax1/interface\_demo1.cs}{interface\_syntax1/interface\_demo1.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax2/interface\_demo2.cs}{interface\_syntax2/interface\_demo2.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax3/interface\_demo3.cs}{interface\_syntax3/interface\_demo3.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax4/interface\_demo4.cs}{interface\_syntax4/interface\_demo4.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax5/interface\_demo5.cs}{interface\_syntax5/interface\_demo5.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax6/interface\_demo6.cs}{interface\_syntax6/interface\_demo6.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax7/interface\_demo7.cs}{interface\_syntax7/interface\_demo7.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/interface\_syntax8/interface\_demo8.cs}{interface\_syntax8/interface\_demo8.cs}

\sphinxAtStartPar
After looking at those simple bare examples illustrating the syntax,
go on to the next section {\hyperref[\detokenize{interfaces/csproj-revisited:csproject-revisited}]{\sphinxcrossref{\DUrole{std,std-ref}{Csproject Revisited}}}},
where a useful, more sophisticated user\sphinxhyphen{}defined interface
is introduced….


\subsubsection{Example Class Sorting \sphinxhyphen{} Worked Exercise}
\label{\detokenize{interfaces/fractions-revisited:example-class-sorting-worked-exercise}}
\sphinxAtStartPar
In {\hyperref[\detokenize{classes/classexamples:more-getters-and-setters}]{\sphinxcrossref{\DUrole{std,std-ref}{More Getters and Setters}}}} we introduced example
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/example\_class/example\_class.cs}{example\_class/example\_class.cs}.

\sphinxAtStartPar
Elaborate the code for the \sphinxcode{\sphinxupquote{Example}} class, adding
a \sphinxcode{\sphinxupquote{CompareTo}} method.
The rules for comparison are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
An object
with a larger \sphinxcode{\sphinxupquote{n}} value is considered larger.

\item {} 
\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{n}}
values are the same, then the object with the larger \sphinxcode{\sphinxupquote{d}}
value is considered larger.

\item {} 
\sphinxAtStartPar
If they completely match, then they are equal, of course.

\end{enumerate}

\sphinxAtStartPar
Modify the \sphinxcode{\sphinxupquote{Main}} driver to merely test sorting:
create and sort a list of \sphinxcode{\sphinxupquote{Example}}
elements.  Show the before and after sequence in the list.

\sphinxAtStartPar
You can compare your solution to ours:
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/example\_class2/example\_class2.cs}{example\_class2/example\_class2.cs}.

\sphinxstepscope


\section{Csproject Revisited}
\label{\detokenize{interfaces/csproj-revisited:csproject-revisited}}\label{\detokenize{interfaces/csproj-revisited:id1}}\label{\detokenize{interfaces/csproj-revisited::doc}}
\sphinxAtStartPar
The \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/cs\_project1}{cs\_project1} project skeleton was set up with the different commands
in different classes, keeping related things together.

\sphinxAtStartPar
On the other hand they had high level structure in common.
Similar names were consciously used for methods:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Each command needed to Execute

\item {} 
\sphinxAtStartPar
Each command needed to have Help for the user.

\end{itemize}

\sphinxAtStartPar
The corresponding names made it somewhat easier to follow
the part of the Game constructor
with the additions to the \sphinxcode{\sphinxupquote{helpDetails}} Dictionary.
Also there is repetitive logic in
the crucial \sphinxcode{\sphinxupquote{proccessCommand}} method.

\sphinxAtStartPar
In a game with more possible commands, the code
would only get more repetitious!
You would like to think of having a loop to replace the
repetitious code.

\sphinxAtStartPar
A major use of a C\# interface will allow this all to work
in neat loops.
For the first time we define our own interface, and
use that interface as a type in a declaration.

\sphinxAtStartPar
While we are at this we can refactor our code further:
classes that give a response to a command all obviously have their
Execute and Help methods.  They also have a command word
to call them.  We can further encapsulate
all data for the response by having the classes themselves
be able to announce the command that calls them.
We add a string property CommandWord to each of them.

\sphinxAtStartPar
We will add an extra convenience feature of C\# here.
Thus far we have used private instance variables and public
getter methods.  We can use a public instance variable declaration
with a similar effect as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{CommandName}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{k}{get}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{private}\PYG{+w}{ }\PYG{k}{set}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The extra syntax in braces says that users in a another class
may freely \sphinxstyleemphasis{get} (read) the variable, but setting the variable is
still \sphinxstyleemphasis{private}: it may only be done inside the class.  This is more
concise than using a getter method:  No getter needs to be declared;
referencing the data is shorter too, since it is a property,
no method parentheses are needed.

\sphinxAtStartPar
Note the unusual syntax: the declaration does
not end with a semicolon.  The only semicolons are inside the braces.
You will not be required to code with this notation, but it surely is neater than
using a getter method!

\sphinxAtStartPar
Now we can define our own interface taking all of these common features
together.  Since each is a response to a command, we will call our interface
Response:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{/// Object that responds to a command}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{interface}\PYG{+w}{ }\PYG{n}{Response}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{/// Execute cmd.}
\PYG{+w}{      }\PYG{c+c1}{/// Return true if the game is over; false otherwise}
\PYG{+w}{      }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{Execute}\PYG{p}{(}\PYG{n}{Command}\PYG{+w}{ }\PYG{n}{cmd}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{/// Return a Help string for the command}
\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{Help}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{CommandName}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{get}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Things to note:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The heading has the reserved word \sphinxcode{\sphinxupquote{interface}} instead of class.

\item {} 
\sphinxAtStartPar
All the common method headings and the property declaration
are listed.

\item {} 
\sphinxAtStartPar
See what is missing!  In place of each method
body is just a semicolon.

\item {} 
\sphinxAtStartPar
Everything in an interface is public.
The part of the property about private access is merely omitted.

\end{itemize}

\sphinxAtStartPar
We are going to need a collection if we want to simplify the code with
loops.  We could use code like the following, assuming we already declared
the objects helper, goer, and quitter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Response}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{resp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{n}{helper}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{goer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{quitter}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See how we use Response as a declaration type!
Each of the objects in the declaration list \sphinxstyleemphasis{is}
in fact a Response.

\sphinxAtStartPar
Now that we can process
with this collection and \sphinxcode{\sphinxupquote{foreach}} loops,
we do not need the object names we gave at all:
We can just put new objects in the initialization sequence!

\sphinxAtStartPar
Now that we can think of these different objects as being of the same type, we can see
the processCommand logic, with its repetitive \sphinxcode{\sphinxupquote{if}} statement syntax is just trying
to match a command word with the proper Response, so a Dictionary is what makes sense!

\sphinxAtStartPar
In fact all the logic for combining the various Responses is now moved into
CommandMapper, and the the CommandMapper constructor creates the Dictionary
used to look up the Response that goes with each command word.  Here is the whole code for
ResponseMapper, taking advantage of the Dictionary in other methods, too.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n+nn}{System.Collections.Generic}\PYG{p}{;}
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{IntroCS}
\PYG{p}{\PYGZob{}}

\PYG{c+c1}{/// Map commands names to commands.}
\PYG{+w}{   }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CommandMapper}
\PYG{+w}{   }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{AllCommands}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{get}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{private}\PYG{+w}{ }\PYG{k}{set}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{k}{private}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Response}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{responses}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//responses to commands}

\PYG{+w}{      }\PYG{c+c1}{/// Initialize the command response mapping}
\PYG{+w}{      }\PYG{c+c1}{///  game The game being played.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{CommandMapper}\PYG{p}{(}\PYG{n}{Game}\PYG{+w}{ }\PYG{n}{game}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{responses}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{Dictionary}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Response}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{Response}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{resp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Quitter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{            }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Goer}\PYG{p}{(}\PYG{n}{game}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{            }\PYG{k}{new}\PYG{+w}{ }\PYG{n+nf}{Helper}\PYG{p}{(}\PYG{n}{responses}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{this}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{// add new Responses here!}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{AllCommands}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{k}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Response}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n}{resp}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{responses}\PYG{p}{[}\PYG{n}{r}\PYG{p}{.}\PYG{n}{CommandName}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{AllCommands}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{CommandName}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{} \PYGZdq{}}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Check whether aString is a valid command word.}
\PYG{+w}{      }\PYG{c+c1}{/// Return true if it is, false if it isn\PYGZsq{}t.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isCommand}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{aString}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{responses}\PYG{p}{.}\PYG{n}{ContainsKey}\PYG{p}{(}\PYG{n}{aString}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{      }\PYG{c+c1}{/// Return the command associated with a command word.}
\PYG{+w}{      }\PYG{c+c1}{///  cmdWord The command word.}
\PYG{+w}{      }\PYG{c+c1}{/// Return the Response for the command.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Response}\PYG{+w}{ }\PYG{n+nf}{getResponse}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{cmdWord}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{responses}\PYG{p}{[}\PYG{n}{cmdWord}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is even more to recommend this setup:  The old setup had references in multiple places
to various details about the collection of Responses.  That made it harder to follow and
definitely harder to update if you want to add a new command.
Now after writing the new class to respond to a new command,  the \sphinxstyleemphasis{only} thing you
need to do is add a new instance of that class to the array initializer in the
CommandMapper constructor!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Interfaces never say anything about constructors.  Classes satisfying
an interface can have totally different constructors.
\end{sphinxadmonition}

\sphinxAtStartPar
In the code above,
\sphinxcode{\sphinxupquote{Quitter}} has a very simple constructor.
(A \sphinxcode{\sphinxupquote{Quitter}} has no individualized data,
and only has an instance because an interface can
only work with an instance, not with a static class.)
On the other hand the \sphinxcode{\sphinxupquote{Goer}} and \sphinxcode{\sphinxupquote{Helper}}
objects need to reference more data to work properly, so they have
parameters.

\sphinxAtStartPar
The revised Xamarin Studio project is \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/csproject\_stub}{csproject\_stub} (no 1 this time).

\sphinxAtStartPar
See how the Game class is simplified, too.

\sphinxAtStartPar
Talking about adding commands \sphinxhyphen{} these classes could be the basis of a game project for
a small group.  Have any ideas?  See {\hyperref[\detokenize{appendix/project:group-project}]{\sphinxcrossref{\DUrole{std,std-ref}{Group Project}}}}.
Note that there is a data file in the project directory.
Make sure your project,
like this stub, sets the Output Path to the project folder.

\sphinxAtStartPar
There are further examples of defining and using Interfaces
in the starting code for the exercises at the end of the next section.

\index{cohesion of code units@\spxentry{cohesion of code units}}\index{coupling of classes@\spxentry{coupling of classes}}\index{separation of concerns among classes@\spxentry{separation of concerns among classes}}\index{class@\spxentry{class}!choosing what parts fit@\spxentry{choosing what parts fit}}\ignorespaces 

\subsection{Cohesion, Coupling, and Separation of Concerns}
\label{\detokenize{interfaces/csproj-revisited:cohesion-coupling-and-separation-of-concerns}}\label{\detokenize{interfaces/csproj-revisited:index-0}}
\sphinxAtStartPar
This section is motivated by the revisions to the project,
not specifically about Interfaces, though good use of them helps.

\sphinxAtStartPar
There are three important ideas in organizing your code into
classes and methods:

\sphinxAtStartPar
\sphinxstyleemphasis{Cohesion} of code is how focused a portion of code is on a unified purpose.
This applies to both individual methods and to a class.  The higher
the cohesion, the easier it is for you to understand a method or
a class.  Also a cohesive method is easy to reuse in combination
with other cohesive methods.  A method that does several things
is not useful to you if you only want to do one of the things later.

\sphinxAtStartPar
\sphinxstyleemphasis{Separation of concerns} allows most things related to a class to take place in the
class where they are easy to track, separated from other classes.
Data most used by one class should probably reside in that class.
Cohesion is related to separation of concerns:  The data and methods most used
by one class should probably reside in that class, so you do not need to go
looking elsewhere for important parts. Also, if you need to change something,
where concerns are separated into cohesive classes, with the data and
logic in one place, it is easier to see what to change, and the changes are likely
to be able to be kept internal to the class,
affecting only its internal implementation, not its public interface.

\sphinxAtStartPar
Some methods are totally related to the connection between classes, and there may not be
a clear candidate for a class to maximize the separation of concerns.  One thing to
look at is the number of references to different classes.  It is likely that the most
referred to class is the one where the method should reside.

\sphinxAtStartPar
\sphinxstyleemphasis{Coupling} is the connections between classes.  If there were no connections
to a class, no public interface,
it would be useless except all by itself.  The must be some coupling between classes,
where one class uses another, but with increased cohesion and strong
separation of concerns you are likely to be able to have
looser coupling.  Limiting coupling makes it easier to follow
your code.  There is less jumping around. More important, it is easier to
modify the code.  There will be less interfacing between classes, so if
you need to change the public interface of a class, there are fewer places
in other classes that need to be changed to keep in sync.

\sphinxAtStartPar
Aim for strong cohesion, clear separation of concerns, and loose coupling.  Together
they make your code clearer, easier to modify, and easier to debug.

\index{exercise@\spxentry{exercise}!igame@\spxentry{igame}}\index{interface@\spxentry{interface}!igame exercise@\spxentry{igame exercise}}\index{igame exercise@\spxentry{igame exercise}}\ignorespaces 

\subsubsection{IGame Interface Exercise}
\label{\detokenize{interfaces/csproj-revisited:igame-interface-exercise}}\label{\detokenize{interfaces/csproj-revisited:index-1}}\label{\detokenize{interfaces/csproj-revisited:id2}}
\sphinxAtStartPar
On a much smaller scale than the project, this exercise offers you
experience
writing classes implementing and using an interface.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Copy project stub \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/igame\_stub}{igame\_stub} to your own project,
and modify it as
discussed below.

\item {} 
\sphinxAtStartPar
Look at the IGame interface in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/igame\_stub/i\_game.cs}{i\_game.cs}.
Then look at \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/igame\_stub/addition\_game.cs}{addition\_game.cs},
that implements the interface. See how a new \sphinxcode{\sphinxupquote{AdditionGame}} can be added to list of
\sphinxcode{\sphinxupquote{IGame}}‘s. Run \sphinxcode{\sphinxupquote{play\_games.cs}}. Randomly choosing a game when there is
only one to choose from is pretty silly, but it gives you a start on a
more elaborate list of games.  The \sphinxcode{\sphinxupquote{PopRandom}} method is a good general
model for choosing, removing, and returning a random element.

\item {} 
\sphinxAtStartPar
Write several very simple classes implementing the IGame interface,
and modify Main in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/igame\_stub/play\_games.cs}{play\_games.cs}
to create and add a new game of each
type. (Test adding one at a time.)

\sphinxAtStartPar
One such game to create with little more work would be a variation on
instance based Guessing Game \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/instance\_version/guess\_game.cs}{instance\_version/guess\_game.cs}.
You need to make slight modifications.
You could make Play return the opposite of the number of guesses,
so more guesses does generate a worse score. Note that you could not use the
original static game version:  Only objects can satisfy an interface.

\end{enumerate}


\subsubsection{Bisection With Function Interface Exercise}
\label{\detokenize{interfaces/csproj-revisited:bisection-with-function-interface-exercise}}\label{\detokenize{interfaces/csproj-revisited:bisection-exercise}}
\sphinxAtStartPar
See \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/bisection\_method/bisection\_method.cs}{bisection\_method/bisection\_method.cs}. Identify the interface.
See how two new classes satisfy the interface, while the rest of the
code in these classes is quite different:  One has an instance variable
and an explicit constructor, while the other does not.
See that the \sphinxcode{\sphinxupquote{Bisection}} function
now has a parameter for an object containing the mathematical function to
use for root finding:  \sphinxcode{\sphinxupquote{Bisection}} is now a generally useful method,
not just tied to one hard\sphinxhyphen{}coded function that might have a root.

\sphinxAtStartPar
Add a new class satisfying the \sphinxcode{\sphinxupquote{Function}} interface; add a test in \sphinxcode{\sphinxupquote{Main}}.
Try a function with multiple roots in the original interval and see what happens.
Then, using \sphinxstyleemphasis{distinct} intervals in different tests,
find different roots of the same function.

\sphinxstepscope


\section{Chapter Review Questions}
\label{\detokenize{interfaces/reviewinterfaces:chapter-review-questions}}\label{\detokenize{interfaces/reviewinterfaces::doc}}
\sphinxAtStartPar
For these review questions, assume \sphinxcode{\sphinxupquote{Foo}} is an interface type that you
have access to.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Suppose you are writing a new class that you want to satisfy
an existing interface:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Is matching the signatures required by the interface enough?

\item {} 
\sphinxAtStartPar
What else do you need in the new class heading?

\end{enumerate}

\item {} 
\sphinxAtStartPar
With interface type \sphinxcode{\sphinxupquote{Foo}} can you:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Declare a formal parameter of type \sphinxcode{\sphinxupquote{Foo}}?

\item {} 
\sphinxAtStartPar
Declare a list of type \sphinxcode{\sphinxupquote{List\textless{}Foo\textgreater{}}}?

\item {} 
\sphinxAtStartPar
Declare an array of type \sphinxcode{\sphinxupquote{Foo{[}{]}}}?

\item {} 
\sphinxAtStartPar
Create a new object with \sphinxcode{\sphinxupquote{new Foo()}}?

\end{enumerate}

\item {} 
\sphinxAtStartPar
If you have an array of type \sphinxcode{\sphinxupquote{Foo{[}{]}}}, then each element is
an object which has an underlying class type.  Must each element
have the \sphinxstyleemphasis{same} underlying class type?

\item {} 
\sphinxAtStartPar
An interface type \sphinxcode{\sphinxupquote{Foo}} has what heading (simplest)?

\item {} 
\sphinxAtStartPar
An interface type definition includes the signatures of all the methods
for that interface.  What is included after each signature?

\item {} 
\sphinxAtStartPar
May an interface definition include a constructor?

\item {} 
\sphinxAtStartPar
May a class satisfying an interface have further methods not listed
in the interface?

\item {} 
\sphinxAtStartPar
Identify the legal interface declarations, and say what is wrong with
any other code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{interface}\PYG{+w}{ }\PYG{n}{A}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{L}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{interface}\PYG{+w}{ }\PYG{n}{B}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{interface}\PYG{+w}{ }\PYG{n}{C}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{interface}\PYG{+w}{ }\PYG{n}{D}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{D}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{E}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Which of these class definitions make the class implement the legal
interface C above?  Explain the problem with any that do not.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CA}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{L}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//  Same as CA, except with heading}
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CB}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{C}
\PYG{c+c1}{// ...}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CC}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{C}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{L}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CD}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{C}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{L}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{CE}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{C}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{private}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{CE}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k}{this}\PYG{p}{.}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{L}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{L}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{h}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{       }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{*}\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxstepscope


\chapter{Recursion}
\label{\detokenize{recursion/recursion:recursion}}\label{\detokenize{recursion/recursion::doc}}
\sphinxAtStartPar
We are looking forward to a data structures course.  Recursion is an important topic.
It is not a topic we require in the introductory course.

\sphinxAtStartPar
More later.

\sphinxstepscope


\chapter{Data Structures}
\label{\detokenize{datastructures/datastructures:data-structures}}\label{\detokenize{datastructures/datastructures::doc}}
\sphinxAtStartPar
We have discussed some basic data structures that are available in C\#:  Array, List,
Set, Dictionary.  There are many more with many implementations.  Further
study leads you into a data structures course.

\sphinxAtStartPar
We may add some optional, forward looking material here.

\sphinxstepscope


\chapter{Appendix}
\label{\detokenize{appendix/appendix:appendix}}\label{\detokenize{appendix/appendix:id1}}\label{\detokenize{appendix/appendix::doc}}
\sphinxstepscope

\index{development tools@\spxentry{development tools}}\ignorespaces 

\section{Development Tools}
\label{\detokenize{appendix/monotools:development-tools}}\label{\detokenize{appendix/monotools:index-0}}\label{\detokenize{appendix/monotools:id1}}\label{\detokenize{appendix/monotools::doc}}

\subsection{About Software Development Kits (SDKs)}
\label{\detokenize{appendix/monotools:about-software-development-kits-sdks}}
\sphinxAtStartPar
A software development kit (SDK) is a set of tools for developing in a
particular programming language (in our class, C\#). Developing in a
language means everything from compiling to running and (when things
go wrong) to debugging programs.

\sphinxAtStartPar
The Microsoft SDK is the proprietary implementation of .Net. It runs
only on Windows and is the primary development framework for all
things Microsoft.

\sphinxAtStartPar
The Mono Project SDK \textless{}\sphinxurl{http://mono-project.com}\textgreater{} is the free/open source
equivalent implementation of the Microsoft SDK.
It runs on all major platforms (including Windows) and is needed in situations
where you want to develop .Net applications on non\sphinxhyphen{}Windows platforms.

\sphinxAtStartPar
As an interesting aside, the company whose developers lead the work on
the Mono SDK are working on commercial tools that allow you to
develop/run applications written in .Net on Apple iOS and Android
mobile devices (phones and tablets).


\subsection{Editing and Building Tools}
\label{\detokenize{appendix/monotools:editing-and-building-tools}}
\sphinxAtStartPar
Early programs were written with rudimentary text editors,
more primitive than Windows Notepad.  Gradually tools got better.
Now there are editors that are highly optimized for editing code.

\sphinxAtStartPar
After code is edited, it has to be converted into an executable program.
That may involve several files and libraries and other dependencies.
Streamlining and automating this process was a big deal.  There
are a variety of building tools that can be used with, or built into
an SDK:  make, ant, and now NAnt for .net.

\sphinxAtStartPar
Many developers use an a la carte approach, using their favorite editor along
with their favorite building tool.


\subsection{About Integrated Development Environments (IDE)}
\label{\detokenize{appendix/monotools:about-integrated-development-environments-ide}}
\sphinxAtStartPar
There are also all\sphinxhyphen{}in\sphinxhyphen{}one tools that combine an editor and build tools.
These are also used by many developers.

\sphinxAtStartPar
There are two major IDEs for .Net development, which we explain briefly below:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Visual Studio is the Microsoft IDE that interfaces directly to the
Microsoft SDK.

\item {} 
\sphinxAtStartPar
Xamarin Studio is the free/open source IDE for developing applications
using the Mono SDK on Windows and all other platforms (in
particular, Linux and OS X).  The project started as MonoDevelop.
Now Xamarin is both a major contributor to the code and has commercial
versions for iOS development.  \sphinxstyleemphasis{The name on the software is now}
\sphinxstylestrong{Xamarin Studio}, though you may see references to MonoDevelop instead.

\end{itemize}

\sphinxAtStartPar
In addition, there is another Windows\sphinxhyphen{}specific IDE, SharpDevelop, that
inspired the creation of Xamarin Studio. It is still actively maintained
and provides a somewhat “lighter weight” alternative to Visual Studio
for Windows users. Like Xamarin Studio, it is aimed at developers who
would prefer a more free/open source “friendly” version.


\subsection{Our Approach}
\label{\detokenize{appendix/monotools:our-approach}}
\sphinxAtStartPar
In the interest of providing a consistent experience for our students who use
various operating systems on their own machines,
we will be using the multi\sphinxhyphen{}platform Mono (the SDK).

\sphinxAtStartPar
We find the IDE Xamarin Studio convenient to integrate everything for a beginner,
and it is a powerful tool at a more advanced level.  Hence we start off
introducing and using Xamarin Studio.  Later we will look at some of the
underlying tools that are obscured by the use of Xamarin Studio.

\sphinxAtStartPar
Mono has an extra advantage in the tool csharp, for immediate testing of
small snippets of code.  We will use it extensively as we introduce bits of
syntax.

\sphinxAtStartPar
As there is significant evolution of both the Microsoft
and Mono \sphinxstyleemphasis{toolchains}\textendash{}a fancy word we want you to know and a more
elegant way of saying SDK\textendash{}we’ll issue updates to this book.

\sphinxAtStartPar
Everything is free, but there are a number of steps.  Follow them carefully.

\index{mono installation@\spxentry{mono installation}}\ignorespaces 

\subsection{Installing Mono and Xamarin Studios}
\label{\detokenize{appendix/monotools:installing-mono-and-xamarin-studios}}\label{\detokenize{appendix/monotools:install-mono}}\label{\detokenize{appendix/monotools:index-1}}
\sphinxAtStartPar
Because the Mono Project web page is known to change frequently, these
instructions are designed to be as generic as possible. If you have
any questions, you should contact the instructors immediately or seek
tutoring help.


\subsection{OS X}
\label{\detokenize{appendix/monotools:os-x}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Xamarin Studio needs at least version 10.8 of OSX.
If you have an older version, you can upgrade the operating system, or
possibly use an older version of Xamarin Studio.  In that case, ask for help.
\end{sphinxadmonition}

\sphinxAtStartPar
There are two downloads to get and install in order. Mono first:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Go to \textless{}\sphinxurl{http://mono-project.com}\textgreater{}.

\item {} 
\sphinxAtStartPar
Look for the Mono downloads link. Link on OS\sphinxhyphen{}X.
You want to get the latest \sphinxstyleemphasis{stable}
version of Mono for OS X. For this class, you need version 2.10 or
later, though preferably 3.2.4 or later. Choose the MRE version.
It installs directly. Administrative privileges are required to run the
installer, so if you do not know this information, please stop
here.

\sphinxAtStartPar
Do \sphinxstyleemphasis{not} download Xamarin Studio from this site.
This version of Xamararin Studio bugs you with emails.

\end{enumerate}

\sphinxAtStartPar
Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Go to Applications \sphinxhyphen{}\textgreater{} Utilities and launch the Terminal
application, or quicker: enter terminal in Spotlight.
(Terminal is how you get to a command\sphinxhyphen{}line shell in OS X.)

\item {} 
\sphinxAtStartPar
You’ll see a prompt that looks like this
\sphinxcode{\sphinxupquote{computername:folder user\$}}.
This means that Terminal is ready for input.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{which csharp}} and hit enter/return. You should see
\sphinxcode{\sphinxupquote{/usr/bin/csharp}} as output. \sphinxcode{\sphinxupquote{csharp}} is the C\# interpreter.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{which mcs}} and hit enter/return. You should see
\sphinxcode{\sphinxupquote{/usr/bin/mcs}} as output.  \sphinxcode{\sphinxupquote{mcs}} is one of the interfaces to
the C\# compiler.

\end{enumerate}

\index{Xamarin Studio@\spxentry{Xamarin Studio}!installation@\spxentry{installation}}\ignorespaces 

\subsubsection{Xamarin Studio Installation \sphinxhyphen{} OSX}
\label{\detokenize{appendix/monotools:xamarin-studio-installation-osx}}\label{\detokenize{appendix/monotools:install-md-osx}}\label{\detokenize{appendix/monotools:index-2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure Mono is installed first.

\item {} 
\sphinxAtStartPar
Now go to \sphinxurl{http://monodevelop.com}.  \sphinxstylestrong{Note}:  Do \sphinxstyleemphasis{not} use a version
that is linked to the
mono\sphinxhyphen{}project.com site.  Getting the suggested open\sphinxhyphen{}source version
from \sphinxurl{http://monodevelop.com} should not lead to a prompt for your email address….

\item {} 
\sphinxAtStartPar
As with Mono, we need to look for the downloads link.
You should download the \sphinxstyleemphasis{stable} version.

\item {} 
\sphinxAtStartPar
For OS X, the Xamarin Studio SDK is distributed as a DMG disk image. You’ll need
to download this image and double\sphinxhyphen{}click it. Open the image and run
the installer. Administrative privileges are required to run the
installer.

\item {} 
\sphinxAtStartPar
This time, you will see an App for Xamarin Studio,
which you can drag and drop into the Applications folder.

\item {} 
\sphinxAtStartPar
If the preceding steps were successful, you can launch
Xamarin Studio by double\sphinxhyphen{}clicking the icon in your Applications
folder. (You won’t know what to do with it yet, but at least you can
verify that it launches correctly and then use Command\sphinxhyphen{}Q to exit.)

\end{enumerate}


\subsection{Windows}
\label{\detokenize{appendix/monotools:windows}}
\sphinxAtStartPar
There are four packages, so this takes a while.  Mono first:

\sphinxAtStartPar
Dr. Yacobellis has a video showing Windows installation.
\sphinxurl{https://connect.luc.edu/p4hmzk2kbmt/}
There may be further changes to the system.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Go to \textless{}\sphinxurl{http://mono-project.com}\textgreater{}.

\item {} 
\sphinxAtStartPar
Look for the Mono downloads link. You want to get the latest
\sphinxstyleemphasis{stable} version of Mono for Windows. For this class, you need version
2.10 or later, preferably 3.2.3 or later.

\item {} 
\sphinxAtStartPar
Choose the link: Mono for Windows, Gtk\#, and XSP, and download the
installation package

\item {} 
\sphinxAtStartPar
It is a
self\sphinxhyphen{}extracting executable, so you will need to double click it to
install. For Windows 7 users, you may need to check your taskbar to
see whether the installer is being held up by Microsoft’s enhanced
security, UAM, that makes sure you really want to install something
you downloaded from the internet.

\end{enumerate}

\sphinxAtStartPar
Here is how to do a quick sanity check of your Mono setup:

\index{mono command prompt (Windows)@\spxentry{mono command prompt}\spxextra{Windows}}\index{csharp@\spxentry{csharp}!mono command prompt (Windows)@\spxentry{mono command prompt}\spxextra{Windows}}\ignorespaces 

\subsubsection{Mono Command Prompt}
\label{\detokenize{appendix/monotools:mono-command-prompt}}\label{\detokenize{appendix/monotools:index-3}}\label{\detokenize{appendix/monotools:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open the Windows Start Menu and type “mono” in the text field at the bottom.
You should see a short list of places “mono” appears.

\item {} 
\sphinxAtStartPar
Click on the choice that says “Mono … Command prompt”.
(This is probably faster than going to the Start Menu,
finding the Mono folder, expanding it, and clicking on
the Mono Command Prompt.)

\end{enumerate}

\sphinxAtStartPar
If it comes up, you are all set for an initial installation check. This will be the first
step later, when you want to run the handy csharp program or compile and run your
own programs.  When working, you can just leave this window open,
saving it for later use,
(or close and reopen later….)


\subsubsection{Xamarin Studio Installation \sphinxhyphen{} Windows}
\label{\detokenize{appendix/monotools:xamarin-studio-installation-windows}}\label{\detokenize{appendix/monotools:install-md-win}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Have Mono installed first.

\item {} 
\sphinxAtStartPar
Now go to \sphinxurl{http://monodevelop.com}.  \sphinxstylestrong{Note}:  Do \sphinxstyleemphasis{not} use a version
that is linked to the
mono\sphinxhyphen{}project.com site.  Getting the suggested open\sphinxhyphen{}source version
from \sphinxurl{http://monodevelop.com} should not lead to a prompt for your email address….

\item {} 
\sphinxAtStartPar
As with Mono, we need to look for the downloads link, click on the Windows icon.
You should
click the link for the download of the requirements for the \sphinxstyleemphasis{stable} version.
That should be at least numbered 4.2.2. \sphinxstylestrong{Do not install it yet.}

\sphinxAtStartPar
\sphinxstylestrong{Note however, that you will next}
\sphinxstylestrong{install two support packages}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
.Net Framework 4.0 first.  The link takes you to a Microsoft download site.
Do not click the top Download button \sphinxhyphen{} that gives you much more than you need.
Further down in Popular download 01 is
Microsoft .NET Framework 4 (Web Installer).  Click on that and follow
the default sequence.

\item {} 
\sphinxAtStartPar
GKT\#  The GKT@ download directly downloads the GKT installer.  Again follow
the default installation sequence.

\item {} 
\sphinxAtStartPar
install Xamarin Studio \sphinxstylestrong{last}. The Download link gets you the installer
directly.  Install it following the default steps.

\end{itemize}

\item {} 
\sphinxAtStartPar
If the preceding steps were successful, you can launch
Xamarin Studio by double\sphinxhyphen{}clicking the icon on the Desktop
or using the Start Menu.
(You won’t know what to do with it yet, but at least you can
verify at it launches correctly and then close the window.)

\end{enumerate}


\subsection{Linux}
\label{\detokenize{appendix/monotools:linux}}
\sphinxAtStartPar
We only provide instructions for Debian\sphinxhyphen{}based Linux distributions such
as Ubuntu.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Using the command\sphinxhyphen{}line \sphinxcode{\sphinxupquote{apt\sphinxhyphen{}get}} tool, you can install everything
that you need using \sphinxcode{\sphinxupquote{apt\sphinxhyphen{}get install monodevelop}}. This should be
run as the \sphinxstylestrong{root} user (using the \sphinxcode{\sphinxupquote{sudo}} command).

\item {} 
\sphinxAtStartPar
You can test the sanity of your setup by following the instructions
under OS X.

\end{enumerate}

\sphinxAtStartPar
Xamarin Studio releases on Linux tend to lag behind the official stable
release.

\sphinxAtStartPar
This page,
\sphinxurl{https://launchpad.net/~keks9n/+archive/monodevelop-latest},
describes
how to update your Xamarin Studio setup if it is not version 2.8 or later
as we’ll need for this course.

\sphinxAtStartPar
We wish to stress that Linux is recommended for students who already
have a bit of programming experience under their belts. It can take a
significant amount of energy to get a Linux setup up and running and
to tweak it to your liking. While it has gotten ever so much easier
since the 1990s when it first appeared, we encourage you to set it up
perhaps a bit later in the semester or consider running it using
virtualization software (on Mac or Windows) such as VirtualBox or
VMware.

\sphinxstepscope

\index{Xamarin Studio@\spxentry{Xamarin Studio}!further tools@\spxentry{further tools}}\ignorespaces 

\section{Xamarin Studio}
\label{\detokenize{appendix/xamarinstudio:xamarin-studio}}\label{\detokenize{appendix/xamarinstudio:xamarinstudio}}\label{\detokenize{appendix/xamarinstudio:index-0}}\label{\detokenize{appendix/xamarinstudio::doc}}
\sphinxAtStartPar
Several sections have given documentation for Xamarin Studio:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{appendix/monotools:install-md-win}]{\sphinxcrossref{\DUrole{std,std-ref}{Xamarin Studio Installation \sphinxhyphen{} Windows}}}}

\item {} 
\sphinxAtStartPar
or {\hyperref[\detokenize{appendix/monotools:install-md-osx}]{\sphinxcrossref{\DUrole{std,std-ref}{Xamarin Studio Installation \sphinxhyphen{} OSX}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data/lab-edit-compile-run:lab-edit-compile-run}]{\sphinxcrossref{\DUrole{std,std-ref}{Lab: Editing, Compiling, and Running with Xamarin Studio}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data/programstructure:indentation-help}]{\sphinxcrossref{\DUrole{std,std-ref}{Indentation Help}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data/io:our-md-projects}]{\sphinxcrossref{\DUrole{std,std-ref}{Running our Xamarin Studio Examples Solution}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data/lab-division-sentences:xamarinstudio-reminders}]{\sphinxcrossref{\DUrole{std,std-ref}{Xamarin Studio Reminders and Fixes}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{functions/libraryclass:library-projects-in-xamarinstudio}]{\sphinxcrossref{\DUrole{std,std-ref}{Library Projects in Xamarin Studio (Optional)}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{testing/testing:running-nunit-tests}]{\sphinxcrossref{\DUrole{std,std-ref}{Running the NUnit Tests}}}}

\end{itemize}

\sphinxstepscope

\index{command line@\spxentry{command line}}\ignorespaces 

\section{Command Line Introduction}
\label{\detokenize{appendix/cmdline:command-line-introduction}}\label{\detokenize{appendix/cmdline:commandline}}\label{\detokenize{appendix/cmdline:index-0}}\label{\detokenize{appendix/cmdline::doc}}
\sphinxAtStartPar
Sometimes we will be directing you to use a command window or terminal to
compile and run
C\# programs. %
\begin{footnote}[1]\sphinxAtStartFootnote
Thanks to Dr. Robert Yacobellis for elaborations to this section.
%
\end{footnote}

\sphinxAtStartPar
Reasons to use the command line:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The command line precedes the graphical user interface (GUI) used in
modern operating systems and provides a simpler interface for input and output
that is very flexible and powerful for \sphinxstyleemphasis{knowledgeable} users.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Input comes from the keyboard as typed characters (no mouse processing).
Commands are only processed once you press \sphinxkeyboard{\sphinxupquote{Enter}}.

\item {} 
\sphinxAtStartPar
Output goes to the monitor as textual information (no window processing).

\item {} 
\sphinxAtStartPar
In C\# these input/output mechanisms are called Console processing.

\item {} 
\sphinxAtStartPar
Input from and output to files is done in a very similar way, simplifying learning.

\end{itemize}

\item {} 
\sphinxAtStartPar
Many software development organizations use command line processing
to automate creating, compiling (“building”), and running or executing
software programs.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Command line “scripts” can be created to automate routine tasks.

\item {} 
\sphinxAtStartPar
Command line scripts are similar to C\# and other computer programs.

\item {} 
\sphinxAtStartPar
Serious software developers should be familiar with the command line.

\end{itemize}

\end{itemize}

\sphinxAtStartPar
The most direct way to access the command line (often called a \sphinxstyleemphasis{command shell}):
\begin{itemize}
\item {} 
\sphinxAtStartPar
On Windows, to have easy access to Mono tools,
press the Windows key (lower left or lower right on the
keyboard) and type Mono, then select the
Mono Command Prompt and press Enter.

\sphinxAtStartPar
Alternately, if you do \sphinxstyleemphasis{not need Mono tools for sure}, the general way to
get a command window is to press the Windows key
and R (lower or upper case) together, then type \sphinxstyleemphasis{cmd} and
press the Enter or Return key \textendash{} this brings up the basic command
processing program, cmd.

\item {} 
\sphinxAtStartPar
On a Mac just open a Terminal window \textendash{} this is fine for the Mono SDK
commands.

\end{itemize}

\sphinxAtStartPar
Mac OSX, Linux and other Unix variants work basically the same once
you get to a terminal, so we will only distinguish Windows and Mac OS\sphinxhyphen{}X.

\index{command line@\spxentry{command line}!paths@\spxentry{paths}}\index{paths on command line@\spxentry{paths on command line}}\ignorespaces 

\subsection{Navigating Directories}
\label{\detokenize{appendix/cmdline:navigating-directories}}\label{\detokenize{appendix/cmdline:index-1}}\label{\detokenize{appendix/cmdline:id2}}
\sphinxAtStartPar
First make sure you are familiar with {\hyperref[\detokenize{files/paths:path-strings}]{\sphinxcrossref{\DUrole{std,std-ref}{Path Strings}}}}.

\sphinxAtStartPar
In a command shell there is always a \sphinxstyleemphasis{current working directory}, usually
shown in the prompt for the next command.
When you open a Mono Command Prompt or Terminal window you will see
a prompt that tells you what folder or directory the command shell has
started in: If you directly open a terminal as in the previous section,
in Windows this is typically C:\textbackslash{}Windows\textbackslash{}System32, and on
a Mac it is typically /Users/\sphinxstyleemphasis{yourLogin}.

\sphinxAtStartPar
Particularly on windows, this is an annoying folder.  There are several ways
to get to a better location.

\sphinxAtStartPar
If you can get to a parent folder of a folder that you want in a Windows Explorer window
(by right clicking on Start) or Mac Finder, there are shortcuts to opening a terminal
so the current directory is one being one shown in the graphical window:
\begin{description}
\sphinxlineitem{Windows}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Note: this approach does \sphinxstyleemphasis{not} give your a Mono command prompt.

\item {} 
\sphinxAtStartPar
In Windows explorer navigate to the parent folder,
showing the folder you want as a subfolder.

\item {} 
\sphinxAtStartPar
Hold down the shift key and \sphinxstyleemphasis{right} click on the desired folder.
A popup menu appears.

\item {} 
\sphinxAtStartPar
Click on “Open a Command Window here”.

\end{enumerate}

\sphinxlineitem{Mac}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
In the Finder navigate to the parent folder,
showing the folder you want as a subfolder.

\item {} 
\sphinxAtStartPar
Hold down the control key and click on the desired folder.
A popup menu appears.

\item {} 
\sphinxAtStartPar
Click on the bottom item Services, to get a submenu.

\item {} 
\sphinxAtStartPar
In the submenu click on “New Terminal at Folder” (likely the bottom entry).

\end{enumerate}

\end{description}

\index{command line@\spxentry{command line}!dir and ls@\spxentry{dir and ls}}\index{dir on Windows command line@\spxentry{dir on Windows command line}}\index{ls on Mac command line@\spxentry{ls on Mac command line}}\ignorespaces 
\sphinxAtStartPar
Files in the current working directory can to referred to by their simple names,
e.g., \sphinxstyleemphasis{myfile.txt}.  You can list all the files in the directory with the simple
command \sphinxcode{\sphinxupquote{dir}} (short for directory) in Windows or \sphinxcode{\sphinxupquote{ls}} (short for list) on a Mac.

\sphinxAtStartPar
You need to refer to files not in the current directory via a relative or absolute
path name.

\sphinxAtStartPar
After starting in one folder, you may well want to change the current folder
without opening a new terminal window.  This is particularly true if you
start with a Windows Mono command prompt.
You will see below that you can change the current
directory with the \sphinxstyleemphasis{cd} command.

\sphinxAtStartPar
On a Mac, the file system is unified in
one hierarchy. On Windows there may be several drives, and you need to start a
path reference with a drive, like C:, if it is not the current drive.

\sphinxAtStartPar
When you run cmd or start a Mono command prompt in Windows,
you are likely to want to get to
your home directory (where the Mac users start automatically).

\sphinxAtStartPar
Windows users enter the command below (substituting your login ID)
to get to your home directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd C:\PYGZbs{}Users\PYGZbs{}yourLoginId
\end{sphinxVerbatim}

\sphinxAtStartPar
The cd is short for “Change Directory”, changing the current directory.

\index{drive change on Windows@\spxentry{drive change on Windows}}\ignorespaces \phantomsection\label{\detokenize{appendix/cmdline:drive-change}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Windows only:
The cd command does not work the way you are likely to think about it on
a Windows system with more than one drive (like C: and flash drive E: that you have
plugged in).  Windows remembers a \sphinxstyleemphasis{separate} current directory for each
\sphinxstyleemphasis{separate} drive.  It also \sphinxstyleemphasis{independently} remembers a \sphinxstyleemphasis{current drive}.
You do \sphinxstyleemphasis{not change the current drive} with the cd command.
The command to change the current drive is just the name of the
drive with a colon after it.  For example the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
E:
\end{sphinxVerbatim}

\sphinxAtStartPar
sets the current drive to E:, and the active directory is the
current directory on E:.

\sphinxAtStartPar
However, if the current drive is C:, and you enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd E:\PYGZbs{}comp170
\end{sphinxVerbatim}

\sphinxAtStartPar
then you change the current directory on E:, but \sphinxstyleemphasis{the current drive remains C:}.
\end{sphinxadmonition}

\sphinxAtStartPar
We described above how you can use a Windows Explorer/Finder folder to
open a \sphinxstyleemphasis{new} terminal.
If you just want to change
directory in an existing terminal, there is also a shortcut to copy a long
folder name, given a Windows Explorer/Finder folder:

\sphinxAtStartPar
Windows
\begin{itemize}
\item {} 
\sphinxAtStartPar
Depending on the setup of your options, in the address bar you may \sphinxstyleemphasis{not} see a clear
path with a drive and backslashes.  In that case generally clicking to the right of any
directory in the path converts the view to the version we use on the
command line.

\item {} 
\sphinxAtStartPar
When you see a full absolute path, you can just note it and manually copy it,
or else select it all and copy it
and follow the instructions in {\hyperref[\detokenize{appendix/cmdline:copypaste}]{\sphinxcrossref{\DUrole{std,std-ref}{Copy and Paste}}}} to later
paste in the command window.

\item {} 
\sphinxAtStartPar
In any case click in the terminal window, type \sphinxstyleemphasis{cd} and a space, then
type or paste the path.

\item {} 
\sphinxAtStartPar
Of course, you can also go the other way \textendash{} if you see the current
directory name in the Windows prompt, type that into an Explorer address
bar to see its contents in a GUI window.

\end{itemize}

\sphinxAtStartPar
On a Mac there is an easier shortcut:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Type \sphinxstyleemphasis{cd} and a \sphinxstyleemphasis{space} to start the command in the terminal

\item {} 
\sphinxAtStartPar
Locate the directory you want as a subfolder in the Finder
(not opening the directory).

\item {} 
\sphinxAtStartPar
Drag the directory icon to the terminal.  The path gets pasted! Press return.

\end{itemize}


\subsection{Common Commands}
\label{\detokenize{appendix/cmdline:common-commands}}
\sphinxAtStartPar
The command shell waits for you to type in a \sphinxstyleemphasis{command} (a
short name that the shell recognizes) followed by 0 or more \sphinxstyleemphasis{parameters}
separated by spaces (and Enter).
Note that if a parameter contains spaces you must surround the
parameter value with matching single or double quotes \textendash{} you’ll see an
example later.

\sphinxAtStartPar
We are going to mention some of the simplest uses of basic commands.  More
advanced documentation would include more options.

\sphinxAtStartPar
Some commands are common between the Windows and Mac shells:
\begin{description}
\sphinxlineitem{dir (Windows) or ls (Mac)}
\sphinxAtStartPar
to list all the files a in the current directory or a named directory.

\end{description}

\index{command line@\spxentry{command line}!cd@\spxentry{cd}}\index{cd on command line@\spxentry{cd on command line}}\index{change directory on command line@\spxentry{change directory on command line}}\ignorespaces \begin{description}
\sphinxlineitem{cd}
\sphinxAtStartPar
stands for \sphinxstyleemphasis{Change Directory} \textendash{} you can use this
command to change the current working directory to a different one.

\sphinxAtStartPar
You can use this command to change to directories where your C\#
program source files are located, if different from the initial
directory.

\sphinxAtStartPar
On Windows, suppose you created a directory C:\textbackslash{}COMP170\textbackslash{}hello; to
change to that, type \sphinxstyleemphasis{cd C:\textbackslash{}COMP170\textbackslash{}hello} and press Enter \textendash{} the shell
prompt will change to show this new directory location and programs like
\sphinxstyleemphasis{mcs} and \sphinxstyleemphasis{mono} will be able to access files there, directly
by name.  If the Comp170 directory was you current directory, it would
be shorter to use relative paths and just \sphinxcode{\sphinxupquote{cd hello}}.  Remember if
you want a different Windows drive, you must first use a
{\hyperref[\detokenize{appendix/cmdline:drive-change}]{\sphinxcrossref{\DUrole{std,std-ref}{drive change command}}}}.

\sphinxAtStartPar
On a Mac absolute or relative paths work with \sphinxcode{\sphinxupquote{cd}}.
There is no issue with drives.

\sphinxAtStartPar
If you included a space in one or more of the directory names, for
example C:\textbackslash{}COMP 170\textbackslash{}hello (a space between COMP and 170) you should
enclose the path in quotes like: \sphinxcode{\sphinxupquote{cd "C:\textbackslash{}\textbackslash{}COMP 170\textbackslash{}\textbackslash{}hello"}}

\sphinxAtStartPar
\sphinxstylestrong{Mac Note}: if you type just \sphinxstyleemphasis{cd} and press Enter you will change back to
your home directory.  There is also a shorthand name for your home
directory in command paths:  tilde (\textasciitilde{}), often shifted backquote on the
keyboard. Sorry,
no such thing with Windows.

\end{description}

\index{command line@\spxentry{command line}!mkdir@\spxentry{mkdir}}\index{mkdir on command line@\spxentry{mkdir on command line}}\ignorespaces \begin{description}
\sphinxlineitem{mkdir}
\sphinxAtStartPar
stands for make directory \textendash{}
you can use \sphinxstyleemphasis{mkdir} to create a new empty directory in the current
directory.

\sphinxAtStartPar
For example, on a Mac with current directory /Users/\sphinxstyleemphasis{YourLogin},
type \sphinxstyleemphasis{mkdir hello} and press Enter \textendash{} this will create a new directory
/Users/\sphinxstyleemphasis{yourLogin}/hello if it did not exist before; you can now create
a C\# source file in that directory and enter \sphinxstyleemphasis{cd hello} in the command shell.

\sphinxAtStartPar
An optional Windows abbreviation is \sphinxstyleemphasis{md}.

\end{description}

\index{command line@\spxentry{command line}!rmdir@\spxentry{rmdir}}\index{rmdir on command line@\spxentry{rmdir on command line}}\ignorespaces \begin{description}
\sphinxlineitem{rmdir}
\sphinxAtStartPar
removes an \sphinxstyleemphasis{empty} directory that you give as parameter, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rmdir hello
\end{sphinxVerbatim}

\end{description}

\sphinxAtStartPar
With Mono installed (and for Windows, with a Mono command window), the
programs associated with Mono can be used:
\begin{description}
\sphinxlineitem{mcs}
\sphinxAtStartPar
compiles one or more listed C\# source files without using Xamarin Studio.

\sphinxlineitem{csharp}
\sphinxAtStartPar
is the interactive C\# statement testing program.

\end{description}

\sphinxAtStartPar
Other useful commands, with different names for Windows and Mac,
are listed next by generic function,
with general Windows syntax first and Mac second, and then
often examples in the same order:

\index{command line@\spxentry{command line}!display text file@\spxentry{display text file}}\index{type on Windows command line@\spxentry{type on Windows command line}}\index{cat on Mac command line@\spxentry{cat on Mac command line}}\ignorespaces 
\sphinxAtStartPar
Display the contents of a text file in the command window. The Unix/Mac
name origin:  a more complicated
use of cat is to con\sphinxstylestrong{cat}enate files.

\begin{DUlineblock}{0em}
\item[] type \sphinxstyleemphasis{textFileName}
\item[] cat \sphinxstyleemphasis{textFileName}
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
type my\PYGZus{}program.cs
cat my\PYGZus{}program.cs
\end{sphinxVerbatim}

\index{command line@\spxentry{command line}!copy file@\spxentry{copy file}}\index{copy on Windows command line@\spxentry{copy on Windows command line}}\index{cp on Mac command line@\spxentry{cp on Mac command line}}\ignorespaces 
\sphinxAtStartPar
Make a copy of a file.  Caution: If the second file already exists,
you wipe out the original contents!

\begin{DUlineblock}{0em}
\item[] copy \sphinxstyleemphasis{originalFile}  \sphinxstyleemphasis{copyName}
\item[] cp \sphinxstyleemphasis{originalFile}  \sphinxstyleemphasis{copyName}
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
copy prog.cs prog\PYGZus{}bak.cs
cp prog.cs prog\PYGZus{}bak.cs
\end{sphinxVerbatim}

\index{command line@\spxentry{command line}!delete a file@\spxentry{delete a file}}\index{erase on Windows command line@\spxentry{erase on Windows command line}}\index{rm on Mac command line@\spxentry{rm on Mac command line}}\ignorespaces 
\sphinxAtStartPar
Erase or remove a file:

\begin{DUlineblock}{0em}
\item[] erase \sphinxstyleemphasis{fileToKill}
\item[] rm \sphinxstyleemphasis{fileToKill}
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
erase poorAttempt.cs
rm poorAttempt.cs
\end{sphinxVerbatim}

\sphinxAtStartPar
Another Windows equivalent is \sphinxcode{\sphinxupquote{del}} (short for delete).

\index{command line@\spxentry{command line}!help@\spxentry{help}}\index{help on command line@\spxentry{help on command line}}\index{man on Mac command line@\spxentry{man on Mac command line}}\ignorespaces 
\sphinxAtStartPar
We have explained the simplest use of many of the commands above.
Many modifiers are possible.

\sphinxAtStartPar
Help on a command:

\begin{DUlineblock}{0em}
\item[] help \sphinxstyleemphasis{commandName};
\item[] \sphinxstyleemphasis{commandName} \textendash{}help
\end{DUlineblock}

\sphinxAtStartPar
Note the double dash above: This
sometimes works for concise help on a Mac while you can generally get
an immensely detailed help overload on a Mac from
\begin{quote}

\sphinxAtStartPar
man \sphinxstyleemphasis{commandName}
\end{quote}

\index{command line@\spxentry{command line}!script@\spxentry{script}}\index{script on command line@\spxentry{script on command line}}\ignorespaces 

\subsection{Scripts}
\label{\detokenize{appendix/cmdline:scripts}}\label{\detokenize{appendix/cmdline:index-11}}
\sphinxAtStartPar
This is not a subject of this course, but commands can be combined into
script files.

\sphinxAtStartPar
Scripting languages are in fact whole new specialized programming languages,
that include many of the types of
programming statements found in C\#.

\index{command line@\spxentry{command line}!copy and paste text@\spxentry{copy and paste text}}\index{copy text on command line@\spxentry{copy text on command line}}\index{paste text on command line@\spxentry{paste text on command line}}\ignorespaces 

\subsection{Copy and Paste}
\label{\detokenize{appendix/cmdline:copy-and-paste}}\label{\detokenize{appendix/cmdline:copypaste}}\label{\detokenize{appendix/cmdline:index-12}}
\sphinxAtStartPar
Copying or pasting with a Mac is is the same with a terminal as in other editing:
Use the same Apple Command key with C or P, and you can select with the mouse.

\sphinxAtStartPar
In Windows it is more complicated when using a command window:
You can paste into the current command line by \sphinxstyleemphasis{right}
clicking on the Command Window Title bar, and select edit and then paste.

\sphinxAtStartPar
By default
a Windows command window is not sensitive to the mouse.
You can change so that it is sensitive
for select and copy:  Right click in the title bar, select defaults, and make sure
the check boxes under edit options are \sphinxstyleemphasis{all} checked.
(The last two are explained in the next section.)
Click OK.  Then you can select with
mouse and press Enter for the selection to be remembered in the copy buffer.

\index{command line@\spxentry{command line}!shortcuts@\spxentry{shortcuts}}\index{shortcuts on command line@\spxentry{shortcuts on command line}}\index{file completion on command line@\spxentry{file completion on command line}}\index{history on command line@\spxentry{history on command line}}\ignorespaces 

\subsection{Command Line Shortcuts}
\label{\detokenize{appendix/cmdline:command-line-shortcuts}}\label{\detokenize{appendix/cmdline:index-13}}
\sphinxAtStartPar
Both Mac and Windows (with the right options selected,
like the Windows check boxes in the last section), allow you to reduce typing:

\sphinxAtStartPar
You can bring back a previous command for the history of commands that are automatically
remembered: Use the up and down arrows.  This makes it very easy to run the same command
again, or to make slight edits.

\sphinxAtStartPar
Both Windows and OS\sphinxhyphen{}X can see what files are in any directory being referred to.
If you just start to type a file or folder name and then press the Tab key, both
Windows and  OS\sphinxhyphen{}X will do \sphinxstyleemphasis{file completion}
to complete the name if there is no ambiguity.  If there is ambiguity,
they work differently:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Windows will cycle through all the options as you keep
pressing Tab.

\item {} 
\sphinxAtStartPar
On the first tab OS\sphinxhyphen{}X will do nothing but give a sound if there is
ambiguity, but the second tab will list all the options.  Then you need to type enough
more to disambiguate the meaning.

\end{itemize}

\sphinxstepscope

\index{precedence@\spxentry{precedence}}\index{operator@\spxentry{operator}!precedence@\spxentry{precedence}}\ignorespaces 

\section{Precedence of Operators}
\label{\detokenize{appendix/precedence:precedence-of-operators}}\label{\detokenize{appendix/precedence:precedence}}\label{\detokenize{appendix/precedence:index-0}}\label{\detokenize{appendix/precedence::doc}}
\sphinxAtStartPar
Earlier lines have higher precedence.
Only operators used in this book are included:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
obj.field  f(x)  a[i]  n++  n\PYGZhy{}\PYGZhy{}  new
+  \PYGZhy{}  ! (Type)x (Unary operators)
* / \PYGZpc{}
+ \PYGZhy{} (binary)
\PYGZlt{} \PYGZgt{} \PYGZlt{}= \PYGZgt{}=
== !=
\PYGZam{}\PYGZam{}
||
=  *=  /=  \PYGZpc{}=  +=  \PYGZhy{}=
\end{sphinxVerbatim}

\sphinxAtStartPar
All symbols are listed at the beginning of the index.

\sphinxAtStartPar
Parentheses for grouping are encouraged with less common combinations, even if
not strictly necessary.

\sphinxstepscope

\index{homework@\spxentry{homework}!grade\_calc I@\spxentry{grade\_calc I}}\ignorespaces 

\section{Homework: Grade Calculation}
\label{\detokenize{appendix/homework-gradecalculation:homework-grade-calculation}}\label{\detokenize{appendix/homework-gradecalculation:index-0}}\label{\detokenize{appendix/homework-gradecalculation:id1}}\label{\detokenize{appendix/homework-gradecalculation::doc}}
\sphinxAtStartPar
Create a program file \sphinxcode{\sphinxupquote{grade\_calc.cs}} for this assignment.
You are going to be
putting together your first programming assignment where
you will be taking the various concepts we have learned
thus far from class and to put together your first
meaningful program on your own.

\sphinxAtStartPar
This program will incorporate the following elements:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Prompt a user for input.

\item {} 
\sphinxAtStartPar
Perform some rudimentary calculations.

\item {} 
\sphinxAtStartPar
Make some decisions.

\item {} 
\sphinxAtStartPar
Produce output.

\end{itemize}

\sphinxAtStartPar
As we’ve mentioned earlier in class, our focus is going
to be on learning how to write computer programs that start
with a Main() function and perhaps use other functions as
needed to \sphinxstyleemphasis{get a particular job done}. Eventually, we will
be incorporating more and more advanced elements, such as
classes and objects. For now, we would like you to organize
your program according to the guidelines set forth here.


\subsection{Program Summary}
\label{\detokenize{appendix/homework-gradecalculation:program-summary}}
\sphinxAtStartPar
Our first program is based on a common task that every
course professor/instructor needs to do: make grades. In
any given course, there is a \sphinxstyleemphasis{grading scale} and a set of
\sphinxstyleemphasis{categories}.

\sphinxAtStartPar
Here is sample output from two runs of the program.
The only data entered by the user are
show in \sphinxstylestrong{boldface} for illustration here.

\sphinxAtStartPar
One successful run with the data used above:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter weights for each part as an integer
\item[] percentage of the final grade:
\item[] Exams: \sphinxstylestrong{40}
\item[] Labs: \sphinxstylestrong{15}
\item[] Homework: \sphinxstylestrong{15}
\item[] Project: \sphinxstylestrong{20}
\item[] Participation: \sphinxstylestrong{10}
\item[] 
\item[] Enter decimal numbers for the averages in each part:
\item[] Exams: \sphinxstylestrong{50}
\item[] Labs: \sphinxstylestrong{100}
\item[] Homework: \sphinxstylestrong{100}
\item[] Project: \sphinxstylestrong{100}
\item[] Participation: \sphinxstylestrong{5}
\item[] 
\item[] Your grade is 70.5\%
\item[] Your letter grade is C\sphinxhyphen{}.
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
A run with bad weights:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter weights for each part as an integer
\item[] percentage of the final grade:
\item[] Exams: \sphinxstylestrong{30}
\item[] Labs: \sphinxstylestrong{10}
\item[] Homework: \sphinxstylestrong{10}
\item[] Project: \sphinxstylestrong{10}
\item[] Participation: \sphinxstylestrong{10}
\item[] 
\item[] Your weights add to 70, not 100.
\item[] This grading program is ending.
\end{DUlineblock}
\end{quote}


\subsection{Details}
\label{\detokenize{appendix/homework-gradecalculation:details}}
\sphinxAtStartPar
Make your program file have the name \sphinxcode{\sphinxupquote{grade\_calc.cs}}.

\sphinxAtStartPar
This is based on the idea of Dr. Thiruvathukal’s own
legendary course syllabus.
We’re going to start
by assuming that there is a fixed set of categories.
As an example we assume Dr. Thiruvathukal’s categories.

\sphinxAtStartPar
In the example below we work out for
Dr. Thiruvathukal’s weights in each category,
though your program should prompt
the user for these integer percentages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
exams \sphinxhyphen{} 40\% (integer weight is 40)

\item {} 
\sphinxAtStartPar
labs \sphinxhyphen{} 15\% (weight 15)

\item {} 
\sphinxAtStartPar
homework \sphinxhyphen{} 15\% (weight 15)

\item {} 
\sphinxAtStartPar
project \sphinxhyphen{} 20\% (weight 20)

\item {} 
\sphinxAtStartPar
participation \sphinxhyphen{} 10\% (weight 10)

\end{itemize}

\sphinxAtStartPar
Your program will prompt the user for each the weights
for each of the categories. These weights will be entered
as integers, which must add up to 100.

\sphinxAtStartPar
If the weights do not add up to 100, print a message and
end the program. You can use an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{else}} construction
here.  An alternative is an \sphinxcode{\sphinxupquote{if}} statement to test for a bad sum.
In the block of statements that go with the \sphinxcode{\sphinxupquote{if}} statement,
you can put not only the message to the user, but also a
statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Recall that a function ends when a return statement is reached.
You may not have heard that this can also be used
with a \sphinxcode{\sphinxupquote{void}} function.  In a \sphinxcode{\sphinxupquote{void}} function
there is no return value in the \sphinxcode{\sphinxupquote{return}} statement.

\sphinxAtStartPar
Assuming the weights add to 100, then we will use
these weights to compute your
grade as a \sphinxcode{\sphinxupquote{double}}, which gives you the
best precision when it comes to floating\sphinxhyphen{}point arithmetic.

\sphinxAtStartPar
We’ll talk in class about why we want the weights to be
integers. Because floating\sphinxhyphen{}point mathematics is not 100\%
precise, it is important that we have an accurate way
to know that the weights \sphinxstyleemphasis{really add up} to 100. The only
way to be assured of this is to use \sphinxstyleemphasis{integers}. We will
actually use floating\sphinxhyphen{}point calculations to compute the
grade, because we have a certain tolerance for errors at
this stage. (This is a fairly advanced topic that is
covered extensively in courses like COMP 264/Systems
Programming and even more advanced courses like Numerical
Analysis, Comp 308.)

\sphinxAtStartPar
We are going to pretend
that we already know our score (as a percentage) for each
one of these categories, so it will be fairly simple to
compute the grade.

\sphinxAtStartPar
For each category, you will define a weight (int) and a
score (double). Then you will sum up the weight * score and
divide by 100.0 (to get a double\sphinxhyphen{}precision floating\sphinxhyphen{}point
result).

\sphinxAtStartPar
This is best illustrated by example.

\sphinxAtStartPar
George is a student in COMP 170. He has the following
averages for each category to date:
\begin{itemize}
\item {} 
\sphinxAtStartPar
exams: 50\%

\item {} 
\sphinxAtStartPar
labs: 100\%

\item {} 
\sphinxAtStartPar
homework: 100\%

\item {} 
\sphinxAtStartPar
project: 100\%

\item {} 
\sphinxAtStartPar
participation: 5\%

\end{itemize}

\sphinxAtStartPar
The following session with the \sphinxcode{\sphinxupquote{csharp}} interpreter shows
the how you would declare all of the needed variables and
the calculation to be performed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} int exam\PYGZus{}weight = 40;
csharp\PYGZgt{} int lab\PYGZus{}weight = 15;
csharp\PYGZgt{} int hw\PYGZus{}weight = 15;
csharp\PYGZgt{} int project\PYGZus{}weight = 20;
csharp\PYGZgt{} int participation\PYGZus{}weight = 10;

csharp\PYGZgt{} double exam\PYGZus{}grade = 50.0;
csharp\PYGZgt{} double lab\PYGZus{}grade = 100;
csharp\PYGZgt{} double homework\PYGZus{}grade = 100;
csharp\PYGZgt{} double project\PYGZus{}grade = 100;
csharp\PYGZgt{} double participation\PYGZus{}grade = 5;
\end{sphinxVerbatim}

\sphinxAtStartPar
This is intended only to be as an example though. Your
program must ask the user to enter each of these variables.

\sphinxAtStartPar
Once we have all of the weights and scores entered, we
can calculate the grade as follows.  This is a long
expression: It is continued on multiple lines.  Recall all
the \sphinxcode{\sphinxupquote{\textgreater{}}} symbols are csharp prompts are not part of the
expression:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} double grade = (exam\PYGZus{}weight * exam\PYGZus{}grade +
      \PYGZgt{} homework\PYGZus{}weight* homework\PYGZus{}grade +
      \PYGZgt{} lab\PYGZus{}weight * lab\PYGZus{}grade + project\PYGZus{}weight * project\PYGZus{}grade +
      \PYGZgt{} participation\PYGZus{}weight * participation\PYGZus{}grade) / 100.0;
\end{sphinxVerbatim}

\sphinxAtStartPar
Then you can display the grade as a percentage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
csharp\PYGZgt{} Console.WriteLine(\PYGZdq{}Your grade is \PYGZob{}0\PYGZcb{}\PYGZpc{}\PYGZdq{}, grade);
Your grade is 70.5\PYGZpc{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now for the fun part. We will use \sphinxcode{\sphinxupquote{if}} statements to
print the letter grade. You will actually need to use
multiple \sphinxcode{\sphinxupquote{if}} statements to test the conditions. A way
of thinking of how you would write the logic for determining
your grade is similar to how you tend to think of the \sphinxstyleemphasis{best}
grade you can \sphinxstyleemphasis{hope for} in any given class. (We know that
we used to do this as students.)

\sphinxAtStartPar
Here is the thought process:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If my grade is 93 (93.0) or higher, I’m getting an A.

\item {} 
\sphinxAtStartPar
If my grade is 90 or higher (but less than 93), I
am getting an A\sphinxhyphen{}.

\item {} 
\sphinxAtStartPar
If my grade is 87 or higher (but less than 90), I
am getting a B+.

\item {} 
\sphinxAtStartPar
And so on…

\item {} 
\sphinxAtStartPar
Finally, if I am less than 60, I am unlikely to pass.

\end{itemize}

\sphinxAtStartPar
We’ll come to see how \sphinxstyleemphasis{logic} plays a major role in
computer science\textendash{}sometimes even more of a role than
other mathematical aspects. In this particular program,
however, we see a bit of the best of both worlds. We’re
doing \sphinxstyleemphasis{arithmetic} calculations to \sphinxstyleemphasis{compute} the grade.
But we are using \sphinxstyleemphasis{logic} to determine the grade in the
cold reality that we all know and love: the bottom\sphinxhyphen{}line
grade.

\sphinxAtStartPar
This assignment can be started after the data chapter,
because you can do most all of it with tools
learned so far.  Add the parts with \sphinxcode{\sphinxupquote{if}} statements
when you have been introduced to \sphinxcode{\sphinxupquote{if}} statements.
(Initially be sure to use data that makes the
weights actually add up to 100.)

\sphinxAtStartPar
You should be able to write the program more concisely
and readably if you use functions developed
in class for the prompting user input.


\subsection{Grading Rubric}
\label{\detokenize{appendix/homework-gradecalculation:grading-rubric}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
As a general rule, we expect programs to be complete,
compile correctly, run, and be
thoroughly tested. We are able to grade an incomplete program
but will only give at most 10/25
for effort. Instead of submitting something incomplete,
you are encouraged to complete your program and
submit it per the late policy.  Start early and get help!
\end{sphinxadmonition}

\sphinxAtStartPar
25 point assignment broken down as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Enter weights, with prompts \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
End if the weights do not add to 100: \sphinxstylestrong{{[}5{]}}

\item {} 
\sphinxAtStartPar
Enter grades, with prompts: \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
Calculate the numerical average and display with a label: \sphinxstylestrong{{[}5{]}}

\item {} 
\sphinxAtStartPar
Calculate the letter grade and display witha label: \sphinxstylestrong{{[}5{]}}

\item {} 
\sphinxAtStartPar
Use formatting standards for indentation: \sphinxstylestrong{{[}4{]}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sequential statements at the same level of indentation

\item {} 
\sphinxAtStartPar
Blocks of statements inside of braces indented

\item {} 
\sphinxAtStartPar
Closing brace for a statement block always lining up with the
heading before the start of the block.

\end{itemize}

\end{itemize}


\subsection{Logs and Partners}
\label{\detokenize{appendix/homework-gradecalculation:logs-and-partners}}
\sphinxAtStartPar
You may work with a partner, following good pair\sphinxhyphen{}programming practice,
sharing responsibility for all parts.

\sphinxAtStartPar
Only one of a pair needs to submit the actual programming assignment.
However \sphinxstyleemphasis{both} students, \sphinxstyleemphasis{independently}, should write and
include a log in their
Homework submission.  Students working alone should also submit a log,
with fewer parts.

\sphinxAtStartPar
Each individual’s log should indicate each of the following clearly:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Your name and who your partner is (if you have one)

\item {} 
\sphinxAtStartPar
Your approximate total number of hours working on the homework

\item {} 
\sphinxAtStartPar
Some comment about how it went \sphinxhyphen{} what was hard …

\item {} 
\sphinxAtStartPar
An assessment of your contribution (if you have a partner)

\item {} 
\sphinxAtStartPar
An assessment of your partner’s contribution (if you have a partner).

\end{itemize}

\sphinxAtStartPar
Just omit the parts about a partner if you do not have one.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Name the log file with the exact file name:
“log.txt” and make it a plain text file.
You can create it in a program editor or in a fancy document editor.
If you use a fancy document editor, be sure to a “Save As…” dialog,
and select the file format “plain text”,
usually indicated by the “.txt” suffix.
It does not work to save a file in the default word processor format, and
then later just change its name (but not its format) in the file system.
\end{sphinxadmonition}

\sphinxstepscope

\index{homework@\spxentry{homework}!grade calculation 2@\spxentry{grade calculation 2}}\index{grade calculation 2 homework@\spxentry{grade calculation 2 homework}}\ignorespaces 

\section{Homework: Grade Calculation from Individual Scores}
\label{\detokenize{appendix/homework-gradecalculation2:homework-grade-calculation-from-individual-scores}}\label{\detokenize{appendix/homework-gradecalculation2:homework-grade-calculation2}}\label{\detokenize{appendix/homework-gradecalculation2:index-0}}\label{\detokenize{appendix/homework-gradecalculation2::doc}}
\sphinxAtStartPar
In the previous assignment, we calculated grades based on a \sphinxstyleemphasis{memorized}
overall grade within each of the categories below, as in this example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
exams \sphinxhyphen{} 40\% (integer weight is 40)

\item {} 
\sphinxAtStartPar
labs \sphinxhyphen{} 15\% (weight 15)

\item {} 
\sphinxAtStartPar
homework \sphinxhyphen{} 15\% (weight 15)

\item {} 
\sphinxAtStartPar
project \sphinxhyphen{} 20\% (weight 20)

\item {} 
\sphinxAtStartPar
participation \sphinxhyphen{} 10\% (weight 10)

\end{itemize}

\sphinxAtStartPar
In this assignment, we are going to change the specification slightly
to make the program a bit smarter. Instead of someone having to remember
what their average grade was for each category, we will prompt the user for
the number of items within each category (e.g. number of exams, number
of labs, etc.), have the user enter individual grades, and have the program
calculate the average for the category.

\sphinxAtStartPar
As usual, we will begin by specifying \sphinxstyleemphasis{requirements}.
User responses are shown \sphinxstylestrong{bold faced}.


\subsection{Functional Requirements}
\label{\detokenize{appendix/homework-gradecalculation2:functional-requirements}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Instead of bombing out if the weights don’t add up to 100, use {\hyperref[\detokenize{while/do-while:do-while}]{\sphinxcrossref{\DUrole{std,std-ref}{Do\sphinxhyphen{}While Loops}}}}
to prompt the user again
for all of the weights until they do add up to 100. A \sphinxcode{\sphinxupquote{do \{ ... \} while}}
loop is the right choice here, because you can test all of the weights
at the end of the loop, after each time they have been entered
in the loop.

\item {} 
\sphinxAtStartPar
Write a function, \sphinxcode{\sphinxupquote{FindAverage}},
to do the following.  The example refers to the category exam,
but you will want your code to work for each
category, and hence the category
\sphinxstyleemphasis{name} will need to be a parameter to \sphinxcode{\sphinxupquote{FindAverage}}.)

\sphinxAtStartPar
Prompt the user for the number of items in the category:
\begin{quote}

\sphinxAtStartPar
Please enter the number grades in category exam: \sphinxstylestrong{4}
\end{quote}

\sphinxAtStartPar
Instead of prompting the user for an overall average
exam grade, use a loop  to
read one grade at a time. The grades will be added together (on the fly)
to give the grade for that category. For example, after you have asked
for the number of exams, you’d prompt the user to enter each exam
grade and have the program compute the sum. As soon as a category
sum is calculated, also print out the average as shown in the sample below:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Please enter the grade for exam 1: \sphinxstylestrong{100}
\item[] Please enter the grade for exam 2: \sphinxstylestrong{90}
\item[] Please enter the grade for exam 3: \sphinxstylestrong{80}
\item[] Please enter the grade for exam 4: \sphinxstylestrong{92}
\item[] Calculated average exam grade = 90.5
\end{DUlineblock}
\end{quote}

\sphinxAtStartPar
Of course you must return the grade to the caller for use in the
overall weighted average grade.

\sphinxAtStartPar
A category may have only a single grade, in which case the
user will just enter the number of grades as 1.

\item {} 
\sphinxAtStartPar
Once you have read in the data for each of the items within a category,
you’ll basically be able to \sphinxstyleemphasis{reuse} the code that you developed in the
previous assignment to compute the weighted average and print the
final letter grade.

\item {} 
\sphinxAtStartPar
Print the final numerical average, \sphinxstyleemphasis{this time rounded to one decimal place}.
If the final average was actually 93.125, you would print 93.1.
If the final average was actually 93, you would print 93.0.
If the final average was actually 93.175, you would print 93.2.

\end{enumerate}


\subsection{Style Requirements}
\label{\detokenize{appendix/homework-gradecalculation2:style-requirements}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
For this assignment, you are expected to start using functions for all
aspects of the assignment. For example, it can become tedious in a hurry
to write code to prompt for each of exams, labs, homework, etc. when
a single function (with parameter named \sphinxstyleemphasis{category}) could be used to
avoid repeating yourself. In particular you should
write your function to take advantage of our \sphinxcode{\sphinxupquote{UI}}
class, from {\hyperref[\detokenize{while/userinput:ui}]{\sphinxcrossref{\DUrole{std,std-ref}{User Input: UI}}}}.

\item {} 
\sphinxAtStartPar
Also beginning with this assignment, it is expected that your work
will be presented neatly. That is, we expect the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
proper indentation that makes your program more readable by other
humans. Use all spaces, not tabs to indent.  You never know what
default tabs your grader will have set up.

\item {} 
\sphinxAtStartPar
proper naming of classes and functions. In C\#, the convention is to
begin a name with a capital letter. You can have multiple words in a
name, but these should be capitalized using a method known as
CamelCase \sphinxcite{appendix/homework-gradecalculation2:camelcase}. We also recommend this same naming convention
for variables but with a lowercase first letter.
For variables, we are also
ok with the use of underscores. For example, in homework 1 we used
names like \sphinxtitleref{exam\_grade}. If you use CamelCase, you can name this
variable \sphinxtitleref{examGrade}.

\item {} 
\sphinxAtStartPar
If you have any questions about the neatness or appearance of your
code, please talk to the instructor or teaching assistant.

\item {} 
\sphinxAtStartPar
This guide from CIS 193 at \sphinxcite{appendix/homework-gradecalculation2:upenncsharp}
provides a nice set of conventions
to follow. We include this here so you know that other faculty at
other universities also consider neatness/appearance to be important.

\end{itemize}

\end{enumerate}


\subsection{Grading Rubric}
\label{\detokenize{appendix/homework-gradecalculation2:grading-rubric}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
As a general rule, we expect programs to be complete,
compile correctly, run, and be
thoroughly tested. We are able to grade an incomplete program
but will only give at most 10/25
for effort. Instead of submitting something incomplete,
you are encouraged to complete your program and
submit it per the late policy.  Start early and get help!
\end{sphinxadmonition}

\sphinxAtStartPar
25 point assignment broken down as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Loop until weights add to 100: 5

\item {} 
\sphinxAtStartPar
Average any number of grades in a category: 5

\item {} 
\sphinxAtStartPar
One function that is reused and works for the average in each category: 5

\item {} 
\sphinxAtStartPar
Print final numerical grade rounded to one decimal place: 2

\item {} 
\sphinxAtStartPar
Previous program features still work: 3

\item {} 
\sphinxAtStartPar
Style: 5

\end{itemize}


\subsection{Logs and Partners}
\label{\detokenize{appendix/homework-gradecalculation2:logs-and-partners}}
\sphinxAtStartPar
You may work with a partner, following good pair\sphinxhyphen{}programming practice,
sharing responsibility for all parts.

\sphinxAtStartPar
Only one of a pair needs to submit the actual programming assignment.
However \sphinxstyleemphasis{both} students, \sphinxstyleemphasis{independently}, should write and
include a log in their
Homework submission.  Students working alone should also submit a log,
with fewer parts.

\sphinxAtStartPar
Each individual’s log should indicate each of the following clearly:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Your name and who your partner is (if you have one)

\item {} 
\sphinxAtStartPar
Your approximate total number of hours working on the homework

\item {} 
\sphinxAtStartPar
Some comment about how it went \sphinxhyphen{} what was hard …

\item {} 
\sphinxAtStartPar
An assessment of your contribution (if you have a partner)

\item {} 
\sphinxAtStartPar
An assessment of your partner’s contribution (if you have a partner).

\end{itemize}

\sphinxAtStartPar
Just omit the parts about a partner if you do not have one.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Name the log file with the exact file name:
“log.txt” and make it a plain text file.
You can create it in a program editor or in a fancy document editor.
If you use a fancy document editor, be sure to a “Save As…” dialog,
and select the file format “plain text”,
usually indicated by the “.txt” suffix.
It does not work to save a file in the default word processor format, and
then just change its name (but not its format) in the file system.
\end{sphinxadmonition}

\sphinxstepscope

\index{homework@\spxentry{homework}!grade files@\spxentry{grade files}}\index{grade files homework@\spxentry{grade files homework}}\ignorespaces 

\section{Homework: Grade File}
\label{\detokenize{appendix/hw-gradefiles:homework-grade-file}}\label{\detokenize{appendix/hw-gradefiles:hw-gradefiles}}\label{\detokenize{appendix/hw-gradefiles:index-0}}\label{\detokenize{appendix/hw-gradefiles::doc}}
\sphinxAtStartPar
Copy project files in \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade\_file\_homework\_stub}{grade\_file\_homework\_stub} to
your own project.  Then you should have copies of the
source file \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade\_file\_homework\_stub/grade\_files.cs}{grade\_files.cs}
for you to \sphinxstyleemphasis{complete} for this homework.
The folder also contains sample data files
including the examples discussed below.

\sphinxAtStartPar
In this assignment, we’re going to begin taking steps to help you
achieve greater \sphinxstyleemphasis{independence} when it comes to programming. This
means (among other things) that you will be given what is commonly
known as a specification. In software development\textendash{}and in the business
world in general, it is customary to capture a set of
\sphinxstyleemphasis{business requirements} in what is commonly known as a
\sphinxstyleemphasis{requirements specification} document. While what you read here will be much more
concise, we want you to become familiar with requirements\sphinxhyphen{}driven
thinking, without which many real\sphinxhyphen{}world software projects fail.

\sphinxAtStartPar
After presenting the set of requirements, we will give you some hints
for how to \sphinxstyleemphasis{implement} the requirements. These hints may or may not
prove completely helpful to you, and you are also invited to come up
with your own solutions. As we inch closer to the semester project,
you’re going to want to use your imagination to create a good solution
to a problem.


\subsection{Brief Problem Statement}
\label{\detokenize{appendix/hw-gradefiles:brief-problem-statement}}
\sphinxAtStartPar
The previous two homework assignments represent a great simplification
of the real\sphinxhyphen{}world process of grading. The notion that grade
information must be entered manually is rather tedious, not to mention
error prone. In the real world, grade information would be kept in a
file (a spreadsheet is common), from which various calculations and
summary reports could be generated.

\sphinxAtStartPar
In this assignment, the problem we are trying to solve is to take all
of the \sphinxstyleemphasis{raw} grade data from one or more student files and prepare a
\sphinxstyleemphasis{summary report} file with a line for each student.

\sphinxAtStartPar
Although we could do all of what we’re describing here with a
\sphinxstyleemphasis{spreadsheet}, the point is to show how we can use C\# to read in a
simplified form of comma\sphinxhyphen{}separated data, process it, and do some
general\sphinxhyphen{}purpose calculations on the data.


\subsection{Using C\#}
\label{\detokenize{appendix/hw-gradefiles:using-c}}
\sphinxAtStartPar
We’ll be making use of a number of C\# features (some old, some new) in
this homework:
\begin{itemize}
\item {} 
\sphinxAtStartPar
decisions, loops, strings, and functions

\item {} 
\sphinxAtStartPar
files

\item {} 
\sphinxAtStartPar
arrays

\end{itemize}


\subsection{Requirements}
\label{\detokenize{appendix/hw-gradefiles:requirements}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Unlike in previous assignments, this program must accept data from
a collection of input files (that is, it will not be reading most of the
data from the class \sphinxcode{\sphinxupquote{Console}}).

\item {} 
\sphinxAtStartPar
The program needs a course abbreviation from the user.  If there
is a command line argument, use it as the course abbreviation.
Make sure your code can
read a command\sphinxhyphen{}line argument using the special form of
\sphinxcode{\sphinxupquote{Main(string{[}{]} args)}} already in the stub
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade\_file\_homework\_stub/grade\_files.cs}{grade\_files.cs}.
If the user does not provide at command line argument,
prompt the user for it once the program starts.
An example would be comp170.  All data files will include the course
abbreviation as part of their name.  We will use comp170 in the examples below,
but it could be something else.  The folder also contains sample data files
for a course abbreviation comp150.

\sphinxAtStartPar
Note that these data files are in the project directory.  Make sure your project,
like this stub, sets the Output Path to the project folder.

\item {} 
\sphinxAtStartPar
There are two master files for any course.
One is “categories\_” + the course abbreviation
+ “.txt”.  For example, \sphinxcode{\sphinxupquote{categories\_comp170.txt}} is a sample data file
provided and used below.

\sphinxAtStartPar
It will contain three lines.
The first line is a comma separated list of category names like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Exam, Lab, Homework, Project, Class Participation
\end{sphinxVerbatim}

\sphinxAtStartPar
There may be extra spaces after the commas.
Categories will be chosen so that \sphinxstyleemphasis{each one starts with a different letter}.

\sphinxAtStartPar
The second line contains the integer weights for each category, like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
40, 15, 15, 20, 10
\end{sphinxVerbatim}

\sphinxAtStartPar
They do \sphinxstyleemphasis{not} need to add to 100.  If the sum is called totWeights,
get the final grade by summing for each category:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{category}\PYG{+w}{ }\PYG{n}{weight}\PYG{p}{)}\PYG{p}{(}\PYG{n}{category}\PYG{+w}{ }\PYG{n}{grade}\PYG{p}{)}\PYG{o}{/}\PYG{n}{totWeights}
\end{sphinxVerbatim}

\sphinxAtStartPar
The third line will contain the number of grades in each category, like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2, 5, 3, 1, 2
\end{sphinxVerbatim}

\sphinxAtStartPar
The second master file will be “students\_” + the course abbreviation + “.txt”.
For example \sphinxcode{\sphinxupquote{students\_comp170.txt}}.
It will contain a list of student information
records. Each record (one per input line) will have the following
structure:
\begin{quote}

\sphinxAtStartPar
Student ID, Last Name, First Name
\end{quote}

\sphinxAtStartPar
For example, the sample data file \sphinxcode{\sphinxupquote{students\_comp170.txt}} starts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
P12345678, Doe, John
P00000001, Hernandez, Maria
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
There will be a secondary file for each student,
named after the student id and the course abbreviation and “.data”.
For example,
John’s scores would be kept in a file named
\sphinxcode{\sphinxupquote{P12345678comp170.data}}. Maria’s scores would be in
\sphinxcode{\sphinxupquote{P00000001comp170.data}}. Each record (one per file line will have the
following structure:
\begin{quote}

\sphinxAtStartPar
Category letter, Item, Points Earned
\end{quote}

\sphinxAtStartPar
where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
category letter is the first letter of the category.  With the categories
given in the example above, they would be E, L, H, P, and C.

\item {} 
\sphinxAtStartPar
item is a number within that category (1, 2, 3, …) \sphinxhyphen{}
only used in part of the extra credit.

\item {} 
\sphinxAtStartPar
points earned is a real number

\item {} 
\sphinxAtStartPar
the lines are in no special order.

\end{itemize}

\sphinxAtStartPar
Sample data file \sphinxcode{\sphinxupquote{P12345678comp170.data}} starts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
H, 1, 90
C, 1, 100
L, 3, 100
L, 2, 80
H, 2, 80
E, 1, 90
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The program will process the data from each student file and
calculate the average within each category, and then the weighted overall average.
Also display the letter grade for
each student, using code derived from the previous
assignment.

\item {} 
\sphinxAtStartPar
Your program writes the final report file.
It is named with the course abbreviation
+ “\_summary.txt”.  Example: “comp170\_summary.txt”.
This file must have a line for each student showing the
student’s last name, first name,
weighted average rounded to one decimal place, and letter grade.
File \sphinxcode{\sphinxupquote{comp170\_summary.txt}} would start with lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Doe, John 78.9 C+
Hernandez, Maria 88.2 B+
\end{sphinxVerbatim}

\sphinxAtStartPar
Write this file to the same directory where you found the input data.  Again
the {\hyperref[\detokenize{files/fio:fio}]{\sphinxcrossref{\DUrole{std,std-ref}{FIO Helper Class}}}} is useful.

\item {} 
\sphinxAtStartPar
The rest of the test data for
course abbreviations comp170 and all the data for comp150 is
in the homework directory.
There are also sample solution files for the
summaries (including some extra credit additions at the ends of lines).
Their names end in \sphinxcode{\sphinxupquote{\_solution.txt}} to distinguish them from the
summary files \sphinxstyleemphasis{you} should generate in tests.

\sphinxAtStartPar
While your program should certainly work for course abbreviations comp170 and comp150,
it should also work in general for any data files your refer to
in the defined formats and place in the same folder.

\item {} 
\sphinxAtStartPar
Turn in materials as in the last homework, including a single copy of
the homework source files and a log.txt file for each student, in the
same form as for the last homework.

\end{enumerate}


\subsection{Hints}
\label{\detokenize{appendix/hw-gradefiles:hints}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Read
{\hyperref[\detokenize{files/files:files}]{\sphinxcrossref{\DUrole{std,std-ref}{Files, Paths, and Directories}}}}.
You’re still going to need ReadLine() and
WriteLine() in this assignment, the only difference is that we’ll
get the input from a file instead
of the Console. The parameter syntax will be the same.

\item {} 
\sphinxAtStartPar
For each file line you’ll want to use the {\hyperref[\detokenize{arrays/onedim:split}]{\sphinxcrossref{\DUrole{std,std-ref}{String Method Split}}}},
and then the \sphinxcode{\sphinxupquote{Trim}}
method from {\hyperref[\detokenize{while/stringmethods2:more-string-methods}]{\sphinxcrossref{\DUrole{std,std-ref}{More String Methods}}}} on each part to
remove surrounding spaces. Then
use indexing to get the field of interest. (More below.)

\item {} 
\sphinxAtStartPar
You’ll need an \sphinxstyleemphasis{outer loop} to read the records from the master name
file. You’ll need an \sphinxstyleemphasis{inner loop} (or a loop inside of a function)
to read the records for each student.

\item {} 
\sphinxAtStartPar
When processing the records from a student file, you should process
each one separately and not assumed they are grouped in any
particular order.

\sphinxAtStartPar
This means, specifically, that your program simply reads a record,
decides what category it is in, and updates the \sphinxstyleemphasis{running total} for
that category. Once the entire file has been read, you can compute
the average for each category based on the \sphinxstyleemphasis{number of items} that
\sphinxstyleemphasis{should} be in that category, which may be more than the number
of records in the file for items turned in.

\item {} 
\sphinxAtStartPar
There is no need to \sphinxstyleemphasis{keep} a score
after you’ve read it and immediately used it.
\sphinxstyleemphasis{Do} use an array, however, for the running total
for each category.

\item {} 
\sphinxAtStartPar
In order to deal with a varying number of categories and different
possible first letter codes, you will need to split the category
name line into an array, say

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{categories}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To know where to update data for each category, you can use this
function after you read in a code, to determine the proper index.
It is already in the stub of the solution file
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/grade\_file\_homework\_stub/grade\_files.cs}{grade\_files.cs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Take the first letter code for a catagory, and}
\PYG{+w}{      }\PYG{c+c1}{/// return the index of that category in categories.}
\PYG{+w}{      }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{codeIndex}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{code}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{categories}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{categories}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{categories}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{               }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{l+m}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//required by compiler: shouldn\PYGZsq{}t reach}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You may assume the data is good and the \sphinxhyphen{}1 is never returned,
but the compiler requires this last line.

\item {} 
\sphinxAtStartPar
You cannot have one fixed formula to calculate the final weighted grade,
because you do not know the number of categories when writing the code.
You will have to accumulate parts in a loop.

\item {} 
\sphinxAtStartPar
Test thoroughly!  Be sure to test with and without command line parameter and
with multiple data sets.

\end{enumerate}


\subsection{Grading Rubric (25 points)}
\label{\detokenize{appendix/hw-gradefiles:grading-rubric-25-points}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Get the abbreviation from the command line if it is there. \sphinxstylestrong{{[}2{]}}

\item {} 
\sphinxAtStartPar
Otherwise get the abbreviation from prompting the user. \sphinxstylestrong{{[}1{]}}

\item {} 
\sphinxAtStartPar
Read the categories file and parse lines. \sphinxstylestrong{{[}2{]}}

\item {} 
\sphinxAtStartPar
Deal with each student. \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
Calculate the cumulative grades in each category, reading
a student’s file once, using arrays. \sphinxstylestrong{{[}5{]}}

\item {} 
\sphinxAtStartPar
Calculate the overall grade and letter grade. \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
Generate summary entries. \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
Use functions where there would otherwise be two several\sphinxhyphen{}line blocks of code
differing only in the name of the data evaluated and the name of the
result generated. \sphinxstylestrong{{[}2{]}}

\item {} 
\sphinxAtStartPar
Use good style:  formatting, naming conventions,
meaningful names other than for simple array indices, lack of redundant code. \sphinxstylestrong{{[}4{]}}

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Optional Extra Credit Opportunities!}  You may choose to do
any combination that does not include both of the last two options about missing work.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Format the summary file in nice columns.  Include the grades for each category,
rounded to one decimal place.  Include a heading line.
For example the summary for the repository example Comp150 could start:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Name: Last, First           Avg Gr     E     H     P
Hopper, Grace             100.0 A  100.0 100.0 100.0
\end{sphinxVerbatim}

\sphinxAtStartPar
You may assume the last\sphinxhyphen{}first name field fits in 25 columns.
Copy the first three column headings from above.
The column headings for the categories can just be their one letter code.
Names and letter grades should be left\sphinxhyphen{}justified (padded on the right, by
using a \sphinxstyleemphasis{negative} field width).
See {\hyperref[\detokenize{for/forexamples:left-justification}]{\sphinxcrossref{\DUrole{std,std-ref}{Left Justification}}}}. \sphinxstylestrong{{[}2{]}}

\item {} 
\sphinxAtStartPar
Change the scheme for calculating letter grades to use a function that calculates
the proper grade, where the only \sphinxcode{\sphinxupquote{if}} statement is one simple one
inside a \sphinxstyleemphasis{loop}.  The \sphinxcode{\sphinxupquote{if}} statement will have a \sphinxcode{\sphinxupquote{return}} statement in its body,
and no \sphinxcode{\sphinxupquote{else}}.  The loop will need to use
corresponding arrays of data for grade cutoffs and grade names. \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
For any student who has missed passing in all the required items,
generate extra data on missing work in the summary, at the right end of the
line for the student.  Add this to
whichever version of the earlier parts you use.
Include an addendum starting with “Missing: ”
only if there are not enough grades in one or more
categories.  For each category where
one or more grades is missing, including a count of the number of grades missing followed
by the category letter.  An example using the example categories is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Doe, John 68.5 D+ Missing: 2 L 1 H
Smith, Chris 83.2 B Missing: 1 L
Star, Anna 91.2 A\PYGZhy{}
\end{sphinxVerbatim}

\sphinxAtStartPar
meaning Doe has 2 labs missing and 1 homework missing.  Smith is missing one lab.  Star
has done all assigned work, since nothing is added. The solution files display this
extra credit addition on the ends of lines.  \sphinxstylestrong{{[}3{]}}

\item {} 
\sphinxAtStartPar
This is a much harder alternate version for handling missing work:
Unlike the previous format, do not count and print the number of missing
entries in each category in a form like “2 L “.
Replace such an entry with a list of \sphinxstyleemphasis{each} item
missing, in order, as in “L:1, 4 “, meaning labs 1 and 4 were missing.
Assume that the expected item numbers for a category
run from 1 through the number of grades in the category.
You may assume no item number for the same category appears twice.
For example, with the sample data files given in the repository for
comp170, the summary line for John Doe would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Doe, John 78.9 C+ Missing: L: 1, 4 H: 3
\end{sphinxVerbatim}

\sphinxAtStartPar
The most straightforward way to do this requires something
like an array of arrays, array of lists or array of sets.
You may need to read ahead if you want to use one of these approaches. \sphinxstylestrong{{[}5{]}}

\end{enumerate}

\sphinxstepscope

\index{homework@\spxentry{homework}!booklist@\spxentry{booklist}}\index{booklist homework@\spxentry{booklist homework}}\index{OOP@\spxentry{OOP}!homework@\spxentry{homework}}\ignorespaces 

\section{Homework: Book List}
\label{\detokenize{appendix/hw-booklist:homework-book-list}}\label{\detokenize{appendix/hw-booklist:booklist}}\label{\detokenize{appendix/hw-booklist:index-0}}\label{\detokenize{appendix/hw-booklist::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Objectives}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Complete a simple data storing class (Book), with fields for title, author, and
year of publication.

\item {} 
\sphinxAtStartPar
Complete a class with a Collection (BookList) that uses the public methods
of another class you wrote (Book), and select various data from the list.

\item {} 
\sphinxAtStartPar
Complete a testing program (TestBookList), that creates a
BookList, adds Books to the BookList, and tests BookList
methods clearly and completely for a user looking at the output
of the program and \sphinxstyleemphasis{not} the source code..

\end{itemize}

\sphinxAtStartPar
Copy stub files from the project \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub}{books\_homework\_stub} to your own
project.
Stubs for the assignment files are
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub/book.cs}{book.cs},
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub/book\_list.cs}{book\_list.cs}, and
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub/test\_book\_list.cs}{test\_book\_list.cs},

\sphinxAtStartPar
Some of the method stubs included are only to be fleshed out if you are doing
the corresponding extra credit option.  They include a comment,
just inside the method, \sphinxcode{\sphinxupquote{// code for extra credit}}.
There are also extra files used by the extra credit portion.
They are discussed
in the Extra Credit section at the end of the assignment.

\sphinxAtStartPar
Complete the first line in each file to show your names. At the top of
the Book class include any comments about help in \sphinxstyleemphasis{all} of the classes.

\sphinxAtStartPar
Create methods one at a time, and test them.  Complete \sphinxcode{\sphinxupquote{book.cs}} first,
preferably testing along the way.  (You can write an initial version of the
testing program, so it does not depend on BookList.)  Then add methods to
\sphinxcode{\sphinxupquote{book\_list.cs}}, and concurrently add and run tests in \sphinxcode{\sphinxupquote{test\_book\_list.cs}}.
Testing the Book class first means that when you get to
BookList you can have more confidence that any problems you have are from the latest
part you wrote, not parts written earlier in the class Book.

\sphinxAtStartPar
Remember to have each individual submit a \sphinxstylestrong{log}, \sphinxcode{\sphinxupquote{log.txt}},
in the same format as the last assignment.


\subsection{Book class}
\label{\detokenize{appendix/hw-booklist:book-class}}
\sphinxAtStartPar
See the stub file provided. It should have instance fields for the
author, title, and year (published).

\sphinxAtStartPar
Complete the constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Book}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{title}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{author}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{year}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
that initializes the fields.
(Be careful, as we have discussed in class, when using the same names
for these parameters as the instance variables!)

\sphinxAtStartPar
It should have three standard (one line) getter methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetTitle}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{GetAuthor}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetYear}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ToString}} should return a \sphinxstyleemphasis{single} string spread across three lines,
with no newline at the end.
For example if the \sphinxcode{\sphinxupquote{Book}} fields were
“C\# Yellow Book”, “Rob Miles”, and 2011, the string should appear,
when printed, as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Title: C\PYGZsh{} Yellow Book
Author: Rob Miles
Year: 2011
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{override}} in the heading is important so the compiler knows that this
is the official method for the system to used implicitly to convert the object
to a string.

\sphinxAtStartPar
Remember the use of @ with multi\sphinxhyphen{}line string literals.


\subsection{BookList class}
\label{\detokenize{appendix/hw-booklist:booklist-class}}
\sphinxAtStartPar
It has just one instance variable, already declared:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private}\PYG{+w}{ }\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Book}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It has a constructor (already written \sphinxhyphen{} creating an empty List):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{BookList}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should have public methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// Add book to the list.}
\PYG{+w}{      }\PYG{c+c1}{// The regular assignment version always returns true.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{Addbook}\PYG{p}{(}\PYG{n}{Book}\PYG{+w}{ }\PYG{n}{book}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The regular version should just leave the final \sphinxcode{\sphinxupquote{return true;}}
The extra credit version is more elaborate.

\sphinxAtStartPar
Further methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// List the full descriptions of each book,}
\PYG{+w}{      }\PYG{c+c1}{/// with each book separated by a blank line.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintList}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{//}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// List the titles (only!), one per line, of each book}
\PYG{+w}{      }\PYG{c+c1}{// in the list that is by the specified author.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintTitlesByAuthor}\PYG{p}{(}\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n}{author}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// List the full descriptions of each book printed}
\PYG{+w}{      }\PYG{c+c1}{// in the range of years specified,}
\PYG{+w}{      }\PYG{c+c1}{// with each book separated by a blank line.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{PrintBooksInYears}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{firstYear}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lastYear}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For instance if the list included books published in 1807, 1983, 2004,
1948, 1990, and 2001, the statement

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PrintBooksInYears}\PYG{p}{(}\PYG{l+m}{1940}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{1990}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
would list the books from 1983, 1948, and 1990.


\subsection{TestBookList class}
\label{\detokenize{appendix/hw-booklist:testbooklist-class}}
\sphinxAtStartPar
It should have a \sphinxcode{\sphinxupquote{Main}} program that creates a BookList, adds some books
to it (more than in the skeleton!), and convincingly displays tests of
each of BookList’s methods that exercise all paths through your code.
Check for one\sphinxhyphen{}off errors in PrintBookYears. With all the methods that
print something, the results are easy to see. \sphinxstyleemphasis{Do print a label}, as in
the skeleton, before printing output from each method test, so that the
user of the program can see the correctness of the test
\sphinxstyleemphasis{without any knowledge of the source code}!


\subsection{Grading Rubric}
\label{\detokenize{appendix/hw-booklist:grading-rubric}}
\sphinxAtStartPar
Book class
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}1 point{]} public Book(string title, string author, int year)

\item {} 
\sphinxAtStartPar
{[}1{]} public string GetTitle()

\item {} 
\sphinxAtStartPar
{[}1{]} public string GetAuthor()

\item {} 
\sphinxAtStartPar
{[}1{]} public int GetYear()

\item {} 
\sphinxAtStartPar
{[}2{]} public override string ToString()

\end{itemize}

\sphinxAtStartPar
BookList class
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}2{]} public bool AddBook(Book book)

\item {} 
\sphinxAtStartPar
{[}2{]} public void PrintList()

\item {} 
\sphinxAtStartPar
{[}2{]} public void PrintTitlesByAuthor(string author)

\item {} 
\sphinxAtStartPar
{[}2{]} public void PrintBooksInYears(int firstYear, int lastYear)

\end{itemize}

\sphinxAtStartPar
TestBookList
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}2{]} Supply data to screen indicating what test is being done with what
data and what results, so it is clear that each test works without
looking at the source code.

\item {} 
\sphinxAtStartPar
{[}5{]} Convincingly display tests of each of BookList’s methods that
exercise all paths through your code.

\end{itemize}

\sphinxAtStartPar
Overall:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}4{]} Make your code easy to read \sphinxhyphen{} follow indenting standards, use
reasonable identifier names….  Do not duplicate code when
you could call a method already written.

\end{itemize}


\subsection{Extra Credit}
\label{\detokenize{appendix/hw-booklist:extra-credit}}
\sphinxAtStartPar
You may do any of the numbered options, except that the last one
requires you to do the previous one first.

\sphinxAtStartPar
To get full credit for any particular option, tests for it must be
\sphinxstyleemphasis{fully integrated} into TestBookList!
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}2 points{]} Complete

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Return a single string containing the same data as}
\PYG{+w}{      }\PYG{c+c1}{/// printed by PrintList, including a final newline.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k}{override}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{n+nf}{ToString}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Also \sphinxstyleemphasis{change} the \sphinxcode{\sphinxupquote{PrintList}} method body to the one line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
(The \sphinxcode{\sphinxupquote{Write}} and \sphinxcode{\sphinxupquote{WriteLine}} methods print objects by using their
\sphinxcode{\sphinxupquote{ToString}} methods.)

\sphinxAtStartPar
Be sure to make this addition to TestBookList:
Test the \sphinxcode{\sphinxupquote{ToString}} method by converting the
resulting BookList description string to upper case before printing it
(which should produce a different result than the regular mixed case of
the \sphinxcode{\sphinxupquote{PrintList}} method test).

\item {} 
\sphinxAtStartPar
{[}4 points{]}

\sphinxAtStartPar
In the Book class, a new constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Construct a Book, taking data from reader.}
\PYG{+w}{      }\PYG{c+c1}{/// Read through three lines that contain the}
\PYG{+w}{      }\PYG{c+c1}{/// title, author, and year of publication, respectively.}
\PYG{+w}{      }\PYG{c+c1}{/// There may be an extra blank line at the beginning.}
\PYG{+w}{      }\PYG{c+c1}{/// If so ignore it.}
\PYG{+w}{      }\PYG{c+c1}{/// Nothing beyond the line with the year is read.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{Book}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In class BookList, a new constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// Construct a new BookList using Book data read from}
\PYG{+w}{      }\PYG{c+c1}{// reader.  The data coming from reader will contain groups}
\PYG{+w}{      }\PYG{c+c1}{// of three line descriptions useful for the Book constructor}
\PYG{+w}{      }\PYG{c+c1}{// that reads from a stream.  Each three\PYGZhy{}line book description}
\PYG{+w}{      }\PYG{c+c1}{// *may or may not* be preceded by an empty line.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{n+nf}{BookList}\PYG{p}{(}\PYG{n}{StreamReader}\PYG{+w}{ }\PYG{n}{reader}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For testing we included special files in the right format:
\sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub/books.txt}{books\_homework\_stub/books.txt} and \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/books\_homework\_stub/morebooks.txt}{books\_homework\_stub/morebooks.txt}.

\sphinxAtStartPar
You will also want to include a reference to \sphinxhref{https://github.com/LoyolaChicagoBooks/introcs-csharp-examples/blob/master/fio/fio.cs}{fio/fio.cs}, so the text files are
easy to find.

\item {} 
\sphinxAtStartPar
{[}4 points{]}

\sphinxAtStartPar
In class Book:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// Return true if all the corresponding fields in this Book}
\PYG{+w}{      }\PYG{c+c1}{// and in aBook are equal.  Return false otherwise.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsEqual}\PYG{p}{(}\PYG{n}{Book}\PYG{+w}{ }\PYG{n}{aBook}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}\PYG{+w}{  }\PYG{c+c1}{// code for extra credit}

\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//so skeleton compiles}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is essential to have the \sphinxcode{\sphinxupquote{IsEqual}} method working in Book before any of
the new code in BookList, which all depends on the definition of \sphinxcode{\sphinxupquote{IsEqual}}
for a Book.

\sphinxAtStartPar
NOTE: We chose the name \sphinxcode{\sphinxupquote{IsEqual}} to distinguish it from the
more general \sphinxcode{\sphinxupquote{Equals}} override that you could write.
The \sphinxcode{\sphinxupquote{Equals}} override allows for a parameter of any object type. With
skills from Comp 271 you you be able to write the \sphinxcode{\sphinxupquote{Equals}} override.

\sphinxAtStartPar
In class BookList:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// Test if aBook is contained in this BookList.}
\PYG{+w}{      }\PYG{c+c1}{// Return true if book IsEqual to a Book in the list,}
\PYG{+w}{      }\PYG{c+c1}{// false otherwise.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{Contains}\PYG{p}{(}\PYG{n}{Book}\PYG{+w}{ }\PYG{n}{book}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Caution: Do NOT try to use the \sphinxcode{\sphinxupquote{List}} method \sphinxcode{\sphinxupquote{Contains}}: Because we
did \sphinxstyleemphasis{not} override the \sphinxcode{\sphinxupquote{Equals}} method to specialize it for Books, the \sphinxcode{\sphinxupquote{List}}
method \sphinxcode{\sphinxupquote{Contains}} will \sphinxstyleemphasis{fail}. You need to do a litle bit more
work and write your own version with a loop.

\sphinxAtStartPar
Change the \sphinxcode{\sphinxupquote{AddBook}} method from the regular assignment, so it
satisfies this documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{/// Adds aBook to the list if aBook is}
\PYG{+w}{      }\PYG{c+c1}{/// not already in the list.}
\PYG{+w}{      }\PYG{c+c1}{/// Return true if aBook is added,}
\PYG{+w}{      }\PYG{c+c1}{/// and false if it was already in the list.}
\end{sphinxVerbatim}

\sphinxAtStartPar
In TestBookList you need to react to the return value, too.

\item {} 
\sphinxAtStartPar
{[}2 points{]} This one requires the previous elaboration of \sphinxcode{\sphinxupquote{AddBook}}.
In BookList:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }\PYG{c+c1}{// Add each Book in books to this BookList.}
\PYG{+w}{      }\PYG{c+c1}{// if it is not already contained in this BookList.}
\PYG{+w}{      }\PYG{c+c1}{// Return true if the current list was changed.}
\PYG{+w}{      }\PYG{c+c1}{// Return false if each Book in books is a}
\PYG{+w}{      }\PYG{c+c1}{// duplicate of a Book in the current list.}
\PYG{+w}{      }\PYG{k}{public}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{AddAll}\PYG{p}{(}\PYG{n}{BookList}\PYG{+w}{ }\PYG{n}{books}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You might want to code it first without worrying about the correct
return value; then do the complete version. There are multiple
approach to determining the return value, some much easier than
others!

\sphinxAtStartPar
To fully test in TestBookList, you need to react to the return value, too.

\end{enumerate}

\sphinxstepscope


\section{Group Project}
\label{\detokenize{appendix/project:group-project}}\label{\detokenize{appendix/project:id1}}\label{\detokenize{appendix/project::doc}}

\subsection{Objectives}
\label{\detokenize{appendix/project:objectives}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Being creative, imagining and describing a program, and working it
through to completion

\item {} 
\sphinxAtStartPar
Working in a team:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Communicating to each other

\item {} 
\sphinxAtStartPar
Dividing responsibilities

\item {} 
\sphinxAtStartPar
Helping each other

\item {} 
\sphinxAtStartPar
Finding consensus

\item {} 
\sphinxAtStartPar
Dealing with conflict

\item {} 
\sphinxAtStartPar
Providing process feedback

\item {} 
\sphinxAtStartPar
Integrating parts created by several people

\end{itemize}

\item {} 
\sphinxAtStartPar
Developing new classes to fit your needs

\item {} 
\sphinxAtStartPar
Using the .Net API library

\item {} 
\sphinxAtStartPar
Designing a program for refinement

\item {} 
\sphinxAtStartPar
Testing

\item {} 
\sphinxAtStartPar
Evolving a program

\item {} 
\sphinxAtStartPar
Creating documentation for user and implementers

\item {} 
\sphinxAtStartPar
Programming in the large \textendash{} not a small predefined problem

\item {} 
\sphinxAtStartPar
Make something that is fun

\end{itemize}

\sphinxAtStartPar
See the project \sphinxcode{\sphinxupquote{csproject\_stub}}, already discussed in class.

\sphinxAtStartPar
\sphinxstylestrong{What to turn in:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Periodic reports

\item {} 
\sphinxAtStartPar
intermediate implementation

\item {} 
\sphinxAtStartPar
a final presentation

\item {} 
\sphinxAtStartPar
a final implementation
including user and programmer documentation and process documentation

\item {} 
\sphinxAtStartPar
individual evaluations

\end{itemize}


\subsection{Overview}
\label{\detokenize{appendix/project:overview}}
\sphinxAtStartPar
You will be assigned to groups of 3\sphinxhyphen{}4 people to work on a project that
will extend until the end of the semester, with only a little other work
introduced in class, and of course your last exam. This leaves a month
of course time (in a regular semester)
for the project (classes, labs, dedicated homework time),
ending with presentations in final exam period. Your group will be
designing and implementing a project of your choosing.  You could
choose to make a text based game, starting from our game skeleton or not,
or something completely different, started from scratch.
The project should have some clear focus or aim,
For instance a game should be able to be won.

\sphinxAtStartPar
Start by brainstorming and listing ideas \textendash{} do not criticize ideas at
this point. That is what is meant by brainstorming \sphinxhyphen{} having your internal critic
going inhibits creativity. After you have a large list from
brainstorming, it is time to think more practically and settle on one
basic situation, and think of a considerable list of features you would
like it to have. Order the features, considering importance, apparent ease of
development, and what depends on what else. Get something simple
working, and then add a few features at a time, testing the pieces added
and the whole project so far. Test, debug, and make sure the program
works completely before using your past experience to decide what to add
next. This may different than what you imagined before the work on your
first stage! Like the provided project, early stages do not need
to be full featured, but make sure that you are building up to a version
with an aim, and which includes interesting features. You should
end with a program that has enough instructions provided for the user, so
someone who knows \sphinxstyleemphasis{nothing} of your implementation process or intentions
can use the program successfully. Your implementation should also be
documented, imagining that a new team of programmers is about to take
over after your departure, looking to create yet another version.


\subsection{Your Team}
\label{\detokenize{appendix/project:your-team}}
\sphinxAtStartPar
Your instructor will tell you about team makeup.

\sphinxAtStartPar
There are a number of roles
that must be filled by team members. Some will be shared between all
members, like coder, but for each role there should be a lead person who
makes sure all the contributions come together. Each person will have
more than one role. All members are expected to pull their own weight,
though not all in exactly the same roles. Everyone should make sustained
contributions, every week, documented in the weekly reports. Understand
that this project will be the major course commitment for the rest of
the semester.  These roles vary from rather small to central.
Not all are important immediately.


\subsection{Roles}
\label{\detokenize{appendix/project:roles}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Leader: Makes sure the team is coordinated, encourage consensus on
the overall plan, oversee that the agreements are carried through, be
available as contact person for the team and the TA and your instructor.

\item {} 
\sphinxAtStartPar
Lead programmer: Keep track of different people’s parts to make sure
they fit together.

\item {} 
\sphinxAtStartPar
Coder/unit tester: \sphinxstyleemphasis{Everyone} must have a significant but not
necessarily equal part in this job. Each person should have primary
responsibility for one or more cohesive substantive units, and code
and test and be particularly familiar with those parts. Do your best
to make individual parts be cohesive and loosely coupled with other
people’s work, to save a lot of pain in the testing and debugging
phase. When coding you are still encouraged to do pair programming,
though what pair from the team is working together at different times
may be fluid. The lead programmer might be involved in pairs more
often than others, but be sure the other coders get to drive often.

\item {} 
\sphinxAtStartPar
Librarian/version coordinator: The default should be for you to have a
box.com folder shared with your whole team and me and your TA, with all
as editors.  Your folder should have the name of your team.
You should always have a folder that contains the latest working version
of the project.  You should also keep old versions, for instance copied into
numbered version folders.
Box does not handle successive versions automatically.
You can choose
to use the more capable professional combination of
Bitbucket and {\hyperref[\detokenize{appendix/hgteamwork:hg-and-teamwork}]{\sphinxcrossref{\DUrole{std,std-ref}{Mercurial and Teamwork}}}}.
The latter will have a learning curve, and in that case this person
should be the best informed on Mercurial, and help
the other team members.

\item {} 
\sphinxAtStartPar
Report coordinator: Gather the contributions for reports from team
members and make sure the whole reports get to posted on schedule.
Your instructor needs
a clear idea of the contributions of each member each week. If a team
member is not clear on this to the report writer,
\sphinxstyleemphasis{the report writer needs to be insistent}.

\item {} 
\sphinxAtStartPar
Instruction coordinator: Make sure there are clear written documents
and help within the program for the user, who you assume is not a
C\# programmer and knows nothing about your program at the start.

\item {} 
\sphinxAtStartPar
Documentation coordinator: Make sure the documentation
is clear for method users/consumers.
This includes the documentation for programmers
before the headings of methods and classes.
This is for any time someone wants to use (not rewrite) a class or
method you wrote.
Also have implementer documentation, for someone who will
want to modify or debug your code and needs to understand the
details of your internal implementations.  The extent of this
can be greatly minimized by good naming.

\item {} 
\sphinxAtStartPar
Quality manager: Take charge of integrated tests of the whole program
(following coder’s unit tests). Make sure deficiencies are addressed.

\end{enumerate}

\sphinxAtStartPar
Conflict resolution: You will certainly have disagreements and possibly
conflicts. Try to resolve them within the team. When that is not
working, anyone can go to the instructor with a problem.  Do not delay
coming to me if things are clearly not working with the team.


\subsection{The process}
\label{\detokenize{appendix/project:the-process}}
\sphinxAtStartPar
Initial:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Agree on roles. These roles can change if necessary, but you are
encouraged to stick with them for simplicity and consistency.

\item {} 
\sphinxAtStartPar
Agree on a team name and a short no\sphinxhyphen{}space abbreviation if necessary,
and let me know it.

\item {} 
\sphinxAtStartPar
Brainstorm about the project. Distill the ideas into a direction and
overall goals.

\end{enumerate}

\sphinxAtStartPar
On individual versions (Two formal versions will be required):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Break out specific goals for the version. How are you heading for
your overall goals? Are you biting off a significant and manageable
amount? You are expected to check in with me on this part and 2 and 3
before moving very far. This will be new for most of you.

\item {} 
\sphinxAtStartPar
Plan and organize the necessary parts and the interfaces between the
parts.

\item {} 
\sphinxAtStartPar
Write the interface documentation for consumers of the code
for the parts you plan to write.
Agree on them. You need to do this eventually anyway. Agreement up
front can save you an enormous amount of time! Do not let the gung\sphinxhyphen{}ho
hackers take off before you agree on documented interfaces.
We have seen it happen:  If you do not put your foot down,
you are stuck with a bad plan that will complicate things.  Otherwise lots
of code needs to be rethought and rewritten.

\item {} 
\sphinxAtStartPar
If more than one person is working on the same class, plan the names,
meanings, and restrictions on the private instance variables \textendash{} all
coders should be assuming the same things about the instance
variables! Also agree on documentation for any private helping methods you
share.

\item {} 
\sphinxAtStartPar
Code to match the agreed consumer interface and class implementation
designs.

\item {} 
\sphinxAtStartPar
Check each other’s code.

\item {} 
\sphinxAtStartPar
Do unit tests on your own work, and fix them and test again…

\item {} 
\sphinxAtStartPar
Do overall tests of everything together, and fix and test again…

\item {} 
\sphinxAtStartPar
Look back at what you did, how it went, what you could do better, and
what to change in your process for the next version.

\end{enumerate}

\sphinxAtStartPar
You are strongly encouraged to follow modern programming practice which
involves splitting each of these formal versions into much smaller steps
that can be completed and tested following a similar process. Order
pieces so you only need to code a little bit more before testing and
combining with pieces that already work. This is enormously helpful in
isolating bugs! This is really important. If you thought you spent a
long while fighting bugs in your small homework assignment, that is
nothing compared to the time you can spend with a large project,
particularly if you make a lot of haphazard changes all at once.


\subsection{Splitting Up The Coding}
\label{\detokenize{appendix/project:splitting-up-the-coding}}
\sphinxAtStartPar
Make good use of the
separation of public interface and detailed implementation.
If your project has loosely coupled class, the main part of the
public interface should be limited and easy to comprehend.

\sphinxAtStartPar
Ideally have one individual
(or pair) assigned a whole class. One useful feature for allowing
compiling is to first generate a stub file like we have given you for
homework, that includes the public interface documentation,
headings, and dummy return values
and compiles but does nothing.
\sphinxstyleemphasis{Post this under a box folder for the current version number.}
You will then provide your team members
with something that tells them what they can use and allows them to
compile their own part. Then later substitute more functional classes.

\sphinxAtStartPar
Your instructor and you will want to review your code. We do not want to have to
reread almost the same thing over and over: Use the editor copy command
with extreme caution. If you are considering making an exact copy,
clearly use a common method instead. If you copy and then make
substitutions in the same places, you are likely better off
with a method with the common parts and with parameters inserted where there
are differences.  You can make a quick test with a
couple of copied portions, but then
\sphinxstyleemphasis{convert to using a method with parameters for the substitutions}.
Besides being a waste of effort to define seven methods each
defining a tool, with just a few strings differing from one method to
the next, we will require you to rewrite it, with one method with
parameters, and just seven different calls to the method with different
parameters. Save yourself trouble and do it that way the first time, or
at least after you code a second method and see how much it is like the
first one you coded….

\sphinxAtStartPar
If you are making many substitutions
of static textual data, put the data into a resource file in a variation
of the Fake Advise Lab.

\sphinxAtStartPar
You only want to commit working code into the shared current version folder.
Comment out incomplete additions that you want to show to everyone,
or comment out the call to a method that compiles but does not yet
function logically.  An alternative is to have a separate folder for
in\sphinxhyphen{}process code to share for comment,
so you will not try to compile it with the current working version.


\subsection{Weekly reports}
\label{\detokenize{appendix/project:weekly-reports}}
\sphinxAtStartPar
Reports are due from the report writer each Tuesday.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Inside your team’s box folder have a subfolder called WeeklyReports.
A sample stub form to fill out on the computer is in
\sphinxhref{http://anh.cs.luc.edu/170/examples/Weekly-Report.rtf}{Weekly\sphinxhyphen{}Report.rtf}.
Make the name of each weekly
report document be the date it was due, like Mar26.rtf.
It is easy
to copy the table from this week to last week and edit it to show
how much your plans matched reality.
You should post a version for your team to look at first.  Please distinguish
drafts from the final version for me to look at.   You might have a separate
folder Drafts, and move the report into the WeeklyReport folder when
it is final. Box easily allows moving files, but not renaming them.

\item {} 
\sphinxAtStartPar
Only one report should be generated each week, with the person in the role of
report writer making sure a complete version is produced and placed in the
WeeklyReport folder.

\item {} 
\sphinxAtStartPar
Under plans for the next week, include concrete tasks planned to be
completed, and who will do them, with an informative
explanation.  The content and depth of the person’s work should be clear.
If you can state that clearly and be brief, great.
The tasks do not only include coding: they can be any of the
parts listed above, and for any particular part of the project, where
that makes sense.  \sphinxstyleemphasis{If individuals cannot state clearly what they are working on,}
\sphinxstyleemphasis{then the team leader and lead coder have a significant issue in their leadership}
\sphinxstyleemphasis{that needs to be addressed.}

\item {} 
\sphinxAtStartPar
In the review of the last week (after the first week) include the
last week’s plans and what actually happened, task by task,
concretely, with enough detail to give an idea on the magnitude
of the work. This can include the portion completed and/or changes in
the plans and their reasons. “Still working on X” is not useful: Who
was doing what? What methods, doing what, were completed? Which are
in process? Which are being debugged? What part remains to be done,
and who is it assigned to? The report writer is responsible to get a
clear statement from each team member.

\end{enumerate}


\subsection{Intermediate deliverables}
\label{\detokenize{appendix/project:intermediate-deliverables}}
\sphinxAtStartPar
These materials should be placed in a subfolder \sphinxstylestrong{Intermediate}
of your team project folder.
See the due date in the schedule.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Copy the linked stub of
\sphinxhref{http://anh.cs.luc.edu/170/examples/projectPlans.rtf}{projectPlans.rtf} document.
Then complete it:
\begin{itemize}
\item {} 
\sphinxAtStartPar
List the project roles again, and who ended up filling them. For
coding, say who was the person primarily responsible for each
part.

\item {} 
\sphinxAtStartPar
If you used old classes, like those from the skeleton project or a lab or
somewhere else, say which ones are included \sphinxstyleemphasis{unchanged} or give a
summary of changes.

\item {} 
\sphinxAtStartPar
If your documentation of methods is not generally done,
say what classes got clear documentation (or individual methods if only
some were done).

\item {} 
\sphinxAtStartPar
Where are you planning to go from here, and who you envision being
primarily responsible for different parts?

\end{itemize}

\item {} 
\sphinxAtStartPar
Include parts 2\sphinxhyphen{}4 listed below under Final Deliverables, but for an
intermediate version that runs, and does \sphinxstyleemphasis{not} need to have the goal
working yet. Have documentation of your methods, including summary description
and description of parameters and return values.
If for some reason you do not have all the documentation that you were encouraged
to write \sphinxstyleemphasis{first}, at least be sure to have and point out significant examples of your
clear documentation of purpose, parameters, and return values.
This allows instructor feedback
for completing the rest.

\item {} 
\sphinxAtStartPar
The idea is to have everyone get an idea of what is expected, so we
have no misunderstandings about the final version. We will give you
feedback from this version to incorporate in the final version. We do
not want to have to say anyone did anything “wrong” on the final
version. We want to be able to concentrate on your creative
accomplishments.

\item {} 
\sphinxAtStartPar
Look through the list of deliverables again and make sure your collection is complete.

\end{itemize}


\subsection{Final Deliverables}
\label{\detokenize{appendix/project:final-deliverables}}
\sphinxAtStartPar
\sphinxstylestrong{Group Submission}:

\sphinxAtStartPar
One submission of the group work is due one hour before the final presentations.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
All files listed in parts 2\sphinxhyphen{}5.
Also include a zip file, named with your team abbreviation,
containing a Windows executable with (a separate copy of) any other
image and data files needed.  Test to make sure you can
unzip and run the executable.
The final submissions will be accessible to the whole class
\textendash{} so we can all play them!

\item {} 
\sphinxAtStartPar
Source code. You can name the classes appropriately
for the content of your game.

\item {} 
\sphinxAtStartPar
User instructions. These should be partly built into the program. The
most extensive documentation may be in a document file separate from
the program, if you like. (Plain text, MS Word, Rich text (rtf), or
PDF, please.) The starting message built into the beginning of the
game should mention the file name of such external documentation, if
you have it.

\item {} 
\sphinxAtStartPar
Programmer documentation. Document the public interface for all
methods in comments directly before the method heading.
Add implementation comments
embedded in the code where they add clarity (not just verbosity). You
may have a separate overview document.  Include “Overview” in the
file name

\item {} 
\sphinxAtStartPar
Overall project and process review in a document named like the linked stub,
\sphinxhref{http://anh.cs.luc.edu/170/examples/projectReview.rtf}{projectReview.rtf}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first section should be Changes. So the instructor does not
duplicate effort, please give an overview of the changes from the
intermediate version. What classes are the same? What features
were added? What classes are new? Which classes or methods were
given major rewrites? What classes had only a few changes? (In
this case try to list what to look for.)

\item {} 
\sphinxAtStartPar
List again the roles, and who filled them. For coding, say who was
the person primarily responsible for each part.

\item {} 
\sphinxAtStartPar
What did you learn? What were the biggest challenges? What would
you do differently the next time? What are you most proud of?

\item {} 
\sphinxAtStartPar
How could we administer this project better? What particularly
worked about the structure we set up?

\end{itemize}

\item {} 
\sphinxAtStartPar
A 10\sphinxhyphen{}15 minute presentation of your work to the class in final exam
period. What would you want to hear about other projects? (Say it
about yours.) What was the overall idea? What was the overall
organization? What did you learn that was beyond the regular class
topics that others might find useful to know? What were your biggest
challenges? Do not show off all your code just because it is there.
Show specific bits that gave you trouble or otherwise are
instructive, if you like.

\end{enumerate}

\sphinxAtStartPar
Look through the list of deliverables again, before sending files,
and check with the whole team to make sure your collection is complete.

\sphinxAtStartPar
\sphinxstylestrong{Your Assessment of Individuals in the Group}:

\sphinxAtStartPar
This is due electronically 10 minutes after the final class presentation period,
from each team member, \sphinxstyleemphasis{independently}, turned in a manner specified by your
instructor, like other homework assignments.

\sphinxAtStartPar
Change the name of the linked stub file
\sphinxhref{http://anh.cs.luc.edu/170/examples/Indiv-Mem-Assessment.rtf}{Indiv\sphinxhyphen{}Mem\sphinxhyphen{}Assessment.rtf}
to your
teamAbbreviation\sphinxhyphen{}yourName.rtf.
You may want to tweak it after the
group presentation, but have it essentially done beforehand.

\sphinxAtStartPar
Writing this is NOT a part of your
collective group deliberations. It is individual in two senses: both
in being about individual team members and in being the view of \sphinxstyleemphasis{one}
individual, you. For this document only, everyone should be writing
separately, privately, and independently from individual experience.
If you lack data on some point, say so, rather than using what others are saying.

\sphinxstepscope

\index{labs@\spxentry{labs}!hg and version control@\spxentry{hg and version control}}\index{version control lab@\spxentry{version control lab}}\index{hg@\spxentry{hg}}\ignorespaces 

\section{Lab: Version Control}
\label{\detokenize{appendix/lab-versioncontrol:lab-version-control}}\label{\detokenize{appendix/lab-versioncontrol:lab-versioncontrol}}\label{\detokenize{appendix/lab-versioncontrol:index-0}}\label{\detokenize{appendix/lab-versioncontrol::doc}}
\sphinxAtStartPar
Modern software development requires an early introduction source code
management, also known as version control. While source code
management is frequently touted as being beneficial to a \sphinxstyleemphasis{project
team}, it is also of great value for \sphinxstyleemphasis{individuals} and provides a
clear mechanism for tracking, preserving, and sharing your work.

\sphinxAtStartPar
In addition, it simplifies the process of demonstrating and submitting
your work to your instructor (and graduate assistants). Long gone are
the days of carrying stuff around on USB drives and sending e\sphinxhyphen{}mail
attachments.

\sphinxAtStartPar
There are numerous options for version control. In the free/open
source community, a number of solutions have emerged, including some
old (CVS, Subversion) and some new (Mercurial, Git, and Bazaar). We’re
particularly fond of the Mercurial system. A key reason for our choice
is that there is an excellent cloud\sphinxhyphen{}based solution to host your
projects known as Bitbucket (\sphinxurl{http://bitbucket.org}).

\sphinxAtStartPar
Mercurial is set up for our labs.  You can install it for your
personal machine from \sphinxurl{http://mercurial.selenic.com/downloads/} .

\sphinxAtStartPar
There are other similar solutions to Bitbucket but none at present
provides a completely \sphinxstyleemphasis{free} solution for hosting \sphinxstyleemphasis{private}
repositories, which allow you to keep your work \sphinxstyleemphasis{secret} from others.

\sphinxAtStartPar
The basic idea is to keep a main current copy of a project at a place
like bitbucket.  Anywhere that you work, you can download a copy of the
central version.  You can add and change files.  There are several
layers insulating changes to local files from changes to the
central repository:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You must explicitly \sphinxstyleemphasis{add} any new file names you want the repository to track.

\item {} 
\sphinxAtStartPar
Even on a tracked file, you must \sphinxstyleemphasis{commit} changes to the local repository.

\item {} 
\sphinxAtStartPar
For the committed changes to get to the central repository, you must \sphinxstyleemphasis{push} them.

\item {} 
\sphinxAtStartPar
You have control over what files get ignored.

\end{itemize}

\sphinxAtStartPar
Later, when you want the latest changes to the central repository to get to your
site, you need to \sphinxstyleemphasis{pull} data from the central repository, and then explicitly
\sphinxstyleemphasis{update} your local repository, to incorporate the new data from the central
repository.


\subsection{Goals}
\label{\detokenize{appendix/lab-versioncontrol:goals}}
\sphinxAtStartPar
In this lab, we’re going to learn:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
How to create a source code repository.

\item {} 
\sphinxAtStartPar
How to add files and folders to a repository and track them.

\item {} 
\sphinxAtStartPar
How to make sure certain files and folders are not kept in the repository.

\item {} 
\sphinxAtStartPar
How to push your changes to a remote repository (at Bitbucket.org).

\item {} 
\sphinxAtStartPar
How to do your work at home and in the lab.

\item {} 
\sphinxAtStartPar
How to get our book, examples, and projects (now that that you know how
to use Mercurial).

\end{enumerate}


\subsubsection{Before We Proceed}
\label{\detokenize{appendix/lab-versioncontrol:before-we-proceed}}
\sphinxAtStartPar
You should know that this lab is designed to be repeated as many times
as needed. You can create as many repositories as you wish, subject to
the limitations at Bitbucket.org, and may want to create different
repositories for different needs (one for yourself, one for you and
your partner in pair programming, etc.) This lab assumes you are
starting with a repository for your own work. We’ll include a step for
how to add a \sphinxstyleemphasis{collaborator} to the project.

\sphinxAtStartPar
Future labs will talk about additional things you need to know when it comes
to collaboration, so please view this lab as a \sphinxstyleemphasis{beginning} aimed at helping
you to start using version control right away for your own projects.


\subsection{Steps}
\label{\detokenize{appendix/lab-versioncontrol:steps}}
\index{bitbucket.org@\spxentry{bitbucket.org}}\ignorespaces 

\subsubsection{Create Bitbucket.org account}
\label{\detokenize{appendix/lab-versioncontrol:create-bitbucket-org-account}}\label{\detokenize{appendix/lab-versioncontrol:index-1}}
\sphinxAtStartPar
We’re going to begin by creating a remote repository for our work. The
advantage of doing so is that we get a \sphinxstyleemphasis{hosted} repository that we can
use to push/pull our work. (Unlike a dangerous stunt, you \sphinxstyleemphasis{want} to be able
to try this at home, too!)

\sphinxAtStartPar
Signing up for a repository at \sphinxurl{http://bitbucket.org} is easy. From the
landing page, just click on the option for the \sphinxstyleemphasis{Free Plan}. This allows
you to create any number of public/private repositories with support
for up to 5 users. This is all you’ll need for your work in this course.

\sphinxAtStartPar
Once you’ve created your account (and confirmed it, if required) you
are good to go for the rest of this lab!


\subsubsection{Create repository at Bitbucket}
\label{\detokenize{appendix/lab-versioncontrol:create-repository-at-bitbucket}}
\sphinxAtStartPar
Now we’ll create a first repository at Bitbucket.org.

\sphinxAtStartPar
Go to \sphinxcode{\sphinxupquote{Repositories \sphinxhyphen{}\textgreater{} Create Repository}} (the option is at the bottom
of the list of menu options). You’ll see this screen:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{hgcreaterepository}.png}\hspace*{\fill}}

\sphinxAtStartPar
You’ll need to fill in or select the following options:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Name: A short name for your project. You are encouraged to keep this
simple.  If you are using this for all of your work in COMP 170
(which is fine) you might name the repository after your
initials. So if your name is Linus Torvalds, you could give a short
name like \sphinxstyleemphasis{LinusTorvaldsCOMP170} or \sphinxstyleemphasis{LTCOMP170}.

\item {} 
\sphinxAtStartPar
Repository Type: Select Mercurial. Yes, we realize that Xamarin Studio
supports Git natively, but for the reasons mentioned earlier, we
have chosen Mercurial. We will allow you to use Git on your own if
you can figure it out and use it properly. But this lab assumes
Mercurial.

\item {} 
\sphinxAtStartPar
Language: You can select anything you like here. We do C\# for the
most part in this class, so we recommend that you select it.

\item {} 
\sphinxAtStartPar
Description: You can give any description you like. If you are
working with a partner please list both you and your partner’s name
in the description.

\item {} 
\sphinxAtStartPar
Web Site: Optional

\item {} 
\sphinxAtStartPar
Private checkbox should be checked.

\end{itemize}

\sphinxAtStartPar
So just go ahead and create your first repository. You can always
create more of them later.

\sphinxAtStartPar
Here is an example of a filled out form:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{hgcreaterepository2}.png}\hspace*{\fill}}


\subsubsection{Set up your Mercurial commit username}
\label{\detokenize{appendix/lab-versioncontrol:set-up-your-mercurial-commit-username}}
\sphinxAtStartPar
If you in a place where you have a permanent home directory,
like on your machine or in the Linux Lab,
create a file named \sphinxcode{\sphinxupquote{.hgrc}} in \sphinxstyleemphasis{your home directory}. Your home directory is
where you are dumped when you open a DOS or Linux/OS X terminal.  This is \sphinxstyleemphasis{not}
inside your repository.
This file must contain the following lines, with the part after the equal sign
personalized for you:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+na}{[ui]}
\PYG{n}{username}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{John}\PYG{+w}{ }\PYG{n}{Doe}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{n}{johndoe}\PYG{n}{@johndoe}\PYG{p}{.}\PYG{n}{com}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is a convention to give a name and email address, though
it does not need to match the email address you gave when
signing up for bitbucket.

\sphinxAtStartPar
Creating this file saves you the trouble of having to pass the \sphinxcode{\sphinxupquote{\sphinxhyphen{}u username}}
option to \sphinxcode{\sphinxupquote{hg}} each time you do a \sphinxstyleemphasis{commit} operation.

\sphinxAtStartPar
You can put this file in your home directory in Windows labs, but it disappears.
You might want to keep an extra copy in your repository, and copy it to the Windows
home folder when in the lab.

\sphinxAtStartPar
As a gentle reminder, your home directory on Windows can be a bit difficult to find.
The easiest way is to use your editor to locate your home folder.
When in the DOS prompt, you will also see the path to your directory as part of the prompt.
For example, on Windows 7, you will see \sphinxcode{\sphinxupquote{C:\textbackslash{}Users\textbackslash{}johndoe}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
To ensure that you did this step correctly, please open a \sphinxstyleemphasis{new} terminal or DOS
window at this time and use the \sphinxcode{\sphinxupquote{ls}} or \sphinxcode{\sphinxupquote{dir}} command to verify that the \sphinxcode{\sphinxupquote{.hgrc}}
file is indeed present in your home directory. If it is in any other folder, Mercurial
(the \sphinxstylestrong{hg} command) will not be able to find it\textendash{}and you will receive an error.
\end{sphinxadmonition}


\subsubsection{Clone a repository from Bitbucket}
\label{\detokenize{appendix/lab-versioncontrol:clone-a-repository-from-bitbucket}}
\sphinxAtStartPar
Open a terminal or DOS command shell.

\sphinxAtStartPar
On Windows, the Mono shell is not appropriate. You can get a regular DOS
command shell by clicking the start menu and typing \sphinxcode{\sphinxupquote{cmd}} and into the text box
at the bottom of the start menu, and pressing return.

\sphinxAtStartPar
In the terminal/DOS\sphinxhyphen{}shell navigate with to the the directory
where you want to place the repository
as a sub\sphinxhyphen{}directory.  This could be your home directory on your machine or
a flash drive in a lab.

\sphinxAtStartPar
\sphinxstylestrong{Windows only}:
To navigate in a DOS\sphinxhyphen{}Shell to a flash drive, you need to enter the short command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{E}\PYG{p}{:}
\end{sphinxVerbatim}

\sphinxAtStartPar
or possible another drive letter followed by a colon.
DOS drive letters are annoying because they be different another time with different
resources loaded.  Once you see the proper drive displayed, \sphinxcode{\sphinxupquote{cd}} to the desired
directory.

\sphinxAtStartPar
If all has gone well at bitbucket, you should be able to look at your
bitbucket site and see your new repository on the
list of repositories .

\sphinxAtStartPar
For example, the co\sphinxhyphen{}author’s new repository, \sphinxcode{\sphinxupquote{gkt170}}, shows up on
the list of repositories (the dropdown) as \sphinxcode{\sphinxupquote{gkthiruvathukal/gkt170}}.

\sphinxAtStartPar
So you can now go ahead by selecting this newly created repository
from the list of repositories.  If all goes well, you should see the
following screen:

\noindent{\hspace*{\fill}\sphinxincludegraphics[height=300bp]{{hgrepositorysummary}.png}\hspace*{\fill}}

\sphinxAtStartPar
Somewhere on this screen, you should see this text:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Clone}\PYG{+w}{ }\PYG{k}{this}\PYG{+w}{ }\PYG{n+nf}{repository}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{size}\PYG{p}{:}\PYG{+w}{ }\PYG{l+m}{546}\PYG{+w}{ }\PYG{n}{bytes}\PYG{p}{)}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{HTTPS}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n}{SSH}
\PYG{n}{hg}\PYG{+w}{ }\PYG{n}{clone}\PYG{+w}{ }\PYG{n}{https}\PYG{p}{:}\PYG{c+c1}{//yourusername@bitbucket.org/yourusername/yourrepository}
\end{sphinxVerbatim}

\sphinxAtStartPar
Copy the command you see in the browser starting \sphinxcode{\sphinxupquote{hg clone}}, and paste it in
as a command in your terminal/DOS\sphinxhyphen{}shell window.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hg}\PYG{+w}{ }\PYG{n}{clone}\PYG{+w}{ }\PYG{n}{https}\PYG{p}{:}\PYG{c+c1}{//gkthiruvathukal@bitbucket.org/gkthiruvathukal/gkt170}
\end{sphinxVerbatim}

\sphinxAtStartPar
You will see some output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{http}\PYG{+w}{ }\PYG{n}{authorization}\PYG{+w}{ }\PYG{n}{required}
\PYG{n}{realm}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{Bitbucket}\PYG{p}{.}\PYG{n}{org}\PYG{+w}{ }\PYG{n}{HTTP}
\PYG{n}{user}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{gkthiruvathukal}
\PYG{n}{password}\PYG{p}{:}
\PYG{n}{destination}\PYG{+w}{ }\PYG{n}{directory}\PYG{p}{:}\PYG{+w}{ }\PYG{n}{gkt170}
\PYG{n}{no}\PYG{+w}{ }\PYG{n}{changes}\PYG{+w}{ }\PYG{n}{found}
\PYG{n}{updating}\PYG{+w}{ }\PYG{n}{to}\PYG{+w}{ }\PYG{n}{branch}\PYG{+w}{ }\PYG{k}{default}
\PYG{l+m}{0}\PYG{+w}{ }\PYG{n}{files}\PYG{+w}{ }\PYG{n}{updated}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{n}{files}\PYG{+w}{ }\PYG{n}{merged}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{n}{files}\PYG{+w}{ }\PYG{n}{removed}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{n}{files}\PYG{+w}{ }\PYG{n}{unresolved}
\end{sphinxVerbatim}

\sphinxAtStartPar
You have created a copy of the (empty) bitbucket repository in a
subdirectory named the same as yourrepository (gkt170 in the example).
The is the “checkout directory”, the top level of your copy.

\sphinxAtStartPar
Again, because the repository at Bitbucket is presently empty, the
above output actually makes sense. There are no files to be
updated. We’ll learn more about what this output means later. It is
possible to get \sphinxstyleemphasis{unresolved} files when you make changes that
introduce conflicts. We’re going to do whatever we can to avoid these
for the small projects in our course work. However, when working in
teams, it will become especially important that you and your
teammate(s) are careful to communicate changes you are making,
especially when changing the same files in a project.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
A version control system doesn’t replace the need for human communication and being
organized.
\end{sphinxadmonition}


\subsubsection{Add an .hgignore and Hello World file to your project}
\label{\detokenize{appendix/lab-versioncontrol:add-an-hgignore-and-hello-world-file-to-your-project}}
\sphinxAtStartPar
Change directory into the top\sphinxhyphen{}level directory of your local repository.
That should mean \sphinxcode{\sphinxupquote{cd}} to the directory whose name matches the
bitbucket repository name.

\sphinxAtStartPar
The following is an example of a “dot hgignore” file.  Mercurial will neither
list or otherwise pay attention the files in this list:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} This indicates that we are using shell\PYGZhy{}like matching logic
\PYGZsh{}    instead of regular expressions.
syntax: glob
\PYGZsh{} For Mac users
Thumbs.db
.DS\PYGZus{}Store
\PYGZsh{} This is where Xamarin Studio puts compiled stuff.
bin/
In case you compiled your own stuff, we ignore *.exe and *.dll
*.exe
*.dll
\PYGZsh{} This is a temporary debugging file generated by Xamarin Studio
*.pidb
\PYGZsh{} And one other thing we don\PYGZsq{}t need.
*.userprefs
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is a brief explanation of what we’ve included here and why:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{syntax: glob}} indicates that uses the “glob” syntax, which comes
from MS\sphinxhyphen{}DOS (the command prompt still found on Windows). Glob syntax
allows you to do special things like match all files having a
certain extension (e.g. \sphinxcode{\sphinxupquote{*.exe}} matches \sphinxcode{\sphinxupquote{Hello.exe}} and any
other filename with extension .exe.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Thumbs.db}} and \sphinxcode{\sphinxupquote{.DS\_Store}}. Unfortunately, the Mac is still
notorious for generating temporary files that serve no purpose,
except on OS X. In general, we try to keep these files out of our
repository and encourage you to do the same, especially if you are a
Mac user.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{*.exe}} and \sphinxcode{\sphinxupquote{*.dll}}. Anything that can be (re)produced by the
Mono or Xamarin Studio tools should be excluded. In particular, do not
keep these files in your repository. Today, they are quite small,
but in future development work, they can be large. Worse, they are
not text files (unlike your .cs files), so they cannot be stored
optimally in a version control system.

\item {} 
\sphinxAtStartPar
There are some other files produced by Xamarin Studio that we’ve put on
the exclusion list, including \sphinxcode{\sphinxupquote{*.pidb}} and \sphinxcode{\sphinxupquote{*.userprefs}}. The
reasoning for not keeping these is similar to that in the previous
case.

\end{itemize}

\sphinxAtStartPar
Now do the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Using your text editor, create a file \sphinxcode{\sphinxupquote{.hgignore}}. You can simply
copy and paste the above contents into this file.  Be careful of an editor
like notepad, which adds “.txt” to the end of file names by default.

\end{enumerate}
\begin{quote}
\begin{description}
\sphinxlineitem{\sphinxstylestrong{Windows}: To change from the default extension, use Save As, and change the}
\sphinxAtStartPar
file type from .txt by electing the drop\sphinxhyphen{}down menu beside file type, and
select “All files”.

\end{description}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Create or copy your existing \sphinxcode{\sphinxupquote{Hello World}} example, hello.cs to the
the \sphinxcode{\sphinxupquote{labs}} folder.

\item {} 
\sphinxAtStartPar
Let’s test whether .hgignore is having any effect. Go to the
\sphinxcode{\sphinxupquote{labs}} folder and compile the \sphinxcode{\sphinxupquote{Hello, World.}} example.

\item {} 
\sphinxAtStartPar
Verify that the .cs and .exe files are in the labs directory
(\sphinxcode{\sphinxupquote{ls}} on Linux or OS X; \sphinxcode{\sphinxupquote{dir}} on MS\sphinxhyphen{}DOS)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170/labs\PYGZdl{} mcs hello.cs
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170/labs\PYGZdl{} ls \PYGZhy{}l
total 8
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 gkt gkt  224 2012\PYGZhy{}02\PYGZhy{}20 20:02 hello.cs
\PYGZhy{}rwxrwxr\PYGZhy{}x 1 gkt gkt 3072 2012\PYGZhy{}02\PYGZhy{}20 20:05 hello.exe
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Check the status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170/labs\PYGZdl{} hg status
? .hgignore
? labs/hello.cs
\end{sphinxVerbatim}

\sphinxAtStartPar
What this tells us is that \sphinxcode{\sphinxupquote{.hgignore}} and \sphinxcode{\sphinxupquote{labs/hello.cs}} are not
presently being tracked by our version control system, Mercurial. The
file \sphinxcode{\sphinxupquote{labs/hello.exe}} is not shown, because it’s on the ignore list.

\sphinxAtStartPar
Note that we actually need to put the \sphinxcode{\sphinxupquote{.hgignore}} file under version
control if we want to use it wherever we happen to be working with our
stuff (i.e. when we’re not in the computer lab but, say, at home).

\item {} 
\sphinxAtStartPar
Add the file to version control:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170\PYGZdl{} hg add .hgignore

gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170\PYGZdl{} hg add labs/hello.cs
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Commit the changes, and then see the log entry
with the commands below.  If you set the .hgrc file,
the command somewhere inside your local repository could be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hg}\PYG{+w}{ }\PYG{n}{commit}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}adding an .hgignore file and Hello, World to the project\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you did not create .hgrc, you need also include identification
with \sphinxhyphen{}u yourName after \sphinxcode{\sphinxupquote{commit}}, as in
\begin{quote}

\sphinxAtStartPar
hg commit \sphinxhyphen{}u gkt \sphinxhyphen{}m “adding an .hgignore file and Hello, World to the project”
\end{quote}

\sphinxAtStartPar
It is Ok if your message wraps to a new line.  You can check the log entry created
by your commit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170\PYGZdl{} hg log
changeset:   0:9fe6ee1bf907
tag:         tip
user:        George K. Thiruvathukal \PYGZlt{}gkt@cs.luc.edu\PYGZgt{}
date:        Mon Feb 20 20:14:42 2012 \PYGZhy{}0600
summary:     adding an .hgignore file and Hello, World to the project
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Push the changes to Bitbucket with the following command.
(You’ll be prompted for user/password not shown here):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hg push
\end{sphinxVerbatim}

\sphinxAtStartPar
You should get a response like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pushing to https://gkthiruvathukal@bitbucket.org/gkthiruvathukal/gkt170
searching for changes
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 2 changes to 2 files
remote: bb/acl: gkthiruvathukal is allowed. accepted payload.
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Create an initial structure for your project}
\label{\detokenize{appendix/lab-versioncontrol:create-an-initial-structure-for-your-project}}
\sphinxAtStartPar
We suggest that you follow a scheme similar to what we use when working
with version control. We suggest that your source code goes in
one or more folders, like work, or homework and labs.

\sphinxAtStartPar
So let’s do it:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure you are in the checkout directory, or \sphinxcode{\sphinxupquote{cd}} to it.

\item {} 
\sphinxAtStartPar
Create directories:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir hw
mkdir labs
\end{sphinxVerbatim}

\sphinxAtStartPar
We will be creating items in each one of these folders during the lab.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Please note that most version control systems do not allow you to add \sphinxstyleemphasis{empty}
folders to the repository. You must create at least one file and \sphinxstylestrong{hg add} it
to the repository (and \sphinxstylestrong{hg add} and \sphinxstylestrong{hg push}) for the folder to actually
be created. The above was just intended to make you aware of a desired “organization”.
You are free to organize your project any way you like as long as we are able
to find your homework assignments.
\end{sphinxadmonition}

\end{enumerate}


\subsubsection{Create and Test Content}
\label{\detokenize{appendix/lab-versioncontrol:create-and-test-content}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
copy in or create a simple program in a directory you created,
like labs/hello.cs

\item {} 
\sphinxAtStartPar
Run it.

\item {} 
\sphinxAtStartPar
Now go back to the command prompt, and enterEnter:
\begin{quote}

\sphinxAtStartPar
hg status
\end{quote}

\sphinxAtStartPar
and produce a response like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{?}\PYG{+w}{ }\PYG{n}{labs}\PYG{o}{/}\PYG{n}{hello}\PYG{p}{.}\PYG{n}{cs}
\end{sphinxVerbatim}

\sphinxAtStartPar
Mercurial shows you the tracked files that are modified (none here)
or files not not being tracked (after a ‘?’),
except for those files explicitly ignored.  As you can see,
the source (.cs) file is shown, but
no “binary” objects (like an .exe file),
since you gave instructions to ignore all such files.

\item {} 
\sphinxAtStartPar
Add the new solution/projects to Mercurial. At this point, if the above list looks
“reasonable” to you, you can go ahead and just add \sphinxstyleemphasis{everything}. The \sphinxstylestrong{hg} command
makes this easy for you. Instead of adding the specific files,
you can just type the following (nothing after the add):
\begin{quote}

\sphinxAtStartPar
hg add
\end{quote}

\sphinxAtStartPar
and produce a response like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{adding}\PYG{+w}{ }\PYG{n}{do\PYGZus{}the\PYGZus{}math}\PYG{p}{.}\PYG{n}{cs}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you inadvertently added something that you truly don’t want in the repository, you
can use the \sphinxstylestrong{hg rm} command to remove it. We have nothing at the moment that
we want to remove, but want to make you aware that correcting mistakes is possible.

\item {} 
\sphinxAtStartPar
As before, commit and push.  Here is a sequence from Dr. Thiruvathukal’s Mac:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170\PYGZdl{} hg commit \PYGZhy{}m \PYGZdq{}adding hello program\PYGZdq{}
gkt@gkt\PYGZhy{}mini:\PYGZti{}/gkt170\PYGZdl{} hg push
pushing to https://gkthiruvathukal@bitbucket.org/gkthiruvathukal/gkt170\PYGZbs{}
searching for changes
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 1 change to 1 file
remote: bb/acl: gkthiruvathukal is allowed. accepted payload.
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Verify that your stuff really made it to bitbucket.org}
\label{\detokenize{appendix/lab-versioncontrol:verify-that-your-stuff-really-made-it-to-bitbucket-org}}
\sphinxAtStartPar
At this point, it is entirely possible that you need some convincing to believe that
everything we’ve been doing thus far is really making it to your repository at Bitbucket.
Luckily, this is where having a web interface really can help us.

\sphinxAtStartPar
Do the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Log into bitbucket.org if you are not already logged in.

\item {} 
\sphinxAtStartPar
Go to Repositories and look for your repository. In the authors case, it is under
\sphinxcode{\sphinxupquote{gkthiruvathukal / gkt170}}.

\item {} 
\sphinxAtStartPar
It pays to take a quick look at the dashboard. You’ll see the \sphinxstyleemphasis{recent commits} on the
main screen. You should see at least two commits from our lab session thus far, both
of which likely happened just “minutes ago”.

\item {} 
\sphinxAtStartPar
You can click on any revision to see what changes were made. It is ok to do so at this
time, but we’re going to take a look at the powerful capability of “looking at the
source”. So go to the \sphinxstyleemphasis{Source} tab.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350bp]{{bitbucket-source}.png}\hspace*{\fill}}

\item {} 
\sphinxAtStartPar
If all was done properly, you will see .hgignore and labs. These
were all the result of our earlier sequence of commit+push operations. You can click on
any folder to drill into the hierarchy of folders/files that have been pushed
to Bitbucket (from your local repository). In labs you find
your source code (for hello.cs). Then you
can look at it\textendash{}through the web! When you do so, you’ll see something like this.

\noindent{\hspace*{\fill}\sphinxincludegraphics[height=290bp]{{HelloWorld}.png}\hspace*{\fill}}

\end{enumerate}


\subsubsection{Working between lab and home (or home and lab)}
\label{\detokenize{appendix/lab-versioncontrol:working-between-lab-and-home-or-home-and-lab}}
\sphinxAtStartPar
It may not be immediately obvious, but what we have just shown you is how to work between
the classroom/lab environment and home. In the typical scenario, when you go to your
desk (or laptop), you will go through the following lifecycle:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hg pull}: To gather any changes that you made at another location. You are always
pulling changes from the repository stored at Bitbucket, which is acting as our
intermediary. Being “in the cloud” it is a great place to keep stuff without having
to worry (for the most part) about the repository getting lost.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hg update}: To update your local copy of the repository with all of the changes
that you just pulled down from Bitbucket.

\item {} 
\sphinxAtStartPar
Create or modify your folders/files as desired.

\item {} 
\sphinxAtStartPar
If any files that you want included were just created, use \sphinxstylestrong{hg add}.  It does not
hurt to use this command, even if nothing was added.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hg commit \sphinxhyphen{}m message.}: Save any changes you’ve made, to your local repository only.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hg push}: Push the changes you’ve stashed in your local repository to the Bitbucket
repository.

\end{itemize}

\sphinxAtStartPar
You might wonder why the pull/update and commit/push operations are separate. For a team
of one (or two, if you have a pair), it is not likely that you’d make a mistake when
coordinating changes to a central repository. In a larger team, however, some coordination
is required. We’re not going into all of those details in this lab, of course, but will
likely revisit this topic as we get closer to the team project, which we think will make
you thankful for having a version control system.


\subsubsection{Getting our examples}
\label{\detokenize{appendix/lab-versioncontrol:getting-our-examples}}
\sphinxAtStartPar
We’re going to conclude by taking this opportunity to introduce you to how \sphinxstyleemphasis{we} (Drs.
Harrington and Thiruvathukal) are actually using the stuff we are teaching to work as
a team on developing the book and examples.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Pick a different location (outside of your repository folder and its subfolders)
to check out our stuff from Bitbucket:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hg clone https://bitbucket.org/loyolachicagocs\PYGZus{}books/introcs\PYGZhy{}csharp\PYGZhy{}examples
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Don’t worry about breaking anything. Because Bitbucket knows what users are allowed
to push changes to our repository, anything you change in your copy won’t affect us.

\item {} 
\sphinxAtStartPar
Look under the source tab on the project page.

\item {} 
\sphinxAtStartPar
For example, if you performed a clone to introcs\sphinxhyphen{}csharp\sphinxhyphen{}examples, you should be able to change directory to introcs\sphinxhyphen{}csharp\sphinxhyphen{}examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkt@gkt\PYGZhy{}mini:\PYGZti{}\PYGZdl{} cd introcs\PYGZhy{}csharp\PYGZhy{}examples
gkt@gkt\PYGZhy{}mini:\PYGZti{}/introcs\PYGZhy{}csharp\PYGZhy{}examples\PYGZdl{} ls
addition1
...
write\PYGZus{}test
\end{sphinxVerbatim}

\sphinxAtStartPar
(Most output has been eliminated for conciseness.)

\item {} 
\sphinxAtStartPar
You can explore subfolders to see our programs.

\end{enumerate}

\sphinxstepscope

\index{Mercurial@\spxentry{Mercurial}}\index{version control@\spxentry{version control}}\ignorespaces 

\section{Mercurial and Teamwork}
\label{\detokenize{appendix/hgteamwork:mercurial-and-teamwork}}\label{\detokenize{appendix/hgteamwork:hg-and-teamwork}}\label{\detokenize{appendix/hgteamwork:index-0}}\label{\detokenize{appendix/hgteamwork::doc}}
\sphinxAtStartPar
As this course has a team project, this lecture is about how to work as
a team and make effective use of the version control system, Mercurial,
that we have been using throughout the semester. While the focus is on
the use of Mercurial, the principles we are introducing here can be
adapted to other situations (and alternate version control systems).


\subsection{Planning and Communication}
\label{\detokenize{appendix/hgteamwork:planning-and-communication}}
\sphinxAtStartPar
Two of the most important aspects when it comes to teamwork are planning
and communication. In the real world, planning is often referred to as
\sphinxstyleemphasis{project management}. And communication often takes the form of regular
team \sphinxstyleemphasis{meetings}.

\sphinxAtStartPar
In later courses (e.g. software engineering) there is greater emphasis
placed on thinking more broadly about software process. We’re not going
to cover SE in depth here but want you to be aware that software process
is an important topic. Planning and communication are always supporting
ingredients of a \sphinxstyleemphasis{good} software process.

\sphinxAtStartPar
At the level of actual programming, when two folks are working on the
same project, it is important to think about how you can organize your
work so each person on the team can get something done. As we’ve been
learning throughout the semester, the C\# language gives us a way to
organize our code using projects (with Xamarin Studio). Within a project
we can organize it as a collection of files, each of which maintains
part of the solution to a problem.  These parts are typically organized
using classes within a namespace and methods.

\sphinxAtStartPar
So the key to working together\textendash{}and apart\textendash{}is to spend some time, initially,
planning out the essential organization of a project and the files within
it. Much like writing a term paper, you can create classes and methods
that are needed\textendash{}without writing the actual \sphinxstyleemphasis{body} of the methods\textendash{}and then
commit your code to the repository. Then each member of the team can work
on parts of the code and test them independently. Then you can sit together
again as a pair to integrate the work you’ve done independently.

\sphinxAtStartPar
It’s easier said than done, but this is intended as a suggestion for
how to collaborate.

\sphinxAtStartPar
In any event, the above suggests that you actually need to
\sphinxstyleemphasis{communicate} if you want to get anything done. You should start by
discussing what needs to be done and work in \sphinxstyleemphasis{real time} to do what
has been described above.  Then you start coding. As you are coding,
you are going to realize that as well as you planned the work to be
done, you “forgot” or “misunderstood” some aspect. When this happens,
you and your partner(s) need to communicate.

\sphinxAtStartPar
In the modern era of software development, we are richly blessed with
synchronous communication methods such as instant messaging, texting,
group chat, and other forms of synchronous collaboration. When you and
your partner(s) are working on the project, we highly encourage you to
keep a chat window open (Google Talk, AIM, Yahoo, IRC, whatever) and
use it to communicate any issues as they arise.


\subsection{Typical Scenario}
\label{\detokenize{appendix/hgteamwork:typical-scenario}}
\sphinxAtStartPar
In general, when working with Mercurial, you will find yourself using the
following commands in roughly this order:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg incoming}}: look for incoming changes that were either made by
yourself or your partner(s). We say “by yourself” because it is clearly
possible that you are working on another computer somewhere else (laptop,
home computer) and pushed some changes. So it is a good habit to see
whether “anything has changed” since the last time you looked, even if
you looked recently.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg pull}}: If there are incoming changes showing up as incoming, then
you should in fact pull them in. This will stage the changes locally
but they will not be incorporated until you type \sphinxcode{\sphinxupquote{hg update}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg update}}: Absorbs all changes that were pulled from your remote
repository. This operation has the potential to \sphinxstyleemphasis{overwrite} changes you
are currently making, so you should make sure that the incoming changes
that you observed above are sensible. For example, if you are editing
a file named \sphinxcode{\sphinxupquote{examples/MyProject/my\_project.cs}} and the incoming log
suggests that the same file has been modified, you’re likely to end up
with a conflict when performing the update. (We’ll cover conflict
resolution shortly.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg add}}: Whenever you add files to your folder, if you want them to
be in the repository, you always need to \sphinxstyleemphasis{add} them. It is very easy to
forget to do so. The \sphinxcode{\sphinxupquote{hg status}} command can be used to figure out
files that \sphinxstyleemphasis{might} need to be added.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg status}}: This command will become one of your best friends. You
This typically tells you what has happened since you started your work
in this directory (and since the last commit/push cycle). You especially
want to keep on the lookout for the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{?}}: This means that a file is \sphinxstyleemphasis{untracked} in the repository. If you
see a file with the \sphinxcode{\sphinxupquote{?}} status that is important, you’ll want
to add it using \sphinxcode{\sphinxupquote{hg add}} as explained above.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{M}}: This means that a file has been \sphinxstyleemphasis{modified}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}}: This means that a file has been \sphinxstyleemphasis{added}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg commit}}: In general, you should commit all changes to your
repository, especially before you leave the lab for the day. It is important
to note that committing is a \sphinxstyleemphasis{local} operation and does not affect the
remote repository (at bitbucket.org) until a corresponding push has
been done.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hg push}}: Almost immediately after a commit, it makes sense to do a
push, especially if you are in the lab and will be continuing your work
on other computers. In addition, as you’ve observed with previous homework,
it is the only way to ensure that you can view the code on BitBucket (our
hosting site for Mercurial projects).

\end{itemize}


\subsection{Conflict Avoidance}
\label{\detokenize{appendix/hgteamwork:conflict-avoidance}}
\sphinxAtStartPar
Inevitably, when you are working on project, you are likely to end up
in a situation where you and your partner(s) make changes that
conflict with one another. In many cases, the version control software
can automatically merge the changes. Here are just a few examples of
where it is possible to do so:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You make changes to different files.

\item {} 
\sphinxAtStartPar
You make additions to the repository.

\item {} 
\sphinxAtStartPar
You make changes to a common file that do not overlap. An example of
this might be where you have two functions in your program and both
you and your partner are careful not to modify them.

\end{itemize}

\sphinxAtStartPar
In general, we encourage you to coordinate your efforts, especially
when you are doing something like the third situation.

\sphinxAtStartPar
Where you get into trouble is when there are changes to a common file
that conflict with one another. When this happens, you have two
choices in practice:
\begin{itemize}
\item {} 
\sphinxAtStartPar
use \sphinxcode{\sphinxupquote{hg merge}} and \sphinxcode{\sphinxupquote{hg resolve}} to merge your changes.

\item {} 
\sphinxAtStartPar
make a copy of the conflicting files (e.g. Copy \sphinxcode{\sphinxupquote{hello.cs}} to
\sphinxcode{\sphinxupquote{hello.cs\sphinxhyphen{}backup}} and use \sphinxcode{\sphinxupquote{hg update \sphinxhyphen{}\sphinxhyphen{}clean}} (changing your
copy to match the current version in the remote repository) to just
accept the latest versions of all files from the repository.

\end{itemize}

\sphinxAtStartPar
In our experience, the first option is tricky. You are given the
option to perform the merge anyway or use a merge tool to select the
changes of interest (and decide between them).

\sphinxAtStartPar
The second option basically results in two copies of the file. You can
open up your editor to compare the files side\sphinxhyphen{}by\sphinxhyphen{}side or use a tool
like \sphinxcode{\sphinxupquote{diff}} on Unix or a Mac, which gives a side\sphinxhyphen{}by\sphinxhyphen{}side comparison:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{diff}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{+w}{ }\PYG{n}{hello}\PYG{p}{.}\PYG{n}{cs}\PYG{+w}{ }\PYG{n}{my\PYGZus{}hello}\PYG{p}{.}\PYG{n}{cs}
\end{sphinxVerbatim}

\sphinxAtStartPar
(You will need to expand the width of your console window to see clearly!)

\sphinxAtStartPar
This tool is not built into Windows.  In the Windows lab, you can use the
much less visually helpful

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fc}\PYG{+w}{ }\PYG{n}{hello}\PYG{p}{.}\PYG{n}{cs}\PYG{+w}{ }\PYG{n}{my\PYGZus{}hello}\PYG{p}{.}\PYG{n}{cs}
\end{sphinxVerbatim}

\sphinxAtStartPar
to show differing segments from each file.
You can also download difference display tools for Windows that are more
visually helpful.  One of many choices is at \sphinxurl{http://winmerge.org}.


\subsection{E\sphinxhyphen{}mail Notifications}
\label{\detokenize{appendix/hgteamwork:e-mail-notifications}}
\sphinxAtStartPar
One of the best ways to avoid conflicts when working on a team is to
enable e\sphinxhyphen{}mail notification on your repository.

\sphinxAtStartPar
Bitbucket, the hosting service we are using and recommending for our
students, provides full support for e\sphinxhyphen{}mail notification. Whenever you
or your partner(s) push changes to the hosted repository, an e\sphinxhyphen{}mail
will be generated.

\sphinxAtStartPar
These are the steps to set it up. (Owing to the changing nature of web
interfaces, we are providing generic instructions that should be
adaptable if the Bitbucket service decides to change its web user interface.)
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure your repository is selected. This is always the
especially when you visit your repository by URL.

\item {} 
\sphinxAtStartPar
Select the administrative (Admin) tab.

\item {} 
\sphinxAtStartPar
Select Services (left\sphinxhyphen{}hand\sphinxhyphen{}side navigation).

\item {} 
\sphinxAtStartPar
Add the Email or Email Diff service. These services are basically
equivalent, but one will generate links so you can view the
differences that were just pushed. We recommend Email Diff.

\item {} 
\sphinxAtStartPar
Add the email notification address. You can only have one address.
A good way to overcome this limitation is to set up a group service,
say, at Google Groups.

\end{enumerate}


\subsection{Communication is Key to Success}
\label{\detokenize{appendix/hgteamwork:communication-is-key-to-success}}
\sphinxAtStartPar
At the risk of repeating ourselves, we close by reminding you of the
central importance of good communication. The authors of this book
communicate when it comes to their changes\textendash{}even before we make
them. Yet we occasionally trip over each other, and there is usually a
fair amount of manual reconciliation required to deal with conflicts
when we end up touching the same file by mistake.

\sphinxAtStartPar
When you absolutely and positively need to change a common file, it is
important to ask yourself the important question: Shouldn’t we be
sitting together to make these changes? It’s a rhetorical question,
but working closely together, either in the same room or through a
chat session/phone call, can result in significantly fewer headaches,
especially during the early stages of a project.

\sphinxAtStartPar
So please take this time to stop what you are doing and
communicate. You’ll know your communication is good if you never need
to do anything that has been described on this page. Then again, we’re
human. So you it is likely to happen at least once. (We know from
experience but are doing everything possible to avoid conflicts in our
work!)

\sphinxstepscope


\section{Acknowledgments}
\label{\detokenize{appendix/acknowledgments:acknowledgments}}\label{\detokenize{appendix/acknowledgments::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The Sphinx team at \sphinxurl{http://sphinx.pocoo.org} for creating such an awesome documentation tool.

\item {} 
\sphinxAtStartPar
The Bitbucket team at \sphinxurl{http://bitbucket.org} for giving us a great place to collaborate. We are now moving to GitHub at \sphinxurl{http://github.com} but still think very highly of the Bitbucket team, especially for students and faculty who need to do private projects. (We still use both.)

\item {} 
\sphinxAtStartPar
Jeremy Chalmer at \sphinxurl{http://jchalmer.com/} for his past work to get a \sphinxstyleemphasis{nice} Twitter Bootstrap theme working with Sphinx. We’re now using the Sphinx Bootstrap Theme project at \sphinxurl{http://loose-bits.com/2013/04/10/sphinx-bootstrap-theme-bootswatch.html} but are indebted to Jeremy for inspiring us to take Bootstrap seriously.

\item {} 
\sphinxAtStartPar
Speaking of Sphinx Bootstrap Theme, I wish to thank the two developers (Ryan Roemer and Russell Sim) for adding support for some missing features, especially to support shorter navigation links, links to key pages (e.g. genindex). Their tireless dedication and friendly attitude are what makes free/open source software so awesome!

\end{itemize}

\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\begin{sphinxthebibliography}{Wikipedi}
\bibitem[WirthADP]{arrays/sorting:wirthadp}
\sphinxAtStartPar
Niklaus Wirth, Algorithms + Data Structures = Programs, Prentice Hall, 1976.
\bibitem[WikipediaShellSort]{arrays/sorting:wikipediashellsort}
\sphinxAtStartPar
\sphinxurl{http://en.wikipedia.org/wiki/Shellsort}
\bibitem[uClibc]{arrays/sorting:uclibc}
\sphinxAtStartPar
\sphinxurl{http://en.wikipedia.org/wiki/UClibc}
\bibitem[TCSortingJava]{arrays/sorting:tcsortingjava}
\sphinxAtStartPar
\sphinxurl{http://tools-of-computing.com/tc/CS/Sorts/SortAlgorithms.htm}
\bibitem[CamelCase]{appendix/homework-gradecalculation2:camelcase}
\sphinxAtStartPar
\sphinxurl{http://en.wikipedia.org/wiki/CamelCase}
\bibitem[UPennCSharp]{appendix/homework-gradecalculation2:upenncsharp}
\sphinxAtStartPar
\sphinxurl{http://www.cis.upenn.edu/~cis193/csstyle.html}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}